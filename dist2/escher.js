(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory((function webpackLoadOptionalExternalModule() { try { return require("@jupyter-widgets/base"); } catch(e) {} }()));
	else if(typeof define === 'function' && define.amd)
		define(["@jupyter-widgets/base"], factory);
	else if(typeof exports === 'object')
		exports["escher"] = factory((function webpackLoadOptionalExternalModule() { try { return require("@jupyter-widgets/base"); } catch(e) {} }()));
	else
		root["escher"] = factory(root["@jupyter-widgets/base"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__111__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 57);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ArrayProto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ObjProto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return SymbolProto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return push; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return toString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return hasOwnProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return supportsArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return supportsDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return nativeIsArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return nativeKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return nativeCreate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return nativeIsView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return _isNaN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return _isFinite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return hasEnumBug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return nonEnumerableProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MAX_ARRAY_INDEX; });
// Current version.
var VERSION = '1.13.6';

// Establish the root object, `window` (`self`) in the browser, `global`
// on the server, or `this` in some virtual machines. We use `self`
// instead of `window` for `WebWorker` support.
var root = (typeof self == 'object' && self.self === self && self) ||
          (typeof global == 'object' && global.global === global && global) ||
          Function('return this')() ||
          {};

// Save bytes in the minified (but not gzipped) version:
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

// Create quick reference variables for speed access to core prototypes.
var push = ArrayProto.push,
    slice = ArrayProto.slice,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty;

// Modern feature detection.
var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
    supportsDataView = typeof DataView !== 'undefined';

// All **ECMAScript 5+** native function implementations that we hope to use
// are declared here.
var nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeCreate = Object.create,
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

// Create references to these builtin functions because we override them.
var _isNaN = isNaN,
    _isFinite = isFinite;

// Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
  'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

// The largest integer that can be represented exactly.
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41)))

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ color; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ rgb; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ hsl; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ lab; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ hcl; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ cubehelix; });

// CONCATENATED MODULE: ./node_modules/d3-color/src/define.js
/* harmony default export */ var define = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// CONCATENATED MODULE: ./node_modules/d3-color/src/color.js


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

// CONCATENATED MODULE: ./node_modules/d3-color/src/math.js
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// CONCATENATED MODULE: ./node_modules/d3-color/src/lab.js




var Kn = 18,
    Xn = 0.950470, // D65 standard referent
    Yn = 1,
    Zn = 1.088830,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Rgb(
      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

// CONCATENATED MODULE: ./node_modules/d3-color/src/cubehelix.js




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

// CONCATENATED MODULE: ./node_modules/d3-color/index.js





/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "create", function() { return /* reexport */ create; });
__webpack_require__.d(__webpack_exports__, "creator", function() { return /* reexport */ creator["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "local", function() { return /* reexport */ local; });
__webpack_require__.d(__webpack_exports__, "matcher", function() { return /* reexport */ matcher["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "mouse", function() { return /* reexport */ mouse["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "namespace", function() { return /* reexport */ namespace["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "namespaces", function() { return /* reexport */ namespaces["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "clientPoint", function() { return /* reexport */ point["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "select", function() { return /* reexport */ src_select["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "selectAll", function() { return /* reexport */ selectAll; });
__webpack_require__.d(__webpack_exports__, "selection", function() { return /* reexport */ selection["b" /* default */]; });
__webpack_require__.d(__webpack_exports__, "selector", function() { return /* reexport */ src_selector["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "selectorAll", function() { return /* reexport */ selectorAll["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "style", function() { return /* reexport */ style["b" /* styleValue */]; });
__webpack_require__.d(__webpack_exports__, "touch", function() { return /* reexport */ touch["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "touches", function() { return /* reexport */ src_touches; });
__webpack_require__.d(__webpack_exports__, "window", function() { return /* reexport */ src_window["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "event", function() { return /* reexport */ on["c" /* event */]; });
__webpack_require__.d(__webpack_exports__, "customEvent", function() { return /* reexport */ on["a" /* customEvent */]; });

// EXTERNAL MODULE: ./node_modules/d3-selection/src/creator.js
var creator = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/select.js
var src_select = __webpack_require__(28);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/create.js



/* harmony default export */ var create = (function(name) {
  return Object(src_select["a" /* default */])(Object(creator["a" /* default */])(name).call(document.documentElement));
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/local.js
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// EXTERNAL MODULE: ./node_modules/d3-selection/src/matcher.js
var matcher = __webpack_require__(33);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/mouse.js
var mouse = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespace.js
var namespace = __webpack_require__(25);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespaces.js
var namespaces = __webpack_require__(18);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/point.js
var point = __webpack_require__(17);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/index.js + 31 modules
var selection = __webpack_require__(11);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selectAll.js


/* harmony default export */ var selectAll = (function(selector) {
  return typeof selector === "string"
      ? new selection["a" /* Selection */]([document.querySelectorAll(selector)], [document.documentElement])
      : new selection["a" /* Selection */]([selector == null ? [] : selector], selection["c" /* root */]);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selector.js
var src_selector = __webpack_require__(24);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selectorAll.js
var selectorAll = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/style.js
var style = __webpack_require__(34);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/touch.js
var touch = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/sourceEvent.js
var sourceEvent = __webpack_require__(29);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/touches.js



/* harmony default export */ var src_touches = (function(node, touches) {
  if (touches == null) touches = Object(sourceEvent["a" /* default */])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = Object(point["a" /* default */])(node, touches[i]);
  }

  return points;
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/window.js
var src_window = __webpack_require__(26);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/on.js
var on = __webpack_require__(9);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/index.js




















/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ src_value; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ number; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ round; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ string; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ interpolateTransformCss; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ interpolateTransformSvg; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ zoom; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ src_rgb; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ cubehelixLong; });

// UNUSED EXPORTS: interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateObject, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, quantize

// EXTERNAL MODULE: ./node_modules/d3-color/index.js + 5 modules
var d3_color = __webpack_require__(1);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ var src_basis = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/basisClosed.js


/* harmony default export */ var basisClosed = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/color.js


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function color_hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/rgb.js





/* harmony default export */ var src_rgb = ((function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color["f" /* rgb */])(start)).r, (end = Object(d3_color["f" /* rgb */])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(d3_color["f" /* rgb */])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(src_basis);
var rgbBasisClosed = rgbSpline(basisClosed);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/array.js


/* harmony default export */ var array = (function(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = src_value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/date.js
/* harmony default export */ var date = (function(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/number.js
/* harmony default export */ var number = (function(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/object.js


/* harmony default export */ var object = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = src_value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/string.js


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ var string = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/value.js









/* harmony default export */ var src_value = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = Object(d3_color["a" /* color */])(b)) ? (b = c, src_rgb) : string)
      : b instanceof d3_color["a" /* color */] ? src_rgb
      : b instanceof Date ? date
      : Array.isArray(b) ? array
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/round.js
/* harmony default export */ var round = (function(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ var decompose = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/parse.js


var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/index.js



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/zoom.js
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
/* harmony default export */ var zoom = (function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    }
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    }
  }

  i.duration = S * 1000;

  return i;
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/hsl.js



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color["d" /* hsl */])(start)).h, (end = Object(d3_color["d" /* hsl */])(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ var src_hsl = (hsl(color_hue));
var hslLong = hsl(nogamma);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/lab.js



function lab(start, end) {
  var l = nogamma((start = Object(d3_color["e" /* lab */])(start)).l, (end = Object(d3_color["e" /* lab */])(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/hcl.js



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color["c" /* hcl */])(start)).h, (end = Object(d3_color["c" /* hcl */])(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ var src_hcl = (hcl(color_hue));
var hclLong = hcl(nogamma);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/cubehelix.js



function cubehelix_cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color["b" /* cubehelix */])(start)).h, (end = Object(d3_color["b" /* cubehelix */])(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ var src_cubehelix = (cubehelix_cubehelix(color_hue));
var cubehelixLong = cubehelix_cubehelix(nogamma);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/quantize.js
/* harmony default export */ var quantize = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/index.js



















/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global Blob, XMLSerializer, Image, btoa */

var vkbeautify = __webpack_require__(40);
var _ = __webpack_require__(5);
var d3_json = __webpack_require__(31).json;
var d3_text = __webpack_require__(31).text;
var d3_csvParseRows = __webpack_require__(38).csvParseRows;
var d3_selection = __webpack_require__(2).selection;

try {
  var saveAs = __webpack_require__(59).saveAs;
} catch (e) {
  console.warn('Not a browser, so FileSaver.js not available.');
}

module.exports = {
  set_options: set_options,
  remove_child_nodes: remove_child_nodes,
  load_css: load_css,
  load_files: load_files,
  load_the_file: load_the_file,
  make_class: make_class,
  class_with_optional_new: class_with_optional_new,
  setup_defs: setup_defs,
  draw_an_object: draw_an_object,
  draw_a_nested_object: draw_a_nested_object,
  make_array: make_array,
  make_array_ref: make_array_ref,
  compare_arrays: compare_arrays,
  arrayToObject: arrayToObject,
  clone: clone,
  extend: extend,
  uniqueConcat: uniqueConcat,
  unique_strings_array: unique_strings_array,
  debounce: debounce,
  object_slice_for_ids: object_slice_for_ids,
  object_slice_for_ids_ref: object_slice_for_ids_ref,
  c_plus_c: c_plus_c,
  c_minus_c: c_minus_c,
  c_times_scalar: c_times_scalar,
  download_json: download_json,
  load_json: load_json,
  load_json_or_csv: load_json_or_csv,
  downloadSvg: downloadSvg,
  downloadPng: downloadPng,
  rotate_coords_recursive: rotate_coords_recursive,
  rotate_coords: rotate_coords,
  get_angle: get_angle,
  to_degrees: to_degrees,
  angleNorm: angleNorm,
  to_radians: to_radians,
  to_radians_norm: to_radians_norm,
  angle_for_event: angle_for_event,
  distance: distance,
  check_undefined: check_undefined,
  compartmentalize: compartmentalize,
  decompartmentalize: decompartmentalize,
  mean: mean,
  median: median,
  quartiles: quartiles,
  random_characters: random_characters,
  generate_map_id: generate_map_id,
  check_for_parent_tag: check_for_parent_tag,
  name_to_url: name_to_url,
  get_document: get_document,
  get_window: get_window,
  d3_transform_catch: d3_transform_catch
  // check_browser: check_browser


  /**
   * Check if Blob is available, and alert if it is not.
   */
};function _check_filesaver() {
  try {
    var isFileSaverSupported = !!new Blob();
  } catch (e) {
    alert('Blob not supported');
  }
}

function set_options(options, defaults, must_be_float) {
  if (options === undefined || options === null) {
    return defaults;
  }
  var i = -1;
  var out = {};
  for (var key in defaults) {
    var has_key = key in options && options[key] !== null && options[key] !== undefined;
    var val = has_key ? options[key] : defaults[key];
    if (must_be_float && key in must_be_float) {
      val = parseFloat(val);
      if (isNaN(val)) {
        if (has_key) {
          console.warn('Bad float for option ' + key);
          val = parseFloat(defaults[key]);
          if (isNaN(val)) {
            console.warn('Bad float for default ' + key);
            val = null;
          }
        } else {
          console.warn('Bad float for default ' + key);
          val = null;
        }
      }
    }
    out[key] = val;
  }
  return out;
}

function remove_child_nodes(selection) {
  /** Removes all child nodes from a d3 selection
    */
  var node = selection.node();
  while (node.hasChildNodes()) {
    node.removeChild(node.lastChild);
  }
}

function load_css(css_path, callback) {
  var css = "";
  if (css_path) {
    d3_text(css_path, function (error, text) {
      if (error) {
        console.warn(error);
      }
      css = text;
      callback(css);
    });
  }
  return false;
}

function _ends_with(str, suffix) {
  return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

/**
 * Load a file.
 * @param {} t - this context for callback. Should be an object.
 * @param {} files_to_load - A filename to load. Must be JSON or CSS.
 * @param {} callback - Function to run after the file is loaded. Takes the
 * arguments error and data.
 * @param {} value - If the value is specified, just assign it and do not
 * execute the ajax query.
 */
function load_the_file(t, file, callback, value) {
  if (value) {
    if (file) console.warn('File ' + file + ' overridden by value.');
    callback.call(t, null, value);
    return;
  }
  if (!file) {
    callback.call(t, 'No filename', null);
    return;
  }
  if (_ends_with(file, 'json')) {
    d3_json(file, function (e, d) {
      callback.call(t, e, d);
    });
  } else if (_ends_with(file, 'css')) {
    d3_text(file, function (e, d) {
      callback.call(t, e, d);
    });
  } else {
    callback.call(t, 'Unrecognized file type', null);
  }
  return;
}

function load_files(t, files_to_load, final_callback) {
  /** Load multiple files asynchronously by calling utils.load_the_file.
       t: this context for callback. Should be an object.
       files_to_load: A list of objects with the attributes:
       { file: a_filename.json, callback: a_callback_fn }
       File must be JSON or CSS.
       final_callback: Function that runs after all files have loaded.
   */
  if (files_to_load.length === 0) final_callback.call(t);
  var i = -1,
      remaining = files_to_load.length;
  while (++i < files_to_load.length) {
    load_the_file(t, files_to_load[i].file, function (e, d) {
      this.call(t, e, d);
      if (! --remaining) final_callback.call(t);
    }.bind(files_to_load[i].callback), files_to_load[i].value);
  }
}

/**
 * Create a constructor that returns a new object with our without the 'new'
 * keyword.
 *
 * Adapted from Hubert Kauker (MIT Licensed), John Resig (MIT Licensed).
 * http://stackoverflow.com/questions/7892884/simple-class-instantiation
 */
function make_class() {
  var is_internal;
  var constructor = function constructor(args) {
    if (this instanceof constructor) {
      if (typeof this.init === 'function') {
        this.init.apply(this, is_internal ? args : arguments);
      }
    } else {
      is_internal = true;
      var instance = new constructor(arguments);
      is_internal = false;
      return instance;
    }
  };
  return constructor;
}

/**
 * Return a class that can be instantiated without the new keyword.
 * @param {Class} AClass - Any ES6 class.
 */
function class_with_optional_new(AClass) {
  return new Proxy(AClass, {
    apply: function apply(Target, thisArg, args) {
      return new (Function.prototype.bind.apply(Target, [null].concat(args)))();
    }
  });
}

function setup_defs(svg, style) {
  // add stylesheet
  svg.select("defs").remove();
  var defs = svg.append("defs");
  // make sure the defs is the first node
  var node = defs.node();
  node.parentNode.insertBefore(node, node.parentNode.firstChild);
  defs.append("style").attr("type", "text/css").text(style);
  return defs;
}

/**
 * Run through the d3 data binding steps for an object. Also checks to make sure
 * none of the values in the *object* are undefined, and ignores those.
 *
 * The create_function, update_function, and exit_function CAN modify the input
 * data object.
 *
 * @param {} container_sel - A d3 selection containing all objects.
 *
 * @param {} parent_node_selector - A selector string for a subselection of
 * container_sel.
 *
 * @param {} children_selector - A selector string for each DOM element to bind.
 *
 * @param {} object - An object to bind to the selection.
 *
 * @param {} id_key - The key that will be used to store object IDs in the bound
 * data points.
 *
 * @param {} create_function - A function for enter selection. Create function
 * must return a selection of the new nodes.
 *
 * @param {} update_function - A function for update selection.
 *
 * @param {} exit_function - A function for exit selection.
 */
function draw_an_object(container_sel, parent_node_selector, children_selector, object, id_key, create_function, update_function, exit_function) {
  var draw_object = {};

  for (var id in object) {
    if (object[id] === undefined) {
      console.warn('Undefined value for id ' + id + ' in object. Ignoring.');
    } else {
      draw_object[id] = object[id];
    }
  }

  var sel = container_sel.select(parent_node_selector).selectAll(children_selector).data(make_array_ref(draw_object, id_key), function (d) {
    return d[id_key];
  });

  // enter: generate and place reaction
  var update_sel = create_function ? create_function(sel.enter()).merge(sel) : sel;

  // update: update when necessary
  if (update_function) {
    update_sel.call(update_function);
  }

  // exit
  if (exit_function) {
    sel.exit().call(exit_function);
  }
}

/**
 * Run through the d3 data binding steps for an object that is nested within
 * another element with D3 data.
 *
 * The create_function, update_function, and exit_function CAN modify the input
 * data object.
 *
 * @param {} container_sel - A d3 selection containing all objects.
 *
 * @param {} children_selector - A selector string for each DOM element to bind.
 *
 * @param {} object_data_key - A key for the parent object containing data for
 * the new selection.
 *
 * @param {} id_key - The key that will be used to store object IDs in the bound
 * data points.
 *
 * @param {} create_function - A function for enter selection. Create function
 * must return a selection of the new nodes.
 *
 * @param {} update_function - A function for update selection.
 *
 * @param {} exit_function - A function for exit selection.
 */
function draw_a_nested_object(container_sel, children_selector, object_data_key, id_key, create_function, update_function, exit_function) {
  var sel = container_sel.selectAll(children_selector).data(function (d) {
    return make_array_ref(d[object_data_key], id_key);
  }, function (d) {
    return d[id_key];
  });

  // enter: generate and place reaction
  var update_sel = create_function ? create_function(sel.enter()).merge(sel) : sel;

  // update: update when necessary
  if (update_function) {
    update_sel.call(update_function);
  }

  // exit
  if (exit_function) {
    sel.exit().call(exit_function);
  }
}

function make_array(obj, id_key) {
  // is this super slow?
  var array = [];
  for (var key in obj) {
    // copy object
    var it = clone(obj[key]);
    // add key as 'id'
    it[id_key] = key;
    // add object to array
    array.push(it);
  }
  return array;
}

function make_array_ref(obj, id_key) {
  /** Turn the object into an array, but only by reference. Faster than
      make_array.
   */
  var array = [];
  for (var key in obj) {
    // copy object
    var it = obj[key];
    // add key as 'id'
    it[id_key] = key;
    // add object to array
    array.push(it);
  }
  return array;
}

function compare_arrays(a1, a2) {
  /** Compares two simple (not-nested) arrays.
    */
  if (!a1 || !a2) return false;
  if (a1.length != a2.length) return false;
  for (var i = 0, l = a1.length; i < l; i++) {
    if (a1[i] != a2[i]) {
      // Warning - two different object instances will never be equal: {x:20} != {x:20}
      return false;
    }
  }
  return true;
}

/**
 * Convert an array of objects to an object with all keys and values
 * that are arrays of the same length as arr. Fills in spaces with null.
 *
 *  For example, [ { a: 1 }, { b: 2 }] becomes { a: [1, null], b: [null, 2] }.
 */
function arrayToObject(arr) {
  // new object
  var obj = {};
  // for each element of the array
  for (var i = 0, l = arr.length; i < l; i++) {
    var column = arr[i];
    var keys = Object.keys(column);
    for (var k = 0, nk = keys.length; k < nk; k++) {
      var id = keys[k];
      if (!(id in obj)) {
        var n = [];
        // fill spaces with null
        for (var j = 0; j < l; j++) {
          n[j] = null;
        }
        n[i] = column[id];
        obj[id] = n;
      } else {
        obj[id][i] = column[id];
      }
    }
  }
  return obj;
}

/**
 * Deep copy for array and object types. All other types are returned by
 * reference.
 * @param {T<Object|Array|*>} obj - The object to copy.
 * @return {T} The copied object.
 */
function clone(obj) {
  if (_.isArray(obj)) return _.map(obj, function (t) {
    return clone(t);
  });else if (_.isObject(obj)) return _.mapObject(obj, function (t, k) {
    return clone(t);
  });else return obj;
}

function extend(obj1, obj2, overwrite) {
  /** Extends obj1 with keys/values from obj2. Performs the extension
      cautiously, and does not override attributes, unless the overwrite
      argument is true.
       Arguments
      ---------
       obj1: Object to extend
       obj2: Object with which to extend.
       overwrite: (Optional, Default false) Overwrite attributes in obj1.
   */

  if (overwrite === undefined) overwrite = false;

  for (var attrname in obj2) {
    if (!(attrname in obj1) || overwrite) // UNIT TEST This
      obj1[attrname] = obj2[attrname];else throw new Error('Attribute ' + attrname + ' already in object.');
  }
}

function uniqueConcat(arrays) {
  var newArray = [];
  arrays.forEach(function (a) {
    a.forEach(function (x) {
      if (newArray.indexOf(x) < 0) {
        newArray.push(x);
      }
    });
  });
  return newArray;
}

/**
 * Return unique values in array of strings.
 *
 * http://stackoverflow.com/questions/1960473/unique-values-in-an-array
 */
function unique_strings_array(arr) {
  var a = [];
  for (var i = 0, l = arr.length; i < l; i++) {
    if (a.indexOf(arr[i]) === -1) {
      a.push(arr[i]);
    }
  }
  return a;
}

/**
 * Returns a function, that, as long as it continues to be invoked, will not be
 * triggered. The function will be called after it stops being called for N
 * milliseconds. If "immediate" is passed, trigger the function on the leading
 * edge, instead of the trailing.
 */
function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this;
    var args = arguments;
    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}

/**
 * Return a copy of the object with just the given ids.
 * @param {} obj - An object
 * @param {} ids - An array of id strings
 */
function object_slice_for_ids(obj, ids) {
  var subset = {};
  var i = -1;
  while (++i < ids.length) {
    subset[ids[i]] = clone(obj[ids[i]]);
  }
  if (ids.length !== Object.keys(subset).length) {
    console.warn('did not find correct reaction subset');
  }
  return subset;
}

/**
 * Return a reference of the object with just the given ids. Faster than
 * object_slice_for_ids.
 * @param {} obj - An object.
 * @param {} ids - An array of id strings.
 */
function object_slice_for_ids_ref(obj, ids) {
  var subset = {};
  var i = -1;
  while (++i < ids.length) {
    subset[ids[i]] = obj[ids[i]];
  }
  if (ids.length !== Object.keys(subset).length) {
    console.warn('did not find correct reaction subset');
  }
  return subset;
}

function c_plus_c(coords1, coords2) {
  if (coords1 === null || coords2 === null || coords1 === undefined || coords2 === undefined) {
    return null;
  }
  return {
    x: coords1.x + coords2.x,
    y: coords1.y + coords2.y
  };
}

function c_minus_c(coords1, coords2) {
  if (coords1 === null || coords2 === null || coords1 === undefined || coords2 === undefined) {
    return null;
  }
  return {
    x: coords1.x - coords2.x,
    y: coords1.y - coords2.y
  };
}

function c_times_scalar(coords, scalar) {
  return {
    x: coords.x * scalar,
    y: coords.y * scalar
  };
}

/**
 * Download JSON file in a blob.
 */
function download_json(json, name) {
  // Alert if blob isn't going to work
  _check_filesaver();

  var j = JSON.stringify(json);
  var blob = new Blob([j], { type: 'application/json' });
  saveAs(blob, name + '.json');
}

/**
 * Try to load the file as JSON.
 * @param {} f - The file path
 * @param {} callback - A callback function that accepts arguments: error, data.
 * @param {} pre_fn (optional) - A function to call before loading the data.
 * @param {} failure_fn (optional) - A function to call if the load fails or is
 * aborted.
*/
function load_json(f, callback, pre_fn, failure_fn) {
  // Check for the various File API support
  if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
    callback('The File APIs are not fully supported in this browser.', null);
  }

  var reader = new window.FileReader();
  // Closure to capture the file information.
  reader.onload = function (event) {
    var result = event.target.result;
    var data;
    // Try JSON
    try {
      data = JSON.parse(result);
    } catch (e) {
      // If it failed, return the error
      callback(e, null);
      return;
    }
    // If successful, return the data
    callback(null, data);
  };
  if (pre_fn !== undefined && pre_fn !== null) {
    try {
      pre_fn();
    } catch (e) {
      console.warn(e);
    }
  }
  reader.onabort = function (event) {
    try {
      failure_fn();
    } catch (e) {
      console.warn(e);
    }
  };
  reader.onerror = function (event) {
    try {
      failure_fn();
    } catch (e) {
      console.warn(e);
    }
  };
  // Read in the image file as a data URL
  reader.readAsText(f);
}

/**
 * Try to load the file as JSON or CSV (JSON first).
 * @param {String} f - The file path
 * @param {Function}  csv_converter - A function to convert the CSV output to equivalent JSON.
 * @param {Function} callback - A callback function that accepts arguments: error, data.
 * @param {} pre_fn (optional) - A function to call before loading the data.
 * @param {} failure_fn (optional) - A function to call if the load fails or is
 * aborted.
 * @param {} debug_event (optional) - An event, with a string at
 * event.target.result, to load as though it was the contents of a loaded file.
 */
function load_json_or_csv(f, csv_converter, callback, pre_fn, failure_fn, debug_event) {
  // Capture the file information.
  var onload_function = function onload_function(event) {
    var result = event.target.result;
    var data;
    var errors;
    // try JSON
    try {
      data = JSON.parse(result);
    } catch (e) {
      errors = 'JSON error: ' + e;

      // try csv
      try {
        data = csv_converter(d3_csvParseRows(result));
      } catch (e) {
        // if both failed, return the errors
        callback(errors + '\nCSV error: ' + e, null);
        return;
      }
    }
    // if successful, return the data
    callback(null, data);
  };
  if (debug_event !== undefined && debug_event !== null) {
    console.warn('Debugging load_json_or_csv');
    return onload_function(debug_event);
  }

  // Check for the various File API support.
  if (!(window.File && window.FileReader && window.FileList && window.Blob)) callback("The File APIs are not fully supported in this browser.", null);
  var reader = new window.FileReader();

  if (pre_fn !== undefined && pre_fn !== null) {
    try {
      pre_fn();
    } catch (e) {
      console.warn(e);
    }
  }
  reader.onabort = function (event) {
    try {
      failure_fn();
    } catch (e) {
      console.warn(e);
    }
  };
  reader.onerror = function (event) {
    try {
      failure_fn();
    } catch (e) {
      console.warn(e);
    }
  };
  // Read in the image file as a data URL.
  reader.onload = onload_function;
  reader.readAsText(f);
}

/**
 * Download an svg file using FileSaver.js.
 * @param {String} name - The filename (without extension)
 * @param {D3 Selection} svg_sel - The d3 selection for the SVG element
 * @param {Boolean} do_beautify - If true, then beautify the SVG output
 */
function downloadSvg(name, svg_sel, do_beautify) {
  // Alert if blob isn't going to work
  _check_filesaver();

  // Make the xml string
  var xml = new XMLSerializer().serializeToString(svg_sel.node());
  if (do_beautify) xml = vkbeautify.xml(xml);
  xml = '<?xml version="1.0" encoding="utf-8"?>\n' + '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"\n' + ' "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' + xml;

  // Save
  var blob = new Blob([xml], { type: 'image/svg+xml' });
  saveAs(blob, name + '.svg');
}

/**
 * Download a png file using FileSaver.js.
 * @param {String} name - The filename (without extension).
 * @param {D3 Selection} svg_sel - The d3 selection for the SVG element.
 */
function downloadPng(name, svg_sel) {
  // Alert if blob isn't going to work
  _check_filesaver();

  // Make the xml string
  var xml = new XMLSerializer().serializeToString(svg_sel.node());
  xml = '<?xml version="1.0" encoding="utf-8"?>\n' + '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"\n' + ' "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' + xml;

  // Canvas to hold the image
  var canvas = document.createElement('canvas');
  var context = canvas.getContext('2d');

  // Get SVG size
  var svg_size = svg_sel.node().getBBox();
  var svg_width = svg_size.width + svg_size.x;
  var svg_height = svg_size.height + svg_size.y;

  // Canvas size = SVG size. Constrained to 10000px for very large SVGs
  if (svg_width < 10000 && svg_height < 10000) {
    canvas.width = svg_width;
    canvas.height = svg_height;
  } else {
    if (canvas.width > canvas.height) {
      canvas.width = 10000;
      canvas.height = 10000 * (svg_height / svg_width);
    } else {
      canvas.width = 10000 * (svg_width / svg_height);
      canvas.height = 10000;
    }
  }

  // Image element appended with data
  var base_image = new Image();
  base_image.src = 'data:image/svg+xml;base64,' + btoa(xml);

  base_image.onload = function () {
    // Draw image to canvas with white background
    context.fillStyle = '#FFF';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.drawImage(base_image, 0, 0, canvas.width, canvas.height);

    // Save image
    canvas.toBlob(function (blob) {
      saveAs(blob, name + '.png');
    });
  };
}

function rotate_coords_recursive(coords_array, angle, center) {
  return coords_array.map(function (c) {
    return rotate_coords(c, angle, center);
  });
}

/**
 * Calculates displacement { x: dx, y: dy } based on rotating point c around
 * center with angle.
 */
function rotate_coords(c, angle, center) {
  var dx = Math.cos(-angle) * (c.x - center.x) + Math.sin(-angle) * (c.y - center.y) + center.x - c.x;
  var dy = -Math.sin(-angle) * (c.x - center.x) + Math.cos(-angle) * (c.y - center.y) + center.y - c.y;
  return { x: dx, y: dy };
}

/**
 * Get the angle between coordinates
 * @param {Object} coords - Array of 2 coordinate objects { x: 1, y: 1 }
 * @return {Number} angle between 0 and 2PI.
 */
function get_angle(coords) {
  var denominator = coords[1].x - coords[0].x;
  var numerator = coords[1].y - coords[0].y;
  if (denominator === 0 && numerator >= 0) {
    return Math.PI / 2;
  } else if (denominator === 0 && numerator < 0) {
    return 3 * Math.PI / 2;
  } else if (denominator >= 0 && numerator >= 0) {
    return Math.atan(numerator / denominator);
  } else if (denominator >= 0) {
    return Math.atan(numerator / denominator) + 2 * Math.PI;
  } else {
    return Math.atan(numerator / denominator) + Math.PI;
  }
}

function to_degrees(radians) {
  return radians * 180 / Math.PI;
}

/**
 * Force to domain -PI to PI
 */
function angleNorm(radians) {
  if (radians < -Math.PI) {
    return radians + Math.floor((radians - Math.PI) / (-2 * Math.PI)) * 2 * Math.PI;
  } else if (radians > Math.PI) {
    return radians - Math.floor((radians + Math.PI) / (2 * Math.PI)) * 2 * Math.PI;
  } else {
    return radians;
  }
}

function to_radians(degrees) {
  return Math.PI / 180 * degrees;
}

/**
 * Convert to radians, and force to domain -PI to PI
 */
function to_radians_norm(degrees) {
  var radians = to_radians(degrees);
  return angleNorm(radians);
}

function angle_for_event(displacement, point, center) {
  var gamma = Math.atan2(point.x - center.x, center.y - point.y);
  var beta = Math.atan2(point.x - center.x + displacement.x, center.y - point.y - displacement.y);
  var angle = beta - gamma;
  return angle;
}

function distance(start, end) {
  return Math.sqrt(Math.pow(end.y - start.y, 2) + Math.pow(end.x - start.x, 2));
}

/**
 * Report an error if any of the arguments are undefined. Call by passing in
 * "arguments" from any function and an array of argument names.
 */
function check_undefined(args, names) {
  names.forEach(function (name, i) {
    if (args[i] === undefined) {
      console.error('Argument is undefined: ' + names[i]);
    }
  });
}

function compartmentalize(bigg_id, compartment_id) {
  return bigg_id + '_' + compartment_id;
}

/**
 * Returns an array of [bigg_id, compartment id]. Matches compartment ids with
 * length 1 or 2. Return [ id, null ] if no match is found.
 */
function decompartmentalize(id) {
  var reg = /(.*)_([a-z0-9]{1,2})$/;
  var result = reg.exec(id);
  return result !== null ? result.slice(1, 3) : [id, null];
}

function mean(array) {
  var sum = array.reduce(function (a, b) {
    return a + b;
  });
  var avg = sum / array.length;
  return avg;
}

function median(array) {
  array.sort(function (a, b) {
    return a - b;
  });
  var half = Math.floor(array.length / 2);
  if (array.length % 2 == 1) {
    return array[half];
  } else {
    return (array[half - 1] + array[half]) / 2.0;
  }
}

function quartiles(array) {
  array.sort(function (a, b) {
    return a - b;
  });
  var half = Math.floor(array.length / 2);
  if (array.length === 1) {
    return [array[0], array[0], array[0]];
  } else if (array.length % 2 === 1) {
    return [median(array.slice(0, half)), array[half], median(array.slice(half + 1))];
  } else {
    return [median(array.slice(0, half)), (array[half - 1] + array[half]) / 2.0, median(array.slice(half))];
  }
}

/**
 * Generate random characters
 *
 * Thanks to @csharptest.net
 * http://stackoverflow.com/questions/1349404/generate-a-string-of-5-random-characters-in-javascript
 */
function random_characters(num) {
  var text = '';
  var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (var i = 0; i < num; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}

function generate_map_id() {
  return random_characters(12);
}

/**
 * Check that the selection has the given parent tag.
 * @param {D3 Selection|DOM Node} el - A D3 Selection or DOM Node to check.
 * @param {String} tag - A tag name (case insensitive).
 */
function check_for_parent_tag(el, tag) {
  // make sure it is a node
  if (el instanceof d3_selection) {
    el = el.node();
  }
  while (el.parentNode !== null) {
    el = el.parentNode;
    if (el.tagName === undefined) {
      continue;
    }
    if (el.tagName.toLowerCase() === tag.toLowerCase()) {
      return true;
    }
  }
  return false;
}

/**
 * Convert model or map name to url.
 * @param {String} name - The short name, e.g. e_coli.iJO1366.central_metabolism.
 * @param {String} download_url (optional) - The url to prepend.
 */
function name_to_url(name, download_url) {
  if (download_url !== undefined && download_url !== null) {
    // strip download_url
    download_url = download_url.replace(/^\/|\/$/g, '');
    name = [download_url, name].join('/');
  }
  // strip final path
  return name.replace(/^\/|\/$/g, '') + '.json';
}

/**
 * Get the document for the node
 */
function get_document(node) {
  return node.ownerDocument;
}

/**
 * Get the window for the node
 */
function get_window(node) {
  return get_document(node).defaultView;
}

/**
 * Get translation and rotation values for a transform string. This used to be
 * in d3, but since v4, I just adapted a solution from SO:
 *
 * http://stackoverflow.com/questions/38224875/replacing-d3-transform-in-d3-v4
 *
 * To get skew and scale out, go back to that example.
 *
 * TODO rename function without "catch"
 *
 * @param {String} transform_attr - A transform string.
 */
function d3_transform_catch(transform_attr) {
  if (transform_attr.indexOf('skew') !== -1 || transform_attr.indexOf('matrix') !== -1) {
    throw new Error('d3_transform_catch does not work with skew or matrix');
  }

  var translate_res = /translate\s*\(\s*([0-9.-]+)\s*,\s*([0-9.-]+)\s*\)/.exec(transform_attr);
  var tn = _.isNull(translate_res);
  var tx = tn ? 0.0 : Number(translate_res[1]);
  var ty = tn ? 0.0 : Number(translate_res[2]);

  var rotate_res = /rotate\s*\(\s*([0-9.-]+)\s*\)/.exec(transform_attr);
  var rn = _.isNull(rotate_res);
  var r = rn ? 0.0 : Number(rotate_res[1]);

  var scale_res = /scale\s*\(\s*([0-9.-]+)\s*\)/.exec(transform_attr);
  var sn = _.isNull(scale_res);
  var s = sn ? 0.0 : Number(scale_res[1]);

  return { translate: [tx, ty], rotate: r, scale: s

    // // Create a dummy g for calculation purposes only. This will new be appended
    // // to the DOM and will be discarded once this function returns.
    // var g = document.createElementNS('http://www.w3.org/2000/svg', 'g')

    // // Set the transform attribute to the provided string value.
    // g.setAttributeNS(null, 'transform', transform_attr)

    // // Consolidate the SVGTransformList containing all Try to a single
    // // SVGTransform of type SVG_TRANSFORM_MATRIX and get its SVGMatrix.

    // var matrix = g.transform.baseVal.consolidate().matrix

    // // Below calculations are taken and adapted from the private func
    // // transform/decompose.js of D3's module d3-interpolate.
    // var a = matrix.a
    // var b = matrix.b
    // var c = matrix.c
    // var d = matrix.d
    // var e = matrix.e
    // var f = matrix.f
    // var scaleX = Math.sqrt(a * a + b * b)

    // if (scaleX) {
    //   a /= scaleX
    //   b /= scaleX
    // }

    // if (a * d < b * c) {
    //   a = -a
    //   b = -b
    // }

    // return {
    //   translate: [ e, f ],
    //   rotate: Math.atan2(b, a) * Math.PI / 180,
    // }
  };
}

/**
 * Look for name in the user agent string.
 */
// function check_browser (name) {
//   var browser = function() {
//     // Thanks to
//     // http://stackoverflow.com/questions/2400935/browser-detection-in-javascript
//     var ua = navigator.userAgent
//     var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || []
//     var tem
//     if (/trident/i.test(M[1])) {
//       tem = /\brv[ :]+(\d+)/g.exec(ua) || []
//       return 'IE '+ (tem[1] || '')
//     }
//     if (M[1] === 'Chrome') {
//       tem = ua.match(/\b(OPR|Edge)\/(\d+)/)
//       if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera')
//     }
//     M = M[2] ? [ M[1], M[2] ]: [ navigator.appName, navigator.appVersion, '-?' ]
//     if ((tem = ua.match(/version\/(\d+)/i)) !== null) {
//       M.splice(1, 1, tem[1])
//     }
//     return M.join(' ')
//   }

//   try {
//     // navigator.userAgent is deprecated, so don't count on it
//     return browser().toLowerCase().indexOf(name) > -1
//   } catch (e) {
//     return false
//   }
// }

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "default", function() { return /* reexport */ index_default; });
__webpack_require__.d(__webpack_exports__, "VERSION", function() { return /* reexport */ _setup["e" /* VERSION */]; });
__webpack_require__.d(__webpack_exports__, "restArguments", function() { return /* reexport */ restArguments; });
__webpack_require__.d(__webpack_exports__, "isObject", function() { return /* reexport */ isObject; });
__webpack_require__.d(__webpack_exports__, "isNull", function() { return /* reexport */ isNull; });
__webpack_require__.d(__webpack_exports__, "isUndefined", function() { return /* reexport */ isUndefined; });
__webpack_require__.d(__webpack_exports__, "isBoolean", function() { return /* reexport */ isBoolean; });
__webpack_require__.d(__webpack_exports__, "isElement", function() { return /* reexport */ isElement; });
__webpack_require__.d(__webpack_exports__, "isString", function() { return /* reexport */ isString; });
__webpack_require__.d(__webpack_exports__, "isNumber", function() { return /* reexport */ isNumber; });
__webpack_require__.d(__webpack_exports__, "isDate", function() { return /* reexport */ isDate; });
__webpack_require__.d(__webpack_exports__, "isRegExp", function() { return /* reexport */ isRegExp; });
__webpack_require__.d(__webpack_exports__, "isError", function() { return /* reexport */ isError; });
__webpack_require__.d(__webpack_exports__, "isSymbol", function() { return /* reexport */ isSymbol; });
__webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return /* reexport */ isArrayBuffer; });
__webpack_require__.d(__webpack_exports__, "isDataView", function() { return /* reexport */ modules_isDataView; });
__webpack_require__.d(__webpack_exports__, "isArray", function() { return /* reexport */ isArray; });
__webpack_require__.d(__webpack_exports__, "isFunction", function() { return /* reexport */ modules_isFunction; });
__webpack_require__.d(__webpack_exports__, "isArguments", function() { return /* reexport */ modules_isArguments; });
__webpack_require__.d(__webpack_exports__, "isFinite", function() { return /* reexport */ isFinite_isFinite; });
__webpack_require__.d(__webpack_exports__, "isNaN", function() { return /* reexport */ isNaN_isNaN; });
__webpack_require__.d(__webpack_exports__, "isTypedArray", function() { return /* reexport */ modules_isTypedArray; });
__webpack_require__.d(__webpack_exports__, "isEmpty", function() { return /* reexport */ isEmpty; });
__webpack_require__.d(__webpack_exports__, "isMatch", function() { return /* reexport */ isMatch; });
__webpack_require__.d(__webpack_exports__, "isEqual", function() { return /* reexport */ isEqual; });
__webpack_require__.d(__webpack_exports__, "isMap", function() { return /* reexport */ isMap; });
__webpack_require__.d(__webpack_exports__, "isWeakMap", function() { return /* reexport */ isWeakMap; });
__webpack_require__.d(__webpack_exports__, "isSet", function() { return /* reexport */ isSet; });
__webpack_require__.d(__webpack_exports__, "isWeakSet", function() { return /* reexport */ isWeakSet; });
__webpack_require__.d(__webpack_exports__, "keys", function() { return /* reexport */ keys_keys; });
__webpack_require__.d(__webpack_exports__, "allKeys", function() { return /* reexport */ allKeys; });
__webpack_require__.d(__webpack_exports__, "values", function() { return /* reexport */ values_values; });
__webpack_require__.d(__webpack_exports__, "pairs", function() { return /* reexport */ pairs_pairs; });
__webpack_require__.d(__webpack_exports__, "invert", function() { return /* reexport */ invert; });
__webpack_require__.d(__webpack_exports__, "functions", function() { return /* reexport */ functions; });
__webpack_require__.d(__webpack_exports__, "methods", function() { return /* reexport */ functions; });
__webpack_require__.d(__webpack_exports__, "extend", function() { return /* reexport */ extend; });
__webpack_require__.d(__webpack_exports__, "extendOwn", function() { return /* reexport */ extendOwn; });
__webpack_require__.d(__webpack_exports__, "assign", function() { return /* reexport */ extendOwn; });
__webpack_require__.d(__webpack_exports__, "defaults", function() { return /* reexport */ defaults; });
__webpack_require__.d(__webpack_exports__, "create", function() { return /* reexport */ create; });
__webpack_require__.d(__webpack_exports__, "clone", function() { return /* reexport */ clone; });
__webpack_require__.d(__webpack_exports__, "tap", function() { return /* reexport */ tap; });
__webpack_require__.d(__webpack_exports__, "get", function() { return /* reexport */ get; });
__webpack_require__.d(__webpack_exports__, "has", function() { return /* reexport */ has_has; });
__webpack_require__.d(__webpack_exports__, "mapObject", function() { return /* reexport */ mapObject; });
__webpack_require__.d(__webpack_exports__, "identity", function() { return /* reexport */ identity; });
__webpack_require__.d(__webpack_exports__, "constant", function() { return /* reexport */ constant; });
__webpack_require__.d(__webpack_exports__, "noop", function() { return /* reexport */ noop; });
__webpack_require__.d(__webpack_exports__, "toPath", function() { return /* reexport */ toPath; });
__webpack_require__.d(__webpack_exports__, "property", function() { return /* reexport */ property; });
__webpack_require__.d(__webpack_exports__, "propertyOf", function() { return /* reexport */ propertyOf; });
__webpack_require__.d(__webpack_exports__, "matcher", function() { return /* reexport */ matcher_matcher; });
__webpack_require__.d(__webpack_exports__, "matches", function() { return /* reexport */ matcher_matcher; });
__webpack_require__.d(__webpack_exports__, "times", function() { return /* reexport */ times; });
__webpack_require__.d(__webpack_exports__, "random", function() { return /* reexport */ random; });
__webpack_require__.d(__webpack_exports__, "now", function() { return /* reexport */ now; });
__webpack_require__.d(__webpack_exports__, "escape", function() { return /* reexport */ modules_escape; });
__webpack_require__.d(__webpack_exports__, "unescape", function() { return /* reexport */ modules_unescape; });
__webpack_require__.d(__webpack_exports__, "templateSettings", function() { return /* reexport */ templateSettings; });
__webpack_require__.d(__webpack_exports__, "template", function() { return /* reexport */ template_template; });
__webpack_require__.d(__webpack_exports__, "result", function() { return /* reexport */ result_result; });
__webpack_require__.d(__webpack_exports__, "uniqueId", function() { return /* reexport */ uniqueId; });
__webpack_require__.d(__webpack_exports__, "chain", function() { return /* reexport */ chain; });
__webpack_require__.d(__webpack_exports__, "iteratee", function() { return /* reexport */ iteratee_iteratee; });
__webpack_require__.d(__webpack_exports__, "partial", function() { return /* reexport */ modules_partial; });
__webpack_require__.d(__webpack_exports__, "bind", function() { return /* reexport */ bind; });
__webpack_require__.d(__webpack_exports__, "bindAll", function() { return /* reexport */ bindAll; });
__webpack_require__.d(__webpack_exports__, "memoize", function() { return /* reexport */ memoize_memoize; });
__webpack_require__.d(__webpack_exports__, "delay", function() { return /* reexport */ delay; });
__webpack_require__.d(__webpack_exports__, "defer", function() { return /* reexport */ defer; });
__webpack_require__.d(__webpack_exports__, "throttle", function() { return /* reexport */ throttle; });
__webpack_require__.d(__webpack_exports__, "debounce", function() { return /* reexport */ debounce; });
__webpack_require__.d(__webpack_exports__, "wrap", function() { return /* reexport */ wrap; });
__webpack_require__.d(__webpack_exports__, "negate", function() { return /* reexport */ negate; });
__webpack_require__.d(__webpack_exports__, "compose", function() { return /* reexport */ compose; });
__webpack_require__.d(__webpack_exports__, "after", function() { return /* reexport */ after; });
__webpack_require__.d(__webpack_exports__, "before", function() { return /* reexport */ before; });
__webpack_require__.d(__webpack_exports__, "once", function() { return /* reexport */ once; });
__webpack_require__.d(__webpack_exports__, "findKey", function() { return /* reexport */ findKey; });
__webpack_require__.d(__webpack_exports__, "findIndex", function() { return /* reexport */ findIndex; });
__webpack_require__.d(__webpack_exports__, "findLastIndex", function() { return /* reexport */ findLastIndex; });
__webpack_require__.d(__webpack_exports__, "sortedIndex", function() { return /* reexport */ sortedIndex_sortedIndex; });
__webpack_require__.d(__webpack_exports__, "indexOf", function() { return /* reexport */ indexOf; });
__webpack_require__.d(__webpack_exports__, "lastIndexOf", function() { return /* reexport */ lastIndexOf; });
__webpack_require__.d(__webpack_exports__, "find", function() { return /* reexport */ find; });
__webpack_require__.d(__webpack_exports__, "detect", function() { return /* reexport */ find; });
__webpack_require__.d(__webpack_exports__, "findWhere", function() { return /* reexport */ findWhere; });
__webpack_require__.d(__webpack_exports__, "each", function() { return /* reexport */ each; });
__webpack_require__.d(__webpack_exports__, "forEach", function() { return /* reexport */ each; });
__webpack_require__.d(__webpack_exports__, "map", function() { return /* reexport */ map_map; });
__webpack_require__.d(__webpack_exports__, "collect", function() { return /* reexport */ map_map; });
__webpack_require__.d(__webpack_exports__, "reduce", function() { return /* reexport */ reduce; });
__webpack_require__.d(__webpack_exports__, "foldl", function() { return /* reexport */ reduce; });
__webpack_require__.d(__webpack_exports__, "inject", function() { return /* reexport */ reduce; });
__webpack_require__.d(__webpack_exports__, "reduceRight", function() { return /* reexport */ reduceRight; });
__webpack_require__.d(__webpack_exports__, "foldr", function() { return /* reexport */ reduceRight; });
__webpack_require__.d(__webpack_exports__, "filter", function() { return /* reexport */ filter; });
__webpack_require__.d(__webpack_exports__, "select", function() { return /* reexport */ filter; });
__webpack_require__.d(__webpack_exports__, "reject", function() { return /* reexport */ reject; });
__webpack_require__.d(__webpack_exports__, "every", function() { return /* reexport */ every; });
__webpack_require__.d(__webpack_exports__, "all", function() { return /* reexport */ every; });
__webpack_require__.d(__webpack_exports__, "some", function() { return /* reexport */ some; });
__webpack_require__.d(__webpack_exports__, "any", function() { return /* reexport */ some; });
__webpack_require__.d(__webpack_exports__, "contains", function() { return /* reexport */ contains; });
__webpack_require__.d(__webpack_exports__, "includes", function() { return /* reexport */ contains; });
__webpack_require__.d(__webpack_exports__, "include", function() { return /* reexport */ contains; });
__webpack_require__.d(__webpack_exports__, "invoke", function() { return /* reexport */ invoke; });
__webpack_require__.d(__webpack_exports__, "pluck", function() { return /* reexport */ pluck; });
__webpack_require__.d(__webpack_exports__, "where", function() { return /* reexport */ where; });
__webpack_require__.d(__webpack_exports__, "max", function() { return /* reexport */ max; });
__webpack_require__.d(__webpack_exports__, "min", function() { return /* reexport */ min; });
__webpack_require__.d(__webpack_exports__, "shuffle", function() { return /* reexport */ shuffle; });
__webpack_require__.d(__webpack_exports__, "sample", function() { return /* reexport */ sample_sample; });
__webpack_require__.d(__webpack_exports__, "sortBy", function() { return /* reexport */ sortBy; });
__webpack_require__.d(__webpack_exports__, "groupBy", function() { return /* reexport */ groupBy; });
__webpack_require__.d(__webpack_exports__, "indexBy", function() { return /* reexport */ indexBy; });
__webpack_require__.d(__webpack_exports__, "countBy", function() { return /* reexport */ countBy; });
__webpack_require__.d(__webpack_exports__, "partition", function() { return /* reexport */ modules_partition; });
__webpack_require__.d(__webpack_exports__, "toArray", function() { return /* reexport */ toArray; });
__webpack_require__.d(__webpack_exports__, "size", function() { return /* reexport */ size; });
__webpack_require__.d(__webpack_exports__, "pick", function() { return /* reexport */ pick; });
__webpack_require__.d(__webpack_exports__, "omit", function() { return /* reexport */ omit; });
__webpack_require__.d(__webpack_exports__, "first", function() { return /* reexport */ first; });
__webpack_require__.d(__webpack_exports__, "head", function() { return /* reexport */ first; });
__webpack_require__.d(__webpack_exports__, "take", function() { return /* reexport */ first; });
__webpack_require__.d(__webpack_exports__, "initial", function() { return /* reexport */ initial_initial; });
__webpack_require__.d(__webpack_exports__, "last", function() { return /* reexport */ last_last; });
__webpack_require__.d(__webpack_exports__, "rest", function() { return /* reexport */ rest_rest; });
__webpack_require__.d(__webpack_exports__, "tail", function() { return /* reexport */ rest_rest; });
__webpack_require__.d(__webpack_exports__, "drop", function() { return /* reexport */ rest_rest; });
__webpack_require__.d(__webpack_exports__, "compact", function() { return /* reexport */ compact; });
__webpack_require__.d(__webpack_exports__, "flatten", function() { return /* reexport */ flatten_flatten; });
__webpack_require__.d(__webpack_exports__, "without", function() { return /* reexport */ without; });
__webpack_require__.d(__webpack_exports__, "uniq", function() { return /* reexport */ uniq; });
__webpack_require__.d(__webpack_exports__, "unique", function() { return /* reexport */ uniq; });
__webpack_require__.d(__webpack_exports__, "union", function() { return /* reexport */ union; });
__webpack_require__.d(__webpack_exports__, "intersection", function() { return /* reexport */ intersection; });
__webpack_require__.d(__webpack_exports__, "difference", function() { return /* reexport */ difference; });
__webpack_require__.d(__webpack_exports__, "unzip", function() { return /* reexport */ unzip; });
__webpack_require__.d(__webpack_exports__, "transpose", function() { return /* reexport */ unzip; });
__webpack_require__.d(__webpack_exports__, "zip", function() { return /* reexport */ zip; });
__webpack_require__.d(__webpack_exports__, "object", function() { return /* reexport */ object_object; });
__webpack_require__.d(__webpack_exports__, "range", function() { return /* reexport */ range; });
__webpack_require__.d(__webpack_exports__, "chunk", function() { return /* reexport */ chunk; });
__webpack_require__.d(__webpack_exports__, "mixin", function() { return /* reexport */ mixin; });

// NAMESPACE OBJECT: ./node_modules/underscore/modules/index.js
var modules_namespaceObject = {};
__webpack_require__.r(modules_namespaceObject);
__webpack_require__.d(modules_namespaceObject, "VERSION", function() { return _setup["e" /* VERSION */]; });
__webpack_require__.d(modules_namespaceObject, "restArguments", function() { return restArguments; });
__webpack_require__.d(modules_namespaceObject, "isObject", function() { return isObject; });
__webpack_require__.d(modules_namespaceObject, "isNull", function() { return isNull; });
__webpack_require__.d(modules_namespaceObject, "isUndefined", function() { return isUndefined; });
__webpack_require__.d(modules_namespaceObject, "isBoolean", function() { return isBoolean; });
__webpack_require__.d(modules_namespaceObject, "isElement", function() { return isElement; });
__webpack_require__.d(modules_namespaceObject, "isString", function() { return isString; });
__webpack_require__.d(modules_namespaceObject, "isNumber", function() { return isNumber; });
__webpack_require__.d(modules_namespaceObject, "isDate", function() { return isDate; });
__webpack_require__.d(modules_namespaceObject, "isRegExp", function() { return isRegExp; });
__webpack_require__.d(modules_namespaceObject, "isError", function() { return isError; });
__webpack_require__.d(modules_namespaceObject, "isSymbol", function() { return isSymbol; });
__webpack_require__.d(modules_namespaceObject, "isArrayBuffer", function() { return isArrayBuffer; });
__webpack_require__.d(modules_namespaceObject, "isDataView", function() { return modules_isDataView; });
__webpack_require__.d(modules_namespaceObject, "isArray", function() { return isArray; });
__webpack_require__.d(modules_namespaceObject, "isFunction", function() { return modules_isFunction; });
__webpack_require__.d(modules_namespaceObject, "isArguments", function() { return modules_isArguments; });
__webpack_require__.d(modules_namespaceObject, "isFinite", function() { return isFinite_isFinite; });
__webpack_require__.d(modules_namespaceObject, "isNaN", function() { return isNaN_isNaN; });
__webpack_require__.d(modules_namespaceObject, "isTypedArray", function() { return modules_isTypedArray; });
__webpack_require__.d(modules_namespaceObject, "isEmpty", function() { return isEmpty; });
__webpack_require__.d(modules_namespaceObject, "isMatch", function() { return isMatch; });
__webpack_require__.d(modules_namespaceObject, "isEqual", function() { return isEqual; });
__webpack_require__.d(modules_namespaceObject, "isMap", function() { return isMap; });
__webpack_require__.d(modules_namespaceObject, "isWeakMap", function() { return isWeakMap; });
__webpack_require__.d(modules_namespaceObject, "isSet", function() { return isSet; });
__webpack_require__.d(modules_namespaceObject, "isWeakSet", function() { return isWeakSet; });
__webpack_require__.d(modules_namespaceObject, "keys", function() { return keys_keys; });
__webpack_require__.d(modules_namespaceObject, "allKeys", function() { return allKeys; });
__webpack_require__.d(modules_namespaceObject, "values", function() { return values_values; });
__webpack_require__.d(modules_namespaceObject, "pairs", function() { return pairs_pairs; });
__webpack_require__.d(modules_namespaceObject, "invert", function() { return invert; });
__webpack_require__.d(modules_namespaceObject, "functions", function() { return functions; });
__webpack_require__.d(modules_namespaceObject, "methods", function() { return functions; });
__webpack_require__.d(modules_namespaceObject, "extend", function() { return extend; });
__webpack_require__.d(modules_namespaceObject, "extendOwn", function() { return extendOwn; });
__webpack_require__.d(modules_namespaceObject, "assign", function() { return extendOwn; });
__webpack_require__.d(modules_namespaceObject, "defaults", function() { return defaults; });
__webpack_require__.d(modules_namespaceObject, "create", function() { return create; });
__webpack_require__.d(modules_namespaceObject, "clone", function() { return clone; });
__webpack_require__.d(modules_namespaceObject, "tap", function() { return tap; });
__webpack_require__.d(modules_namespaceObject, "get", function() { return get; });
__webpack_require__.d(modules_namespaceObject, "has", function() { return has_has; });
__webpack_require__.d(modules_namespaceObject, "mapObject", function() { return mapObject; });
__webpack_require__.d(modules_namespaceObject, "identity", function() { return identity; });
__webpack_require__.d(modules_namespaceObject, "constant", function() { return constant; });
__webpack_require__.d(modules_namespaceObject, "noop", function() { return noop; });
__webpack_require__.d(modules_namespaceObject, "toPath", function() { return toPath; });
__webpack_require__.d(modules_namespaceObject, "property", function() { return property; });
__webpack_require__.d(modules_namespaceObject, "propertyOf", function() { return propertyOf; });
__webpack_require__.d(modules_namespaceObject, "matcher", function() { return matcher_matcher; });
__webpack_require__.d(modules_namespaceObject, "matches", function() { return matcher_matcher; });
__webpack_require__.d(modules_namespaceObject, "times", function() { return times; });
__webpack_require__.d(modules_namespaceObject, "random", function() { return random; });
__webpack_require__.d(modules_namespaceObject, "now", function() { return now; });
__webpack_require__.d(modules_namespaceObject, "escape", function() { return modules_escape; });
__webpack_require__.d(modules_namespaceObject, "unescape", function() { return modules_unescape; });
__webpack_require__.d(modules_namespaceObject, "templateSettings", function() { return templateSettings; });
__webpack_require__.d(modules_namespaceObject, "template", function() { return template_template; });
__webpack_require__.d(modules_namespaceObject, "result", function() { return result_result; });
__webpack_require__.d(modules_namespaceObject, "uniqueId", function() { return uniqueId; });
__webpack_require__.d(modules_namespaceObject, "chain", function() { return chain; });
__webpack_require__.d(modules_namespaceObject, "iteratee", function() { return iteratee_iteratee; });
__webpack_require__.d(modules_namespaceObject, "partial", function() { return modules_partial; });
__webpack_require__.d(modules_namespaceObject, "bind", function() { return bind; });
__webpack_require__.d(modules_namespaceObject, "bindAll", function() { return bindAll; });
__webpack_require__.d(modules_namespaceObject, "memoize", function() { return memoize_memoize; });
__webpack_require__.d(modules_namespaceObject, "delay", function() { return delay; });
__webpack_require__.d(modules_namespaceObject, "defer", function() { return defer; });
__webpack_require__.d(modules_namespaceObject, "throttle", function() { return throttle; });
__webpack_require__.d(modules_namespaceObject, "debounce", function() { return debounce; });
__webpack_require__.d(modules_namespaceObject, "wrap", function() { return wrap; });
__webpack_require__.d(modules_namespaceObject, "negate", function() { return negate; });
__webpack_require__.d(modules_namespaceObject, "compose", function() { return compose; });
__webpack_require__.d(modules_namespaceObject, "after", function() { return after; });
__webpack_require__.d(modules_namespaceObject, "before", function() { return before; });
__webpack_require__.d(modules_namespaceObject, "once", function() { return once; });
__webpack_require__.d(modules_namespaceObject, "findKey", function() { return findKey; });
__webpack_require__.d(modules_namespaceObject, "findIndex", function() { return findIndex; });
__webpack_require__.d(modules_namespaceObject, "findLastIndex", function() { return findLastIndex; });
__webpack_require__.d(modules_namespaceObject, "sortedIndex", function() { return sortedIndex_sortedIndex; });
__webpack_require__.d(modules_namespaceObject, "indexOf", function() { return indexOf; });
__webpack_require__.d(modules_namespaceObject, "lastIndexOf", function() { return lastIndexOf; });
__webpack_require__.d(modules_namespaceObject, "find", function() { return find; });
__webpack_require__.d(modules_namespaceObject, "detect", function() { return find; });
__webpack_require__.d(modules_namespaceObject, "findWhere", function() { return findWhere; });
__webpack_require__.d(modules_namespaceObject, "each", function() { return each; });
__webpack_require__.d(modules_namespaceObject, "forEach", function() { return each; });
__webpack_require__.d(modules_namespaceObject, "map", function() { return map_map; });
__webpack_require__.d(modules_namespaceObject, "collect", function() { return map_map; });
__webpack_require__.d(modules_namespaceObject, "reduce", function() { return reduce; });
__webpack_require__.d(modules_namespaceObject, "foldl", function() { return reduce; });
__webpack_require__.d(modules_namespaceObject, "inject", function() { return reduce; });
__webpack_require__.d(modules_namespaceObject, "reduceRight", function() { return reduceRight; });
__webpack_require__.d(modules_namespaceObject, "foldr", function() { return reduceRight; });
__webpack_require__.d(modules_namespaceObject, "filter", function() { return filter; });
__webpack_require__.d(modules_namespaceObject, "select", function() { return filter; });
__webpack_require__.d(modules_namespaceObject, "reject", function() { return reject; });
__webpack_require__.d(modules_namespaceObject, "every", function() { return every; });
__webpack_require__.d(modules_namespaceObject, "all", function() { return every; });
__webpack_require__.d(modules_namespaceObject, "some", function() { return some; });
__webpack_require__.d(modules_namespaceObject, "any", function() { return some; });
__webpack_require__.d(modules_namespaceObject, "contains", function() { return contains; });
__webpack_require__.d(modules_namespaceObject, "includes", function() { return contains; });
__webpack_require__.d(modules_namespaceObject, "include", function() { return contains; });
__webpack_require__.d(modules_namespaceObject, "invoke", function() { return invoke; });
__webpack_require__.d(modules_namespaceObject, "pluck", function() { return pluck; });
__webpack_require__.d(modules_namespaceObject, "where", function() { return where; });
__webpack_require__.d(modules_namespaceObject, "max", function() { return max; });
__webpack_require__.d(modules_namespaceObject, "min", function() { return min; });
__webpack_require__.d(modules_namespaceObject, "shuffle", function() { return shuffle; });
__webpack_require__.d(modules_namespaceObject, "sample", function() { return sample_sample; });
__webpack_require__.d(modules_namespaceObject, "sortBy", function() { return sortBy; });
__webpack_require__.d(modules_namespaceObject, "groupBy", function() { return groupBy; });
__webpack_require__.d(modules_namespaceObject, "indexBy", function() { return indexBy; });
__webpack_require__.d(modules_namespaceObject, "countBy", function() { return countBy; });
__webpack_require__.d(modules_namespaceObject, "partition", function() { return modules_partition; });
__webpack_require__.d(modules_namespaceObject, "toArray", function() { return toArray; });
__webpack_require__.d(modules_namespaceObject, "size", function() { return size; });
__webpack_require__.d(modules_namespaceObject, "pick", function() { return pick; });
__webpack_require__.d(modules_namespaceObject, "omit", function() { return omit; });
__webpack_require__.d(modules_namespaceObject, "first", function() { return first; });
__webpack_require__.d(modules_namespaceObject, "head", function() { return first; });
__webpack_require__.d(modules_namespaceObject, "take", function() { return first; });
__webpack_require__.d(modules_namespaceObject, "initial", function() { return initial_initial; });
__webpack_require__.d(modules_namespaceObject, "last", function() { return last_last; });
__webpack_require__.d(modules_namespaceObject, "rest", function() { return rest_rest; });
__webpack_require__.d(modules_namespaceObject, "tail", function() { return rest_rest; });
__webpack_require__.d(modules_namespaceObject, "drop", function() { return rest_rest; });
__webpack_require__.d(modules_namespaceObject, "compact", function() { return compact; });
__webpack_require__.d(modules_namespaceObject, "flatten", function() { return flatten_flatten; });
__webpack_require__.d(modules_namespaceObject, "without", function() { return without; });
__webpack_require__.d(modules_namespaceObject, "uniq", function() { return uniq; });
__webpack_require__.d(modules_namespaceObject, "unique", function() { return uniq; });
__webpack_require__.d(modules_namespaceObject, "union", function() { return union; });
__webpack_require__.d(modules_namespaceObject, "intersection", function() { return intersection; });
__webpack_require__.d(modules_namespaceObject, "difference", function() { return difference; });
__webpack_require__.d(modules_namespaceObject, "unzip", function() { return unzip; });
__webpack_require__.d(modules_namespaceObject, "transpose", function() { return unzip; });
__webpack_require__.d(modules_namespaceObject, "zip", function() { return zip; });
__webpack_require__.d(modules_namespaceObject, "object", function() { return object_object; });
__webpack_require__.d(modules_namespaceObject, "range", function() { return range; });
__webpack_require__.d(modules_namespaceObject, "chunk", function() { return chunk; });
__webpack_require__.d(modules_namespaceObject, "mixin", function() { return mixin; });
__webpack_require__.d(modules_namespaceObject, "default", function() { return underscore_array_methods; });

// EXTERNAL MODULE: ./node_modules/underscore/modules/_setup.js
var _setup = __webpack_require__(0);

// CONCATENATED MODULE: ./node_modules/underscore/modules/restArguments.js
// Some functions take a variable number of arguments, or a few expected
// arguments at the beginning and then a variable number of values to operate
// on. This helper accumulates all remaining arguments past the function’s
// argument length (or an explicit `startIndex`), into an array that becomes
// the last argument. Similar to ES6’s "rest parameter".
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0),
        rest = Array(length),
        index = 0;
    for (; index < length; index++) {
      rest[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, arguments[0], rest);
      case 2: return func.call(this, arguments[0], arguments[1], rest);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest;
    return func.apply(this, args);
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isObject.js
// Is a given variable an object?
function isObject(obj) {
  var type = typeof obj;
  return type === 'function' || (type === 'object' && !!obj);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isNull.js
// Is a given value equal to null?
function isNull(obj) {
  return obj === null;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isUndefined.js
// Is a given variable undefined?
function isUndefined(obj) {
  return obj === void 0;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isBoolean.js


// Is a given value a boolean?
function isBoolean(obj) {
  return obj === true || obj === false || _setup["t" /* toString */].call(obj) === '[object Boolean]';
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isElement.js
// Is a given value a DOM element?
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_tagTester.js


// Internal function for creating a `toString`-based type tester.
function tagTester(name) {
  var tag = '[object ' + name + ']';
  return function(obj) {
    return _setup["t" /* toString */].call(obj) === tag;
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isString.js


/* harmony default export */ var isString = (tagTester('String'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isNumber.js


/* harmony default export */ var isNumber = (tagTester('Number'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isDate.js


/* harmony default export */ var isDate = (tagTester('Date'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isRegExp.js


/* harmony default export */ var isRegExp = (tagTester('RegExp'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isError.js


/* harmony default export */ var isError = (tagTester('Error'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isSymbol.js


/* harmony default export */ var isSymbol = (tagTester('Symbol'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isArrayBuffer.js


/* harmony default export */ var isArrayBuffer = (tagTester('ArrayBuffer'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isFunction.js



var isFunction = tagTester('Function');

// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
var nodelist = _setup["p" /* root */].document && _setup["p" /* root */].document.childNodes;
if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {
  isFunction = function(obj) {
    return typeof obj == 'function' || false;
  };
}

/* harmony default export */ var modules_isFunction = (isFunction);

// CONCATENATED MODULE: ./node_modules/underscore/modules/_hasObjectTag.js


/* harmony default export */ var _hasObjectTag = (tagTester('Object'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/_stringTagBug.js



// In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
// In IE 11, the most common among them, this problem also applies to
// `Map`, `WeakMap` and `Set`.
var hasStringTagBug = (
      _setup["s" /* supportsDataView */] && _hasObjectTag(new DataView(new ArrayBuffer(8)))
    ),
    isIE11 = (typeof Map !== 'undefined' && _hasObjectTag(new Map));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isDataView.js





var isDataView = tagTester('DataView');

// In IE 10 - Edge 13, we need a different heuristic
// to determine whether an object is a `DataView`.
function ie10IsDataView(obj) {
  return obj != null && modules_isFunction(obj.getInt8) && isArrayBuffer(obj.buffer);
}

/* harmony default export */ var modules_isDataView = (hasStringTagBug ? ie10IsDataView : isDataView);

// CONCATENATED MODULE: ./node_modules/underscore/modules/isArray.js



// Is a given value an array?
// Delegates to ECMA5's native `Array.isArray`.
/* harmony default export */ var isArray = (_setup["k" /* nativeIsArray */] || tagTester('Array'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/_has.js


// Internal function to check whether `key` is an own property name of `obj`.
function has(obj, key) {
  return obj != null && _setup["i" /* hasOwnProperty */].call(obj, key);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isArguments.js



var isArguments = tagTester('Arguments');

// Define a fallback version of the method in browsers (ahem, IE < 9), where
// there isn't any inspectable "Arguments" type.
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }
}());

/* harmony default export */ var modules_isArguments = (isArguments);

// CONCATENATED MODULE: ./node_modules/underscore/modules/isFinite.js



// Is a given object a finite number?
function isFinite_isFinite(obj) {
  return !isSymbol(obj) && Object(_setup["f" /* _isFinite */])(obj) && !isNaN(parseFloat(obj));
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isNaN.js



// Is the given value `NaN`?
function isNaN_isNaN(obj) {
  return isNumber(obj) && Object(_setup["g" /* _isNaN */])(obj);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/constant.js
// Predicate-generating function. Often useful outside of Underscore.
function constant(value) {
  return function() {
    return value;
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_createSizePropertyCheck.js


// Common internal logic for `isArrayLike` and `isBufferLike`.
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= _setup["b" /* MAX_ARRAY_INDEX */];
  }
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_shallowProperty.js
// Internal helper to generate a function to obtain property `key` from `obj`.
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_getByteLength.js


// Internal helper to obtain the `byteLength` property of an object.
/* harmony default export */ var _getByteLength = (shallowProperty('byteLength'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/_isBufferLike.js



// Internal helper to determine whether we should spend extensive checks against
// `ArrayBuffer` et al.
/* harmony default export */ var _isBufferLike = (createSizePropertyCheck(_getByteLength));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isTypedArray.js





// Is a given value a typed array?
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  // `ArrayBuffer.isView` is the most future-proof, so use it when available.
  // Otherwise, fall back on the above regular expression.
  return _setup["l" /* nativeIsView */] ? (Object(_setup["l" /* nativeIsView */])(obj) && !modules_isDataView(obj)) :
                _isBufferLike(obj) && typedArrayPattern.test(_setup["t" /* toString */].call(obj));
}

/* harmony default export */ var modules_isTypedArray = (_setup["r" /* supportsArrayBuffer */] ? isTypedArray : constant(false));

// CONCATENATED MODULE: ./node_modules/underscore/modules/_getLength.js


// Internal helper to obtain the `length` property of an object.
/* harmony default export */ var _getLength = (shallowProperty('length'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/_collectNonEnumProps.js




// Internal helper to create a simple lookup structure.
// `collectNonEnumProps` used to depend on `_.contains`, but this led to
// circular imports. `emulatedSet` is a one-off solution that only works for
// arrays of strings.
function emulatedSet(keys) {
  var hash = {};
  for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
  return {
    contains: function(key) { return hash[key] === true; },
    push: function(key) {
      hash[key] = true;
      return keys.push(key);
    }
  };
}

// Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
// be iterated by `for key in ...` and thus missed. Extends `keys` in place if
// needed.
function collectNonEnumProps(obj, keys) {
  keys = emulatedSet(keys);
  var nonEnumIdx = _setup["n" /* nonEnumerableProps */].length;
  var constructor = obj.constructor;
  var proto = (modules_isFunction(constructor) && constructor.prototype) || _setup["c" /* ObjProto */];

  // Constructor is a special case.
  var prop = 'constructor';
  if (has(obj, prop) && !keys.contains(prop)) keys.push(prop);

  while (nonEnumIdx--) {
    prop = _setup["n" /* nonEnumerableProps */][nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
      keys.push(prop);
    }
  }
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/keys.js





// Retrieve the names of an object's own properties.
// Delegates to **ECMAScript 5**'s native `Object.keys`.
function keys_keys(obj) {
  if (!isObject(obj)) return [];
  if (_setup["m" /* nativeKeys */]) return Object(_setup["m" /* nativeKeys */])(obj);
  var keys = [];
  for (var key in obj) if (has(obj, key)) keys.push(key);
  // Ahem, IE < 9.
  if (_setup["h" /* hasEnumBug */]) collectNonEnumProps(obj, keys);
  return keys;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isEmpty.js






// Is a given array, string, or object empty?
// An "empty" object has no enumerable own-properties.
function isEmpty(obj) {
  if (obj == null) return true;
  // Skip the more expensive `toString`-based type checks if `obj` has no
  // `.length`.
  var length = _getLength(obj);
  if (typeof length == 'number' && (
    isArray(obj) || isString(obj) || modules_isArguments(obj)
  )) return length === 0;
  return _getLength(keys_keys(obj)) === 0;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isMatch.js


// Returns whether an object has a given set of `key:value` pairs.
function isMatch(object, attrs) {
  var _keys = keys_keys(attrs), length = _keys.length;
  if (object == null) return !length;
  var obj = Object(object);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/underscore.js


// If Underscore is called as a function, it returns a wrapped object that can
// be used OO-style. This wrapper holds altered versions of all functions added
// through `_.mixin`. Wrapped objects may be chained.
function _(obj) {
  if (obj instanceof _) return obj;
  if (!(this instanceof _)) return new _(obj);
  this._wrapped = obj;
}

_.VERSION = _setup["e" /* VERSION */];

// Extracts the result from a wrapped and chained object.
_.prototype.value = function() {
  return this._wrapped;
};

// Provide unwrapping proxies for some methods used in engine operations
// such as arithmetic and JSON stringification.
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

_.prototype.toString = function() {
  return String(this._wrapped);
};

// CONCATENATED MODULE: ./node_modules/underscore/modules/_toBufferView.js


// Internal function to wrap or shallow-copy an ArrayBuffer,
// typed array or DataView to a new view, reusing the buffer.
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    _getByteLength(bufferSource)
  );
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/isEqual.js











// We use this string twice, so give it a name for minification.
var tagDataView = '[object DataView]';

// Internal recursive comparison function for `_.isEqual`.
function eq(a, b, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  // `null` or `undefined` only equal to itself (strict comparison).
  if (a == null || b == null) return false;
  // `NaN`s are equivalent, but non-reflexive.
  if (a !== a) return b !== b;
  // Exhaust primitive checks
  var type = typeof a;
  if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
  return deepEq(a, b, aStack, bStack);
}

// Internal recursive comparison function for `_.isEqual`.
function deepEq(a, b, aStack, bStack) {
  // Unwrap any wrapped objects.
  if (a instanceof _) a = a._wrapped;
  if (b instanceof _) b = b._wrapped;
  // Compare `[[Class]]` names.
  var className = _setup["t" /* toString */].call(a);
  if (className !== _setup["t" /* toString */].call(b)) return false;
  // Work around a bug in IE 10 - Edge 13.
  if (hasStringTagBug && className == '[object Object]' && modules_isDataView(a)) {
    if (!modules_isDataView(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case '[object String]':
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return '' + a === '' + b;
    case '[object Number]':
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b;
      // An `egal` comparison is performed for other numeric values.
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case '[object Date]':
    case '[object Boolean]':
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;
    case '[object Symbol]':
      return _setup["d" /* SymbolProto */].valueOf.call(a) === _setup["d" /* SymbolProto */].valueOf.call(b);
    case '[object ArrayBuffer]':
    case tagDataView:
      // Coerce to typed array so we can fall through.
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }

  var areArrays = className === '[object Array]';
  if (!areArrays && modules_isTypedArray(a)) {
      var byteLength = _getByteLength(a);
      if (byteLength !== _getByteLength(b)) return false;
      if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
      areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != 'object' || typeof b != 'object') return false;

    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(modules_isFunction(aCtor) && aCtor instanceof aCtor &&
                             modules_isFunction(bCtor) && bCtor instanceof bCtor)
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
  }
  // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  }

  // Add the first object to the stack of traversed objects.
  aStack.push(a);
  bStack.push(b);

  // Recursively compare objects and arrays.
  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false;
    // Deep compare the contents, ignoring non-numeric properties.
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var _keys = keys_keys(a), key;
    length = _keys.length;
    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys_keys(b).length !== length) return false;
    while (length--) {
      // Deep compare each member
      key = _keys[length];
      if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  // Remove the first object from the stack of traversed objects.
  aStack.pop();
  bStack.pop();
  return true;
}

// Perform a deep comparison to check if two objects are equal.
function isEqual(a, b) {
  return eq(a, b);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/allKeys.js




// Retrieve all the enumerable property names of an object.
function allKeys(obj) {
  if (!isObject(obj)) return [];
  var keys = [];
  for (var key in obj) keys.push(key);
  // Ahem, IE < 9.
  if (_setup["h" /* hasEnumBug */]) collectNonEnumProps(obj, keys);
  return keys;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_methodFingerprint.js




// Since the regular `Object.prototype.toString` type tests don't work for
// some types in IE 11, we use a fingerprinting heuristic instead, based
// on the methods. It's not great, but it's the best we got.
// The fingerprint method lists are defined below.
function ie11fingerprint(methods) {
  var length = _getLength(methods);
  return function(obj) {
    if (obj == null) return false;
    // `Map`, `WeakMap` and `Set` have no enumerable keys.
    var keys = allKeys(obj);
    if (_getLength(keys)) return false;
    for (var i = 0; i < length; i++) {
      if (!modules_isFunction(obj[methods[i]])) return false;
    }
    // If we are testing against `WeakMap`, we need to ensure that
    // `obj` doesn't have a `forEach` method in order to distinguish
    // it from a regular `Map`.
    return methods !== weakMapMethods || !modules_isFunction(obj[forEachName]);
  };
}

// In the interest of compact minification, we write
// each string in the fingerprints only once.
var forEachName = 'forEach',
    hasName = 'has',
    commonInit = ['clear', 'delete'],
    mapTail = ['get', hasName, 'set'];

// `Map`, `WeakMap` and `Set` each have slightly different
// combinations of the above sublists.
var mapMethods = commonInit.concat(forEachName, mapTail),
    weakMapMethods = commonInit.concat(mapTail),
    setMethods = ['add'].concat(commonInit, forEachName, hasName);

// CONCATENATED MODULE: ./node_modules/underscore/modules/isMap.js




/* harmony default export */ var isMap = (isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isWeakMap.js




/* harmony default export */ var isWeakMap = (isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isSet.js




/* harmony default export */ var isSet = (isIE11 ? ie11fingerprint(setMethods) : tagTester('Set'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/isWeakSet.js


/* harmony default export */ var isWeakSet = (tagTester('WeakSet'));

// CONCATENATED MODULE: ./node_modules/underscore/modules/values.js


// Retrieve the values of an object's properties.
function values_values(obj) {
  var _keys = keys_keys(obj);
  var length = _keys.length;
  var values = Array(length);
  for (var i = 0; i < length; i++) {
    values[i] = obj[_keys[i]];
  }
  return values;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/pairs.js


// Convert an object into a list of `[key, value]` pairs.
// The opposite of `_.object` with one argument.
function pairs_pairs(obj) {
  var _keys = keys_keys(obj);
  var length = _keys.length;
  var pairs = Array(length);
  for (var i = 0; i < length; i++) {
    pairs[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/invert.js


// Invert the keys and values of an object. The values must be serializable.
function invert(obj) {
  var result = {};
  var _keys = keys_keys(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result[obj[_keys[i]]] = _keys[i];
  }
  return result;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/functions.js


// Return a sorted list of the function names available on the object.
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (modules_isFunction(obj[key])) names.push(key);
  }
  return names.sort();
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_createAssigner.js
// An internal function for creating assigner functions.
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index],
          keys = keysFunc(source),
          l = keys.length;
      for (var i = 0; i < l; i++) {
        var key = keys[i];
        if (!defaults || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/extend.js



// Extend a given object with all the properties in passed-in object(s).
/* harmony default export */ var extend = (createAssigner(allKeys));

// CONCATENATED MODULE: ./node_modules/underscore/modules/extendOwn.js



// Assigns a given object with all the own properties in the passed-in
// object(s).
// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
/* harmony default export */ var extendOwn = (createAssigner(keys_keys));

// CONCATENATED MODULE: ./node_modules/underscore/modules/defaults.js



// Fill in a given object with default properties.
/* harmony default export */ var defaults = (createAssigner(allKeys, true));

// CONCATENATED MODULE: ./node_modules/underscore/modules/_baseCreate.js



// Create a naked function reference for surrogate-prototype-swapping.
function ctor() {
  return function(){};
}

// An internal function for creating a new object that inherits from another.
function baseCreate(prototype) {
  if (!isObject(prototype)) return {};
  if (_setup["j" /* nativeCreate */]) return Object(_setup["j" /* nativeCreate */])(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result = new Ctor;
  Ctor.prototype = null;
  return result;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/create.js



// Creates an object that inherits from the given prototype object.
// If additional properties are provided then they will be added to the
// created object.
function create(prototype, props) {
  var result = baseCreate(prototype);
  if (props) extendOwn(result, props);
  return result;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/clone.js




// Create a (shallow-cloned) duplicate of an object.
function clone(obj) {
  if (!isObject(obj)) return obj;
  return isArray(obj) ? obj.slice() : extend({}, obj);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/tap.js
// Invokes `interceptor` with the `obj` and then returns `obj`.
// The primary purpose of this method is to "tap into" a method chain, in
// order to perform operations on intermediate results within the chain.
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/toPath.js



// Normalize a (deep) property `path` to array.
// Like `_.iteratee`, this function can be customized.
function toPath(path) {
  return isArray(path) ? path : [path];
}
_.toPath = toPath;

// CONCATENATED MODULE: ./node_modules/underscore/modules/_toPath.js



// Internal wrapper for `_.toPath` to enable minification.
// Similar to `cb` for `_.iteratee`.
function _toPath_toPath(path) {
  return _.toPath(path);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_deepGet.js
// Internal function to obtain a nested property in `obj` along `path`.
function deepGet(obj, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/get.js




// Get the value of the (deep) property on `path` from `object`.
// If any property in `path` does not exist or if the value is
// `undefined`, return `defaultValue` instead.
// The `path` is normalized through `_.toPath`.
function get(object, path, defaultValue) {
  var value = deepGet(object, _toPath_toPath(path));
  return isUndefined(value) ? defaultValue : value;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/has.js



// Shortcut function for checking if an object has a given property directly on
// itself (in other words, not on a prototype). Unlike the internal `has`
// function, this public version can also traverse nested properties.
function has_has(obj, path) {
  path = _toPath_toPath(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!has(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/identity.js
// Keep the identity function around for default iteratees.
function identity(value) {
  return value;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/matcher.js



// Returns a predicate for checking whether an object has a given set of
// `key:value` pairs.
function matcher_matcher(attrs) {
  attrs = extendOwn({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/property.js



// Creates a function that, when passed an object, will traverse that object’s
// properties down the given `path`, specified as an array of keys or indices.
function property(path) {
  path = _toPath_toPath(path);
  return function(obj) {
    return deepGet(obj, path);
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_optimizeCb.js
// Internal function that returns an efficient (for current engines) version
// of the passed-in callback, to be repeatedly applied in other Underscore
// functions.
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1: return function(value) {
      return func.call(context, value);
    };
    // The 2-argument case is omitted because we’re not using it.
    case 3: return function(value, index, collection) {
      return func.call(context, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(context, accumulator, value, index, collection);
    };
  }
  return function() {
    return func.apply(context, arguments);
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_baseIteratee.js








// An internal function to generate callbacks that can be applied to each
// element in a collection, returning the desired result — either `_.identity`,
// an arbitrary callback, a property matcher, or a property accessor.
function baseIteratee(value, context, argCount) {
  if (value == null) return identity;
  if (modules_isFunction(value)) return optimizeCb(value, context, argCount);
  if (isObject(value) && !isArray(value)) return matcher_matcher(value);
  return property(value);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/iteratee.js



// External wrapper for our callback generator. Users may customize
// `_.iteratee` if they want additional predicate/iteratee shorthand styles.
// This abstraction hides the internal-only `argCount` argument.
function iteratee_iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
_.iteratee = iteratee_iteratee;

// CONCATENATED MODULE: ./node_modules/underscore/modules/_cb.js




// The function we call internally to generate a callback. It invokes
// `_.iteratee` if overridden, otherwise `baseIteratee`.
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee_iteratee) return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/mapObject.js



// Returns the results of applying the `iteratee` to each element of `obj`.
// In contrast to `_.map` it returns an object.
function mapObject(obj, iteratee, context) {
  iteratee = cb(iteratee, context);
  var _keys = keys_keys(obj),
      length = _keys.length,
      results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/noop.js
// Predicate-generating function. Often useful outside of Underscore.
function noop(){}

// CONCATENATED MODULE: ./node_modules/underscore/modules/propertyOf.js



// Generates a function for a given object that returns a given property.
function propertyOf(obj) {
  if (obj == null) return noop;
  return function(path) {
    return get(obj, path);
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/times.js


// Run a function **n** times.
function times(n, iteratee, context) {
  var accum = Array(Math.max(0, n));
  iteratee = optimizeCb(iteratee, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee(i);
  return accum;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/random.js
// Return a random integer between `min` and `max` (inclusive).
function random(min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }
  return min + Math.floor(Math.random() * (max - min + 1));
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/now.js
// A (possibly faster) way to get the current timestamp as an integer.
/* harmony default export */ var now = (Date.now || function() {
  return new Date().getTime();
});

// CONCATENATED MODULE: ./node_modules/underscore/modules/_createEscaper.js


// Internal helper to generate functions for escaping and unescaping strings
// to/from HTML interpolation.
function createEscaper(map) {
  var escaper = function(match) {
    return map[match];
  };
  // Regexes for identifying a key that needs to be escaped.
  var source = '(?:' + keys_keys(map).join('|') + ')';
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, 'g');
  return function(string) {
    string = string == null ? '' : '' + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_escapeMap.js
// Internal list of HTML entities for escaping.
/* harmony default export */ var _escapeMap = ({
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;'
});

// CONCATENATED MODULE: ./node_modules/underscore/modules/escape.js



// Function for escaping strings to HTML interpolation.
/* harmony default export */ var modules_escape = (createEscaper(_escapeMap));

// CONCATENATED MODULE: ./node_modules/underscore/modules/_unescapeMap.js



// Internal list of HTML entities for unescaping.
/* harmony default export */ var _unescapeMap = (invert(_escapeMap));

// CONCATENATED MODULE: ./node_modules/underscore/modules/unescape.js



// Function for unescaping strings from HTML interpolation.
/* harmony default export */ var modules_unescape = (createEscaper(_unescapeMap));

// CONCATENATED MODULE: ./node_modules/underscore/modules/templateSettings.js


// By default, Underscore uses ERB-style template delimiters. Change the
// following template settings to use alternative delimiters.
/* harmony default export */ var templateSettings = (_.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
});

// CONCATENATED MODULE: ./node_modules/underscore/modules/template.js




// When customizing `_.templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
  "'": "'",
  '\\': '\\',
  '\r': 'r',
  '\n': 'n',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

function escapeChar(match) {
  return '\\' + escapes[match];
}

// In order to prevent third-party code injection through
// `_.templateSettings.variable`, we test it against the following regular
// expression. It is intentionally a bit more liberal than just matching valid
// identifiers, but still prevents possible loopholes through defaults or
// destructuring assignment.
var bareIdentifier = /^\s*(\w|\$)+\s*$/;

// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
// NB: `oldSettings` only exists for backwards compatibility.
function template_template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = defaults({}, settings, _.templateSettings);

  // Combine delimiters into one regular expression via alternation.
  var matcher = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join('|') + '|$', 'g');

  // Compile the template source, escaping string literals appropriately.
  var index = 0;
  var source = "__p+='";
  text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;

    if (escape) {
      source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }

    // Adobe VMs need the match returned to produce the correct offset.
    return match;
  });
  source += "';\n";

  var argument = settings.variable;
  if (argument) {
    // Insure against third-party code injection. (CVE-2021-23358)
    if (!bareIdentifier.test(argument)) throw new Error(
      'variable is not a bare identifier: ' + argument
    );
  } else {
    // If a variable is not specified, place data values in local scope.
    source = 'with(obj||{}){\n' + source + '}\n';
    argument = 'obj';
  }

  source = "var __t,__p='',__j=Array.prototype.join," +
    "print=function(){__p+=__j.call(arguments,'');};\n" +
    source + 'return __p;\n';

  var render;
  try {
    render = new Function(argument, '_', source);
  } catch (e) {
    e.source = source;
    throw e;
  }

  var template = function(data) {
    return render.call(this, data, _);
  };

  // Provide the compiled source as a convenience for precompilation.
  template.source = 'function(' + argument + '){\n' + source + '}';

  return template;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/result.js



// Traverses the children of `obj` along `path`. If a child is a function, it
// is invoked with its parent as context. Returns the value of the final
// child, or `fallback` if any child is undefined.
function result_result(obj, path, fallback) {
  path = _toPath_toPath(path);
  var length = path.length;
  if (!length) {
    return modules_isFunction(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length; // Ensure we don't continue iterating.
    }
    obj = modules_isFunction(prop) ? prop.call(obj) : prop;
  }
  return obj;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/uniqueId.js
// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + '';
  return prefix ? prefix + id : id;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/chain.js


// Start chaining a wrapped Underscore object.
function chain(obj) {
  var instance = _(obj);
  instance._chain = true;
  return instance;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_executeBound.js



// Internal function to execute `sourceFunc` bound to `context` with optional
// `args`. Determines whether to execute a function as a constructor or as a
// normal function.
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self = baseCreate(sourceFunc.prototype);
  var result = sourceFunc.apply(self, args);
  if (isObject(result)) return result;
  return self;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/partial.js




// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. `_` acts
// as a placeholder by default, allowing any combination of arguments to be
// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
var partial = restArguments(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length) args.push(arguments[position++]);
    return executeBound(func, bound, this, this, args);
  };
  return bound;
});

partial.placeholder = _;
/* harmony default export */ var modules_partial = (partial);

// CONCATENATED MODULE: ./node_modules/underscore/modules/bind.js




// Create a function bound to a given object (assigning `this`, and arguments,
// optionally).
/* harmony default export */ var bind = (restArguments(function(func, context, args) {
  if (!modules_isFunction(func)) throw new TypeError('Bind must be called on a function');
  var bound = restArguments(function(callArgs) {
    return executeBound(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/_isArrayLike.js



// Internal helper for collection methods to determine whether a collection
// should be iterated as an array or as an object.
// Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
/* harmony default export */ var _isArrayLike = (createSizePropertyCheck(_getLength));

// CONCATENATED MODULE: ./node_modules/underscore/modules/_flatten.js





// Internal implementation of a recursive `flatten` function.
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = _getLength(input); i < length; i++) {
    var value = input[i];
    if (_isArrayLike(value) && (isArray(value) || modules_isArguments(value))) {
      // Flatten current level of array or arguments object.
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/bindAll.js




// Bind a number of an object's methods to that object. Remaining arguments
// are the method names to be bound. Useful for ensuring that all callbacks
// defined on an object belong to it.
/* harmony default export */ var bindAll = (restArguments(function(obj, keys) {
  keys = flatten(keys, false, false);
  var index = keys.length;
  if (index < 1) throw new Error('bindAll must be passed function names');
  while (index--) {
    var key = keys[index];
    obj[key] = bind(obj[key], obj);
  }
  return obj;
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/memoize.js


// Memoize an expensive function by storing its results.
function memoize_memoize(func, hasher) {
  var memoize = function(key) {
    var cache = memoize.cache;
    var address = '' + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize.cache = {};
  return memoize;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/delay.js


// Delays a function for the given number of milliseconds, and then calls
// it with the arguments supplied.
/* harmony default export */ var delay = (restArguments(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/defer.js




// Defers a function, scheduling it to run after the current call stack has
// cleared.
/* harmony default export */ var defer = (modules_partial(delay, _, 1));

// CONCATENATED MODULE: ./node_modules/underscore/modules/throttle.js


// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
function throttle(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    var _now = now();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/debounce.js



// When a sequence of calls of the returned function ends, the argument
// function is triggered. The end of a sequence is defined by the `wait`
// parameter. If `immediate` is passed, the argument function will be
// triggered at the beginning of the sequence instead of at the end.
function debounce(func, wait, immediate) {
  var timeout, previous, args, result, context;

  var later = function() {
    var passed = now() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
      // This check is needed because `func` can recursively invoke `debounced`.
      if (!timeout) args = context = null;
    }
  };

  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result = func.apply(context, args);
    }
    return result;
  });

  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };

  return debounced;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/wrap.js


// Returns the first function passed as an argument to the second,
// allowing you to adjust arguments, run code before and after, and
// conditionally execute the original function.
function wrap(func, wrapper) {
  return modules_partial(wrapper, func);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/negate.js
// Returns a negated version of the passed-in predicate.
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/compose.js
// Returns a function that is the composition of a list of functions, each
// consuming the return value of the function that follows.
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result = args[start].apply(this, arguments);
    while (i--) result = args[i].call(this, result);
    return result;
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/after.js
// Returns a function that will only be executed on and after the Nth call.
function after(times, func) {
  return function() {
    if (--times < 1) {
      return func.apply(this, arguments);
    }
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/before.js
// Returns a function that will only be executed up to (but not including) the
// Nth call.
function before(times, func) {
  var memo;
  return function() {
    if (--times > 0) {
      memo = func.apply(this, arguments);
    }
    if (times <= 1) func = null;
    return memo;
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/once.js



// Returns a function that will be executed at most one time, no matter how
// often you call it. Useful for lazy initialization.
/* harmony default export */ var once = (modules_partial(before, 2));

// CONCATENATED MODULE: ./node_modules/underscore/modules/findKey.js



// Returns the first key on an object that passes a truth test.
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys_keys(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_createPredicateIndexFinder.js



// Internal function to generate `_.findIndex` and `_.findLastIndex`.
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = _getLength(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/findIndex.js


// Returns the first index on an array-like that passes a truth test.
/* harmony default export */ var findIndex = (createPredicateIndexFinder(1));

// CONCATENATED MODULE: ./node_modules/underscore/modules/findLastIndex.js


// Returns the last index on an array-like that passes a truth test.
/* harmony default export */ var findLastIndex = (createPredicateIndexFinder(-1));

// CONCATENATED MODULE: ./node_modules/underscore/modules/sortedIndex.js



// Use a comparator function to figure out the smallest index at which
// an object should be inserted so as to maintain order. Uses binary search.
function sortedIndex_sortedIndex(array, obj, iteratee, context) {
  iteratee = cb(iteratee, context, 1);
  var value = iteratee(obj);
  var low = 0, high = _getLength(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
  }
  return low;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_createIndexFinder.js




// Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
function createIndexFinder(dir, predicateFind, sortedIndex) {
  return function(array, item, idx) {
    var i = 0, length = _getLength(array);
    if (typeof idx == 'number') {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex && idx && length) {
      idx = sortedIndex(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(_setup["q" /* slice */].call(array, i, length), isNaN_isNaN);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/indexOf.js




// Return the position of the first occurrence of an item in an array,
// or -1 if the item is not included in the array.
// If the array is large and already in sort order, pass `true`
// for **isSorted** to use binary search.
/* harmony default export */ var indexOf = (createIndexFinder(1, findIndex, sortedIndex_sortedIndex));

// CONCATENATED MODULE: ./node_modules/underscore/modules/lastIndexOf.js



// Return the position of the last occurrence of an item in an array,
// or -1 if the item is not included in the array.
/* harmony default export */ var lastIndexOf = (createIndexFinder(-1, findLastIndex));

// CONCATENATED MODULE: ./node_modules/underscore/modules/find.js




// Return the first value which passes a truth test.
function find(obj, predicate, context) {
  var keyFinder = _isArrayLike(obj) ? findIndex : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/findWhere.js



// Convenience version of a common use case of `_.find`: getting the first
// object containing specific `key:value` pairs.
function findWhere(obj, attrs) {
  return find(obj, matcher_matcher(attrs));
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/each.js




// The cornerstone for collection functions, an `each`
// implementation, aka `forEach`.
// Handles raw objects in addition to array-likes. Treats all
// sparse array-likes as if they were dense.
function each(obj, iteratee, context) {
  iteratee = optimizeCb(iteratee, context);
  var i, length;
  if (_isArrayLike(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee(obj[i], i, obj);
    }
  } else {
    var _keys = keys_keys(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/map.js




// Return the results of applying the iteratee to each element.
function map_map(obj, iteratee, context) {
  iteratee = cb(iteratee, context);
  var _keys = !_isArrayLike(obj) && keys_keys(obj),
      length = (_keys || obj).length,
      results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_createReduce.js




// Internal helper to create a reducing function, iterating left or right.
function createReduce(dir) {
  // Wrap code that reassigns argument variables in a separate function than
  // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
  var reducer = function(obj, iteratee, memo, initial) {
    var _keys = !_isArrayLike(obj) && keys_keys(obj),
        length = (_keys || obj).length,
        index = dir > 0 ? 0 : length - 1;
    if (!initial) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  return function(obj, iteratee, memo, context) {
    var initial = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/reduce.js


// **Reduce** builds up a single result from a list of values, aka `inject`,
// or `foldl`.
/* harmony default export */ var reduce = (createReduce(1));

// CONCATENATED MODULE: ./node_modules/underscore/modules/reduceRight.js


// The right-associative version of reduce, also known as `foldr`.
/* harmony default export */ var reduceRight = (createReduce(-1));

// CONCATENATED MODULE: ./node_modules/underscore/modules/filter.js



// Return all the elements that pass a truth test.
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function(value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/reject.js




// Return all the elements for which a truth test fails.
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/every.js




// Determine whether all of the elements pass a truth test.
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !_isArrayLike(obj) && keys_keys(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/some.js




// Determine if at least one element in the object passes a truth test.
function some(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !_isArrayLike(obj) && keys_keys(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/contains.js




// Determine if the array or object contains a given item (using `===`).
function contains(obj, item, fromIndex, guard) {
  if (!_isArrayLike(obj)) obj = values_values(obj);
  if (typeof fromIndex != 'number' || guard) fromIndex = 0;
  return indexOf(obj, item, fromIndex) >= 0;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/invoke.js






// Invoke a method (with arguments) on every item in a collection.
/* harmony default export */ var invoke = (restArguments(function(obj, path, args) {
  var contextPath, func;
  if (modules_isFunction(path)) {
    func = path;
  } else {
    path = _toPath_toPath(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return map_map(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = deepGet(context, contextPath);
      }
      if (context == null) return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/pluck.js



// Convenience version of a common use case of `_.map`: fetching a property.
function pluck(obj, key) {
  return map_map(obj, property(key));
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/where.js



// Convenience version of a common use case of `_.filter`: selecting only
// objects containing specific `key:value` pairs.
function where(obj, attrs) {
  return filter(obj, matcher_matcher(attrs));
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/max.js





// Return the maximum element (or element-based computation).
function max(obj, iteratee, context) {
  var result = -Infinity, lastComputed = -Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    obj = _isArrayLike(obj) ? obj : values_values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result) {
        result = value;
      }
    }
  } else {
    iteratee = cb(iteratee, context);
    each(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/min.js





// Return the minimum element (or element-based computation).
function min(obj, iteratee, context) {
  var result = Infinity, lastComputed = Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    obj = _isArrayLike(obj) ? obj : values_values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result) {
        result = value;
      }
    }
  } else {
    iteratee = cb(iteratee, context);
    each(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed < lastComputed || (computed === Infinity && result === Infinity)) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/toArray.js








// Safely create a real, live array from anything iterable.
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj) return [];
  if (isArray(obj)) return _setup["q" /* slice */].call(obj);
  if (isString(obj)) {
    // Keep surrogate pair characters together.
    return obj.match(reStrSymbol);
  }
  if (_isArrayLike(obj)) return map_map(obj, identity);
  return values_values(obj);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/sample.js






// Sample **n** random values from a collection using the modern version of the
// [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
// If **n** is not specified, returns a single random element.
// The internal `guard` argument allows it to work with `_.map`.
function sample_sample(obj, n, guard) {
  if (n == null || guard) {
    if (!_isArrayLike(obj)) obj = values_values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample = toArray(obj);
  var length = _getLength(sample);
  n = Math.max(Math.min(n, length), 0);
  var last = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last);
    var temp = sample[index];
    sample[index] = sample[rand];
    sample[rand] = temp;
  }
  return sample.slice(0, n);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/shuffle.js


// Shuffle a collection.
function shuffle(obj) {
  return sample_sample(obj, Infinity);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/sortBy.js




// Sort the object's values by a criterion produced by an iteratee.
function sortBy(obj, iteratee, context) {
  var index = 0;
  iteratee = cb(iteratee, context);
  return pluck(map_map(obj, function(value, key, list) {
    return {
      value: value,
      index: index++,
      criteria: iteratee(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), 'value');
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_group.js



// An internal function used for aggregate "group by" operations.
function group(behavior, partition) {
  return function(obj, iteratee, context) {
    var result = partition ? [[], []] : {};
    iteratee = cb(iteratee, context);
    each(obj, function(value, index) {
      var key = iteratee(value, index, obj);
      behavior(result, value, key);
    });
    return result;
  };
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/groupBy.js



// Groups the object's values by a criterion. Pass either a string attribute
// to group by, or a function that returns the criterion.
/* harmony default export */ var groupBy = (group(function(result, value, key) {
  if (has(result, key)) result[key].push(value); else result[key] = [value];
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/indexBy.js


// Indexes the object's values by a criterion, similar to `_.groupBy`, but for
// when you know that your index values will be unique.
/* harmony default export */ var indexBy = (group(function(result, value, key) {
  result[key] = value;
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/countBy.js



// Counts instances of an object that group by a certain criterion. Pass
// either a string attribute to count by, or a function that returns the
// criterion.
/* harmony default export */ var countBy = (group(function(result, value, key) {
  if (has(result, key)) result[key]++; else result[key] = 1;
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/partition.js


// Split a collection into two arrays: one whose elements all pass the given
// truth test, and one whose elements all do not pass the truth test.
/* harmony default export */ var modules_partition = (group(function(result, value, pass) {
  result[pass ? 0 : 1].push(value);
}, true));

// CONCATENATED MODULE: ./node_modules/underscore/modules/size.js



// Return the number of elements in a collection.
function size(obj) {
  if (obj == null) return 0;
  return _isArrayLike(obj) ? obj.length : keys_keys(obj).length;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_keyInObj.js
// Internal `_.pick` helper function to determine whether `key` is an enumerable
// property name of `obj`.
function keyInObj(value, key, obj) {
  return key in obj;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/pick.js







// Return a copy of the object only containing the allowed properties.
/* harmony default export */ var pick = (restArguments(function(obj, keys) {
  var result = {}, iteratee = keys[0];
  if (obj == null) return result;
  if (modules_isFunction(iteratee)) {
    if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
    keys = allKeys(obj);
  } else {
    iteratee = keyInObj;
    keys = flatten(keys, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys.length; i < length; i++) {
    var key = keys[i];
    var value = obj[key];
    if (iteratee(value, key, obj)) result[key] = value;
  }
  return result;
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/omit.js








// Return a copy of the object without the disallowed properties.
/* harmony default export */ var omit = (restArguments(function(obj, keys) {
  var iteratee = keys[0], context;
  if (modules_isFunction(iteratee)) {
    iteratee = negate(iteratee);
    if (keys.length > 1) context = keys[1];
  } else {
    keys = map_map(flatten(keys, false, false), String);
    iteratee = function(value, key) {
      return !contains(keys, key);
    };
  }
  return pick(obj, iteratee, context);
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/initial.js


// Returns everything but the last entry of the array. Especially useful on
// the arguments object. Passing **n** will return all the values in
// the array, excluding the last N.
function initial_initial(array, n, guard) {
  return _setup["q" /* slice */].call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/first.js


// Get the first element of an array. Passing **n** will return the first N
// values in the array. The **guard** check allows it to work with `_.map`.
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return initial_initial(array, array.length - n);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/rest.js


// Returns everything but the first entry of the `array`. Especially useful on
// the `arguments` object. Passing an **n** will return the rest N values in the
// `array`.
function rest_rest(array, n, guard) {
  return _setup["q" /* slice */].call(array, n == null || guard ? 1 : n);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/last.js


// Get the last element of an array. Passing **n** will return the last N
// values in the array.
function last_last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return rest_rest(array, Math.max(0, array.length - n));
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/compact.js


// Trim out all falsy values from an array.
function compact(array) {
  return filter(array, Boolean);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/flatten.js


// Flatten out an array, either recursively (by default), or up to `depth`.
// Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
function flatten_flatten(array, depth) {
  return flatten(array, depth, false);
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/difference.js





// Take the difference between one array and a number of other arrays.
// Only the elements present in just the first array will remain.
/* harmony default export */ var difference = (restArguments(function(array, rest) {
  rest = flatten(rest, true, true);
  return filter(array, function(value){
    return !contains(rest, value);
  });
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/without.js



// Return a version of the array that does not contain the specified value(s).
/* harmony default export */ var without = (restArguments(function(array, otherArrays) {
  return difference(array, otherArrays);
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/uniq.js





// Produce a duplicate-free version of the array. If the array has already
// been sorted, you have the option of using a faster algorithm.
// The faster algorithm will not work with an iteratee if the iteratee
// is not a one-to-one function, so providing an iteratee will disable
// the faster algorithm.
function uniq(array, isSorted, iteratee, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee;
    iteratee = isSorted;
    isSorted = false;
  }
  if (iteratee != null) iteratee = cb(iteratee, context);
  var result = [];
  var seen = [];
  for (var i = 0, length = _getLength(array); i < length; i++) {
    var value = array[i],
        computed = iteratee ? iteratee(value, i, array) : value;
    if (isSorted && !iteratee) {
      if (!i || seen !== computed) result.push(value);
      seen = computed;
    } else if (iteratee) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result.push(value);
      }
    } else if (!contains(result, value)) {
      result.push(value);
    }
  }
  return result;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/union.js




// Produce an array that contains the union: each distinct element from all of
// the passed-in arrays.
/* harmony default export */ var union = (restArguments(function(arrays) {
  return uniq(flatten(arrays, true, true));
}));

// CONCATENATED MODULE: ./node_modules/underscore/modules/intersection.js



// Produce an array that contains every item shared between all the
// passed-in arrays.
function intersection(array) {
  var result = [];
  var argsLength = arguments.length;
  for (var i = 0, length = _getLength(array); i < length; i++) {
    var item = array[i];
    if (contains(result, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result.push(item);
  }
  return result;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/unzip.js




// Complement of zip. Unzip accepts an array of arrays and groups
// each array's elements on shared indices.
function unzip(array) {
  var length = (array && max(array, _getLength).length) || 0;
  var result = Array(length);

  for (var index = 0; index < length; index++) {
    result[index] = pluck(array, index);
  }
  return result;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/zip.js



// Zip together multiple lists into a single array -- elements that share
// an index go together.
/* harmony default export */ var zip = (restArguments(unzip));

// CONCATENATED MODULE: ./node_modules/underscore/modules/object.js


// Converts lists into objects. Pass either a single array of `[key, value]`
// pairs, or two parallel arrays of the same length -- one of keys, and one of
// the corresponding values. Passing by pairs is the reverse of `_.pairs`.
function object_object(list, values) {
  var result = {};
  for (var i = 0, length = _getLength(list); i < length; i++) {
    if (values) {
      result[list[i]] = values[i];
    } else {
      result[list[i][0]] = list[i][1];
    }
  }
  return result;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/range.js
// Generate an integer Array containing an arithmetic progression. A port of
// the native Python `range()` function. See
// [the Python documentation](https://docs.python.org/library/functions.html#range).
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }

  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range = Array(length);

  for (var idx = 0; idx < length; idx++, start += step) {
    range[idx] = start;
  }

  return range;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/chunk.js


// Chunk a single array into multiple arrays, each containing `count` or fewer
// items.
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result = [];
  var i = 0, length = array.length;
  while (i < length) {
    result.push(_setup["q" /* slice */].call(array, i, i += count));
  }
  return result;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/_chainResult.js


// Helper function to continue chaining intermediate results.
function chainResult(instance, obj) {
  return instance._chain ? _(obj).chain() : obj;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/mixin.js






// Add your own custom functions to the Underscore object.
function mixin(obj) {
  each(functions(obj), function(name) {
    var func = _[name] = obj[name];
    _.prototype[name] = function() {
      var args = [this._wrapped];
      _setup["o" /* push */].apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}

// CONCATENATED MODULE: ./node_modules/underscore/modules/underscore-array-methods.js





// Add all mutator `Array` functions to the wrapper.
each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
  var method = _setup["a" /* ArrayProto */][name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) {
        delete obj[0];
      }
    }
    return chainResult(this, obj);
  };
});

// Add all accessor `Array` functions to the wrapper.
each(['concat', 'join', 'slice'], function(name) {
  var method = _setup["a" /* ArrayProto */][name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) obj = method.apply(obj, arguments);
    return chainResult(this, obj);
  };
});

/* harmony default export */ var underscore_array_methods = (_);

// CONCATENATED MODULE: ./node_modules/underscore/modules/index.js
// Named Exports
// =============

//     Underscore.js 1.13.6
//     https://underscorejs.org
//     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

// Baseline setup.



// Object Functions
// ----------------
// Our most fundamental functions operate on any JavaScript object.
// Most functions in Underscore depend on at least one function in this section.

// A group of functions that check the types of core JavaScript values.
// These are often informally referred to as the "isType" functions.



























// Functions that treat an object as a dictionary of key-value pairs.
















// Utility Functions
// -----------------
// A bit of a grab bag: Predicate-generating functions for use with filters and
// loops, string escaping and templating, create random numbers and unique ids,
// and functions that facilitate Underscore's chaining and iteration conventions.



















// Function (ahem) Functions
// -------------------------
// These functions take a function as an argument and return a new function
// as the result. Also known as higher-order functions.















// Finders
// -------
// Functions that extract (the position of) a single element from an object
// or array based on some criterion.









// Collection Functions
// --------------------
// Functions that work on any collection of elements: either an array, or
// an object of key-value pairs.
























// `_.pick` and `_.omit` are actually object functions, but we put
// them here in order to create a more natural reading order in the
// monolithic build as they depend on `_.contains`.



// Array Functions
// ---------------
// Functions that operate on arrays (and array-likes) only, because they’re
// expressed in terms of operations on an ordered list of values.

















// OOP
// ---
// These modules support the "object-oriented" calling style. See also
// `underscore.js` and `index-default.js`.



// CONCATENATED MODULE: ./node_modules/underscore/modules/index-default.js
// Default Export
// ==============
// In this module, we mix our bundled exports into the `_` object and export
// the result. This is analogous to setting `module.exports = _` in CommonJS.
// Hence, this module is also the entry point of our UMD bundle and the package
// entry point for CommonJS and AMD users. In other words, this is (the source
// of) the module you are interfacing with when you do any of the following:
//
// ```js
// // CommonJS
// var _ = require('underscore');
//
// // AMD
// define(['underscore'], function(_) {...});
//
// // UMD in the browser
// // _ is available as a global variable
// ```



// Add all of the Underscore functions to the wrapper object.
var index_default_ = mixin(modules_namespaceObject);
// Legacy Node.js API.
index_default_._ = index_default_;
// Export the Underscore API.
/* harmony default export */ var index_default = (index_default_);

// CONCATENATED MODULE: ./node_modules/underscore/modules/index-all.js
// ESM Exports
// ===========
// This module is the package entry point for ES module users. In other words,
// it is the module they are interfacing with when they import from the whole
// package instead of from a submodule, like this:
//
// ```js
// import { map } from 'underscore';
// ```
//
// The difference with `./index-default`, which is the package entry point for
// CommonJS, AMD and UMD users, is purely technical. In ES modules, named and
// default exports are considered to be siblings, so when you have a default
// export, its properties are not automatically available as named exports. For
// this reason, we re-export the named exports in addition to providing the same
// default export as in `./index-default`.




/***/ }),
/* 6 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return cloneElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return createRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rerender", function() { return rerender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "options", function() { return options; });
var VNode = function VNode() {};

var options = {};

var stack = [];

var EMPTY_CHILDREN = [];

function h(nodeName, attributes) {
	var children = EMPTY_CHILDREN,
	    lastSimple,
	    child,
	    simple,
	    i;
	for (i = arguments.length; i-- > 2;) {
		stack.push(arguments[i]);
	}
	if (attributes && attributes.children != null) {
		if (!stack.length) stack.push(attributes.children);
		delete attributes.children;
	}
	while (stack.length) {
		if ((child = stack.pop()) && child.pop !== undefined) {
			for (i = child.length; i--;) {
				stack.push(child[i]);
			}
		} else {
			if (typeof child === 'boolean') child = null;

			if (simple = typeof nodeName !== 'function') {
				if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
			}

			if (simple && lastSimple) {
				children[children.length - 1] += child;
			} else if (children === EMPTY_CHILDREN) {
				children = [child];
			} else {
				children.push(child);
			}

			lastSimple = simple;
		}
	}

	var p = new VNode();
	p.nodeName = nodeName;
	p.children = children;
	p.attributes = attributes == null ? undefined : attributes;
	p.key = attributes == null ? undefined : attributes.key;

	if (options.vnode !== undefined) options.vnode(p);

	return p;
}

function extend(obj, props) {
  for (var i in props) {
    obj[i] = props[i];
  }return obj;
}

function applyRef(ref, value) {
  if (ref) {
    if (typeof ref == 'function') ref(value);else ref.current = value;
  }
}

var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

function cloneElement(vnode, props) {
  return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
}

var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

var items = [];

function enqueueRender(component) {
	if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
		(options.debounceRendering || defer)(rerender);
	}
}

function rerender() {
	var p;
	while (p = items.pop()) {
		if (p._dirty) renderComponent(p);
	}
}

function isSameNodeType(node, vnode, hydrating) {
	if (typeof vnode === 'string' || typeof vnode === 'number') {
		return node.splitText !== undefined;
	}
	if (typeof vnode.nodeName === 'string') {
		return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
	}
	return hydrating || node._componentConstructor === vnode.nodeName;
}

function isNamedNode(node, nodeName) {
	return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
}

function getNodeProps(vnode) {
	var props = extend({}, vnode.attributes);
	props.children = vnode.children;

	var defaultProps = vnode.nodeName.defaultProps;
	if (defaultProps !== undefined) {
		for (var i in defaultProps) {
			if (props[i] === undefined) {
				props[i] = defaultProps[i];
			}
		}
	}

	return props;
}

function createNode(nodeName, isSvg) {
	var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
	node.normalizedNodeName = nodeName;
	return node;
}

function removeNode(node) {
	var parentNode = node.parentNode;
	if (parentNode) parentNode.removeChild(node);
}

function setAccessor(node, name, old, value, isSvg) {
	if (name === 'className') name = 'class';

	if (name === 'key') {} else if (name === 'ref') {
		applyRef(old, null);
		applyRef(value, node);
	} else if (name === 'class' && !isSvg) {
		node.className = value || '';
	} else if (name === 'style') {
		if (!value || typeof value === 'string' || typeof old === 'string') {
			node.style.cssText = value || '';
		}
		if (value && typeof value === 'object') {
			if (typeof old !== 'string') {
				for (var i in old) {
					if (!(i in value)) node.style[i] = '';
				}
			}
			for (var i in value) {
				node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
			}
		}
	} else if (name === 'dangerouslySetInnerHTML') {
		if (value) node.innerHTML = value.__html || '';
	} else if (name[0] == 'o' && name[1] == 'n') {
		var useCapture = name !== (name = name.replace(/Capture$/, ''));
		name = name.toLowerCase().substring(2);
		if (value) {
			if (!old) node.addEventListener(name, eventProxy, useCapture);
		} else {
			node.removeEventListener(name, eventProxy, useCapture);
		}
		(node._listeners || (node._listeners = {}))[name] = value;
	} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
		try {
			node[name] = value == null ? '' : value;
		} catch (e) {}
		if ((value == null || value === false) && name != 'spellcheck') node.removeAttribute(name);
	} else {
		var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));

		if (value == null || value === false) {
			if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
		} else if (typeof value !== 'function') {
			if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
		}
	}
}

function eventProxy(e) {
	return this._listeners[e.type](options.event && options.event(e) || e);
}

var mounts = [];

var diffLevel = 0;

var isSvgMode = false;

var hydrating = false;

function flushMounts() {
	var c;
	while (c = mounts.shift()) {
		if (options.afterMount) options.afterMount(c);
		if (c.componentDidMount) c.componentDidMount();
	}
}

function diff(dom, vnode, context, mountAll, parent, componentRoot) {
	if (!diffLevel++) {
		isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

		hydrating = dom != null && !('__preactattr_' in dom);
	}

	var ret = idiff(dom, vnode, context, mountAll, componentRoot);

	if (parent && ret.parentNode !== parent) parent.appendChild(ret);

	if (! --diffLevel) {
		hydrating = false;

		if (!componentRoot) flushMounts();
	}

	return ret;
}

function idiff(dom, vnode, context, mountAll, componentRoot) {
	var out = dom,
	    prevSvgMode = isSvgMode;

	if (vnode == null || typeof vnode === 'boolean') vnode = '';

	if (typeof vnode === 'string' || typeof vnode === 'number') {
		if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
			if (dom.nodeValue != vnode) {
				dom.nodeValue = vnode;
			}
		} else {
			out = document.createTextNode(vnode);
			if (dom) {
				if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
				recollectNodeTree(dom, true);
			}
		}

		out['__preactattr_'] = true;

		return out;
	}

	var vnodeName = vnode.nodeName;
	if (typeof vnodeName === 'function') {
		return buildComponentFromVNode(dom, vnode, context, mountAll);
	}

	isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

	vnodeName = String(vnodeName);
	if (!dom || !isNamedNode(dom, vnodeName)) {
		out = createNode(vnodeName, isSvgMode);

		if (dom) {
			while (dom.firstChild) {
				out.appendChild(dom.firstChild);
			}
			if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

			recollectNodeTree(dom, true);
		}
	}

	var fc = out.firstChild,
	    props = out['__preactattr_'],
	    vchildren = vnode.children;

	if (props == null) {
		props = out['__preactattr_'] = {};
		for (var a = out.attributes, i = a.length; i--;) {
			props[a[i].name] = a[i].value;
		}
	}

	if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
		if (fc.nodeValue != vchildren[0]) {
			fc.nodeValue = vchildren[0];
		}
	} else if (vchildren && vchildren.length || fc != null) {
			innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
		}

	diffAttributes(out, vnode.attributes, props);

	isSvgMode = prevSvgMode;

	return out;
}

function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
	var originalChildren = dom.childNodes,
	    children = [],
	    keyed = {},
	    keyedLen = 0,
	    min = 0,
	    len = originalChildren.length,
	    childrenLen = 0,
	    vlen = vchildren ? vchildren.length : 0,
	    j,
	    c,
	    f,
	    vchild,
	    child;

	if (len !== 0) {
		for (var i = 0; i < len; i++) {
			var _child = originalChildren[i],
			    props = _child['__preactattr_'],
			    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
			if (key != null) {
				keyedLen++;
				keyed[key] = _child;
			} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
				children[childrenLen++] = _child;
			}
		}
	}

	if (vlen !== 0) {
		for (var i = 0; i < vlen; i++) {
			vchild = vchildren[i];
			child = null;

			var key = vchild.key;
			if (key != null) {
				if (keyedLen && keyed[key] !== undefined) {
					child = keyed[key];
					keyed[key] = undefined;
					keyedLen--;
				}
			} else if (min < childrenLen) {
					for (j = min; j < childrenLen; j++) {
						if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
							child = c;
							children[j] = undefined;
							if (j === childrenLen - 1) childrenLen--;
							if (j === min) min++;
							break;
						}
					}
				}

			child = idiff(child, vchild, context, mountAll);

			f = originalChildren[i];
			if (child && child !== dom && child !== f) {
				if (f == null) {
					dom.appendChild(child);
				} else if (child === f.nextSibling) {
					removeNode(f);
				} else {
					dom.insertBefore(child, f);
				}
			}
		}
	}

	if (keyedLen) {
		for (var i in keyed) {
			if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
		}
	}

	while (min <= childrenLen) {
		if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
	}
}

function recollectNodeTree(node, unmountOnly) {
	var component = node._component;
	if (component) {
		unmountComponent(component);
	} else {
		if (node['__preactattr_'] != null) applyRef(node['__preactattr_'].ref, null);

		if (unmountOnly === false || node['__preactattr_'] == null) {
			removeNode(node);
		}

		removeChildren(node);
	}
}

function removeChildren(node) {
	node = node.lastChild;
	while (node) {
		var next = node.previousSibling;
		recollectNodeTree(node, true);
		node = next;
	}
}

function diffAttributes(dom, attrs, old) {
	var name;

	for (name in old) {
		if (!(attrs && attrs[name] != null) && old[name] != null) {
			setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
		}
	}

	for (name in attrs) {
		if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
			setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
		}
	}
}

var recyclerComponents = [];

function createComponent(Ctor, props, context) {
	var inst,
	    i = recyclerComponents.length;

	if (Ctor.prototype && Ctor.prototype.render) {
		inst = new Ctor(props, context);
		Component.call(inst, props, context);
	} else {
		inst = new Component(props, context);
		inst.constructor = Ctor;
		inst.render = doRender;
	}

	while (i--) {
		if (recyclerComponents[i].constructor === Ctor) {
			inst.nextBase = recyclerComponents[i].nextBase;
			recyclerComponents.splice(i, 1);
			return inst;
		}
	}

	return inst;
}

function doRender(props, state, context) {
	return this.constructor(props, context);
}

function setComponentProps(component, props, renderMode, context, mountAll) {
	if (component._disable) return;
	component._disable = true;

	component.__ref = props.ref;
	component.__key = props.key;
	delete props.ref;
	delete props.key;

	if (typeof component.constructor.getDerivedStateFromProps === 'undefined') {
		if (!component.base || mountAll) {
			if (component.componentWillMount) component.componentWillMount();
		} else if (component.componentWillReceiveProps) {
			component.componentWillReceiveProps(props, context);
		}
	}

	if (context && context !== component.context) {
		if (!component.prevContext) component.prevContext = component.context;
		component.context = context;
	}

	if (!component.prevProps) component.prevProps = component.props;
	component.props = props;

	component._disable = false;

	if (renderMode !== 0) {
		if (renderMode === 1 || options.syncComponentUpdates !== false || !component.base) {
			renderComponent(component, 1, mountAll);
		} else {
			enqueueRender(component);
		}
	}

	applyRef(component.__ref, component);
}

function renderComponent(component, renderMode, mountAll, isChild) {
	if (component._disable) return;

	var props = component.props,
	    state = component.state,
	    context = component.context,
	    previousProps = component.prevProps || props,
	    previousState = component.prevState || state,
	    previousContext = component.prevContext || context,
	    isUpdate = component.base,
	    nextBase = component.nextBase,
	    initialBase = isUpdate || nextBase,
	    initialChildComponent = component._component,
	    skip = false,
	    snapshot = previousContext,
	    rendered,
	    inst,
	    cbase;

	if (component.constructor.getDerivedStateFromProps) {
		state = extend(extend({}, state), component.constructor.getDerivedStateFromProps(props, state));
		component.state = state;
	}

	if (isUpdate) {
		component.props = previousProps;
		component.state = previousState;
		component.context = previousContext;
		if (renderMode !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
			skip = true;
		} else if (component.componentWillUpdate) {
			component.componentWillUpdate(props, state, context);
		}
		component.props = props;
		component.state = state;
		component.context = context;
	}

	component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
	component._dirty = false;

	if (!skip) {
		rendered = component.render(props, state, context);

		if (component.getChildContext) {
			context = extend(extend({}, context), component.getChildContext());
		}

		if (isUpdate && component.getSnapshotBeforeUpdate) {
			snapshot = component.getSnapshotBeforeUpdate(previousProps, previousState);
		}

		var childComponent = rendered && rendered.nodeName,
		    toUnmount,
		    base;

		if (typeof childComponent === 'function') {

			var childProps = getNodeProps(rendered);
			inst = initialChildComponent;

			if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
				setComponentProps(inst, childProps, 1, context, false);
			} else {
				toUnmount = inst;

				component._component = inst = createComponent(childComponent, childProps, context);
				inst.nextBase = inst.nextBase || nextBase;
				inst._parentComponent = component;
				setComponentProps(inst, childProps, 0, context, false);
				renderComponent(inst, 1, mountAll, true);
			}

			base = inst.base;
		} else {
			cbase = initialBase;

			toUnmount = initialChildComponent;
			if (toUnmount) {
				cbase = component._component = null;
			}

			if (initialBase || renderMode === 1) {
				if (cbase) cbase._component = null;
				base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
			}
		}

		if (initialBase && base !== initialBase && inst !== initialChildComponent) {
			var baseParent = initialBase.parentNode;
			if (baseParent && base !== baseParent) {
				baseParent.replaceChild(base, initialBase);

				if (!toUnmount) {
					initialBase._component = null;
					recollectNodeTree(initialBase, false);
				}
			}
		}

		if (toUnmount) {
			unmountComponent(toUnmount);
		}

		component.base = base;
		if (base && !isChild) {
			var componentRef = component,
			    t = component;
			while (t = t._parentComponent) {
				(componentRef = t).base = base;
			}
			base._component = componentRef;
			base._componentConstructor = componentRef.constructor;
		}
	}

	if (!isUpdate || mountAll) {
		mounts.push(component);
	} else if (!skip) {

		if (component.componentDidUpdate) {
			component.componentDidUpdate(previousProps, previousState, snapshot);
		}
		if (options.afterUpdate) options.afterUpdate(component);
	}

	while (component._renderCallbacks.length) {
		component._renderCallbacks.pop().call(component);
	}if (!diffLevel && !isChild) flushMounts();
}

function buildComponentFromVNode(dom, vnode, context, mountAll) {
	var c = dom && dom._component,
	    originalComponent = c,
	    oldDom = dom,
	    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
	    isOwner = isDirectOwner,
	    props = getNodeProps(vnode);
	while (c && !isOwner && (c = c._parentComponent)) {
		isOwner = c.constructor === vnode.nodeName;
	}

	if (c && isOwner && (!mountAll || c._component)) {
		setComponentProps(c, props, 3, context, mountAll);
		dom = c.base;
	} else {
		if (originalComponent && !isDirectOwner) {
			unmountComponent(originalComponent);
			dom = oldDom = null;
		}

		c = createComponent(vnode.nodeName, props, context);
		if (dom && !c.nextBase) {
			c.nextBase = dom;

			oldDom = null;
		}
		setComponentProps(c, props, 1, context, mountAll);
		dom = c.base;

		if (oldDom && dom !== oldDom) {
			oldDom._component = null;
			recollectNodeTree(oldDom, false);
		}
	}

	return dom;
}

function unmountComponent(component) {
	if (options.beforeUnmount) options.beforeUnmount(component);

	var base = component.base;

	component._disable = true;

	if (component.componentWillUnmount) component.componentWillUnmount();

	component.base = null;

	var inner = component._component;
	if (inner) {
		unmountComponent(inner);
	} else if (base) {
		if (base['__preactattr_'] != null) applyRef(base['__preactattr_'].ref, null);

		component.nextBase = base;

		removeNode(base);
		recyclerComponents.push(component);

		removeChildren(base);
	}

	applyRef(component.__ref, null);
}

function Component(props, context) {
	this._dirty = true;

	this.context = context;

	this.props = props;

	this.state = this.state || {};

	this._renderCallbacks = [];
}

extend(Component.prototype, {
	setState: function setState(state, callback) {
		if (!this.prevState) this.prevState = this.state;
		this.state = extend(extend({}, this.state), typeof state === 'function' ? state(this.state, this.props) : state);
		if (callback) this._renderCallbacks.push(callback);
		enqueueRender(this);
	},
	forceUpdate: function forceUpdate(callback) {
		if (callback) this._renderCallbacks.push(callback);
		renderComponent(this, 2);
	},
	render: function render() {}
});

function render(vnode, parent, merge) {
  return diff(merge, vnode, {}, false, parent, false);
}

function createRef() {
	return {};
}

var preact = {
	h: h,
	createElement: h,
	cloneElement: cloneElement,
	createRef: createRef,
	Component: Component,
	render: render,
	rerender: rerender,
	options: options
};

/* harmony default export */ __webpack_exports__["default"] = (preact);

//# sourceMappingURL=preact.mjs.map


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "formatDefaultLocale", function() { return /* reexport */ defaultLocale; });
__webpack_require__.d(__webpack_exports__, "format", function() { return /* reexport */ defaultLocale_format; });
__webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return /* reexport */ defaultLocale_formatPrefix; });
__webpack_require__.d(__webpack_exports__, "formatLocale", function() { return /* reexport */ src_locale; });
__webpack_require__.d(__webpack_exports__, "formatSpecifier", function() { return /* reexport */ formatSpecifier; });
__webpack_require__.d(__webpack_exports__, "precisionFixed", function() { return /* reexport */ precisionFixed; });
__webpack_require__.d(__webpack_exports__, "precisionPrefix", function() { return /* reexport */ precisionPrefix; });
__webpack_require__.d(__webpack_exports__, "precisionRound", function() { return /* reexport */ precisionRound; });

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatDecimal.js
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
/* harmony default export */ var formatDecimal = (function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/exponent.js


/* harmony default export */ var src_exponent = (function(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatGroup.js
/* harmony default export */ var formatGroup = (function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatNumerals.js
/* harmony default export */ var formatNumerals = (function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatDefault.js
/* harmony default export */ var formatDefault = (function(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      case "e": break out;
      default: if (i0 > 0) i0 = 0; break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatPrefixAuto.js


var prefixExponent;

/* harmony default export */ var formatPrefixAuto = (function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatRounded.js


/* harmony default export */ var formatRounded = (function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatTypes.js




/* harmony default export */ var formatTypes = ({
  "": formatDefault,
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatSpecifier.js


// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!formatTypes[type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + this.type;
};

// CONCATENATED MODULE: ./node_modules/d3-format/src/identity.js
/* harmony default export */ var identity = (function(x) {
  return x;
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/locale.js








var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ var src_locale = (function(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? (type ? 6 : 12)
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(src_exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/defaultLocale.js


var defaultLocale_locale;
var defaultLocale_format;
var defaultLocale_formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  defaultLocale_locale = src_locale(definition);
  defaultLocale_format = defaultLocale_locale.format;
  defaultLocale_formatPrefix = defaultLocale_locale.formatPrefix;
  return defaultLocale_locale;
}

// CONCATENATED MODULE: ./node_modules/d3-format/src/precisionFixed.js


/* harmony default export */ var precisionFixed = (function(step) {
  return Math.max(0, -src_exponent(Math.abs(step)));
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/precisionPrefix.js


/* harmony default export */ var precisionPrefix = (function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(src_exponent(value) / 3))) * 3 - src_exponent(Math.abs(step)));
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/precisionRound.js


/* harmony default export */ var precisionRound = (function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, src_exponent(max) - src_exponent(step)) + 1;
});

// CONCATENATED MODULE: ./node_modules/d3-format/index.js








/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return nopropagation; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);


function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__[/* event */ "c"].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__[/* event */ "c"].preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__[/* event */ "c"].stopImmediatePropagation();
});


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return customEvent; });
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["b"] = (function(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
});

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ src_dispatch; });

// CONCATENATED MODULE: ./node_modules/d3-dispatch/src/dispatch.js
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ var src_dispatch = (dispatch);

// CONCATENATED MODULE: ./node_modules/d3-dispatch/index.js



/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ root; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Selection; });

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selector.js
var selector = __webpack_require__(24);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/select.js



/* harmony default export */ var selection_select = (function(select) {
  if (typeof select !== "function") select = Object(selector["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selectorAll.js
var selectorAll = __webpack_require__(32);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/selectAll.js



/* harmony default export */ var selectAll = (function(select) {
  if (typeof select !== "function") select = Object(selectorAll["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/matcher.js
var matcher = __webpack_require__(33);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/filter.js



/* harmony default export */ var filter = (function(match) {
  if (typeof match !== "function") match = Object(matcher["a" /* default */])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/sparse.js
/* harmony default export */ var sparse = (function(update) {
  return new Array(update.length);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/enter.js



/* harmony default export */ var selection_enter = (function() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

// CONCATENATED MODULE: ./node_modules/d3-selection/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/data.js




var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ var selection_data = (function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/exit.js



/* harmony default export */ var selection_exit = (function() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/join.js
/* harmony default export */ var join = (function(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/merge.js


/* harmony default export */ var selection_merge = (function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/order.js
/* harmony default export */ var order = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/sort.js


/* harmony default export */ var sort = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/call.js
/* harmony default export */ var call = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/nodes.js
/* harmony default export */ var nodes = (function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/node.js
/* harmony default export */ var selection_node = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/size.js
/* harmony default export */ var size = (function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/empty.js
/* harmony default export */ var empty = (function() {
  return !this.node();
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/each.js
/* harmony default export */ var each = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespace.js
var namespace = __webpack_require__(25);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/attr.js


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ var attr = (function(name, value) {
  var fullname = Object(namespace["a" /* default */])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/style.js
var style = __webpack_require__(34);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ var property = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ var classed = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ var selection_text = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ var html = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ var selection_raise = (function() {
  return this.each(raise);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ var selection_lower = (function() {
  return this.each(lower);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/creator.js
var creator = __webpack_require__(16);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/append.js


/* harmony default export */ var append = (function(name) {
  var create = typeof name === "function" ? name : Object(creator["a" /* default */])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/insert.js



function constantNull() {
  return null;
}

/* harmony default export */ var insert = (function(name, before) {
  var create = typeof name === "function" ? name : Object(creator["a" /* default */])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(selector["a" /* default */])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ var selection_remove = (function() {
  return this.each(remove);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ var clone = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/datum.js
/* harmony default export */ var datum = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/on.js
var on = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/window.js
var src_window = __webpack_require__(26);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/dispatch.js


function dispatchEvent(node, type, params) {
  var window = Object(src_window["a" /* default */])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ var dispatch = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/index.js
































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection_selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection_selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selectAll,
  filter: filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: join,
  merge: selection_merge,
  order: order,
  sort: sort,
  call: call,
  nodes: nodes,
  node: selection_node,
  size: size,
  empty: empty,
  each: each,
  attr: attr,
  style: style["a" /* default */],
  property: property,
  classed: classed,
  text: selection_text,
  html: html,
  raise: selection_raise,
  lower: selection_lower,
  append: append,
  insert: insert,
  remove: selection_remove,
  clone: clone,
  datum: datum,
  on: on["b" /* default */],
  dispatch: dispatch
};

/* harmony default export */ var src_selection = __webpack_exports__["b"] = (selection_selection);


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(75);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return csvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return csvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return csvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return csvFormatBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return csvFormatRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return csvFormatRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return csvFormatValue; });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);


var csv = Object(_dsv_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return tsvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return tsvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return tsvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return tsvFormatBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return tsvFormatRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return tsvFormatRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return tsvFormatValue; });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);


var tsv = Object(_dsv_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces__WEBPACK_IMPORTED_MODULE_1__[/* xhtml */ "b"] && document.documentElement.namespaceURI === _namespaces__WEBPACK_IMPORTED_MODULE_1__[/* xhtml */ "b"]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var fullname = Object(_namespace__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["a"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ interrupt; });

// UNUSED EXPORTS: transition, active

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/index.js + 31 modules
var selection = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/d3-dispatch/index.js + 1 modules
var d3_dispatch = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/d3-timer/src/timer.js
var timer_frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++timer_frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --timer_frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  timer_frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    timer_frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (timer_frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    timer_frame = 1, setFrame(wake);
  }
}

// CONCATENATED MODULE: ./node_modules/d3-timer/src/timeout.js


/* harmony default export */ var src_timeout = (function(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/schedule.js



var emptyOn = Object(d3_dispatch["a" /* dispatch */])("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ var transition_schedule = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTING) throw new Error("too late; already started");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return src_timeout(start);

      // Interrupt the active transition, if any.
      // Dispatch the interrupt event.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    src_timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

// CONCATENATED MODULE: ./node_modules/d3-transition/src/interrupt.js


/* harmony default export */ var interrupt = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/interrupt.js


/* harmony default export */ var selection_interrupt = (function(name) {
  return this.each(function() {
    interrupt(this, name);
  });
});

// EXTERNAL MODULE: ./node_modules/d3-interpolate/index.js + 21 modules
var d3_interpolate = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespace.js
var namespace = __webpack_require__(25);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/tween.js


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ var transition_tween = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

// EXTERNAL MODULE: ./node_modules/d3-color/index.js + 5 modules
var d3_color = __webpack_require__(1);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/interpolate.js



/* harmony default export */ var transition_interpolate = (function(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate["c" /* interpolateNumber */]
      : b instanceof d3_color["a" /* color */] ? d3_interpolate["d" /* interpolateRgb */]
      : (c = Object(d3_color["a" /* color */])(b)) ? (b = c, d3_interpolate["d" /* interpolateRgb */])
      : d3_interpolate["f" /* interpolateString */])(a, b);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/attr.js





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

/* harmony default export */ var attr = (function(name, value) {
  var fullname = Object(namespace["a" /* default */])(name), i = fullname === "transform" ? d3_interpolate["h" /* interpolateTransformSvg */] : transition_interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/attrTween.js


function attrTweenNS(fullname, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttribute(name, i(t));
    };
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ var transition_attrTween = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(namespace["a" /* default */])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/delay.js


function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

/* harmony default export */ var transition_delay = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/duration.js


function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

/* harmony default export */ var duration = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/ease.js


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

/* harmony default export */ var ease = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/matcher.js
var matcher = __webpack_require__(33);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/filter.js



/* harmony default export */ var filter = (function(match) {
  if (typeof match !== "function") match = Object(matcher["a" /* default */])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/merge.js


/* harmony default export */ var transition_merge = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/on.js


function on_start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = on_start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ var on = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/remove.js
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ var remove = (function() {
  return this.on("end.remove", removeFunction(this._id));
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selector.js
var selector = __webpack_require__(24);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/select.js




/* harmony default export */ var transition_select = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(selector["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        transition_schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selectorAll.js
var selectorAll = __webpack_require__(32);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/selectAll.js




/* harmony default export */ var selectAll = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(selectorAll["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            transition_schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/selection.js


var Selection = selection["b" /* default */].prototype.constructor;

/* harmony default export */ var transition_selection = (function() {
  return new Selection(this._groups, this._parents);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/style.js
var style = __webpack_require__(34);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/style.js





function styleRemove(name, interpolate) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = Object(style["b" /* styleValue */])(this, name),
        value1 = (this.style.removeProperty(name), Object(style["b" /* styleValue */])(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = Object(style["b" /* styleValue */])(this, name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = Object(style["b" /* styleValue */])(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), Object(style["b" /* styleValue */])(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

/* harmony default export */ var transition_style = (function(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate["g" /* interpolateTransformCss */] : transition_interpolate;
  return value == null ? this
          .styleTween(name, styleRemove(name, i))
          .on("end.style." + name, styleRemoveEnd(name))
      : this.styleTween(name, typeof value === "function"
          ? styleFunction(name, i, tweenValue(this, "style." + name, value))
          : styleConstant(name, i, value + ""), priority);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/styleTween.js
function styleTween(name, value, priority) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.style.setProperty(name, i(t), priority);
    };
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ var transition_styleTween = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/text.js


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ var transition_text = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/transition.js



/* harmony default export */ var transition_transition = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        transition_schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/index.js



















var transition_id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function src_transition_transition(name) {
  return Object(selection["b" /* default */])().transition(name);
}

function newId() {
  return ++transition_id;
}

var selection_prototype = selection["b" /* default */].prototype;

Transition.prototype = src_transition_transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: selectAll,
  filter: filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on,
  attr: attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  remove: remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: duration,
  ease: ease
};

// CONCATENATED MODULE: ./node_modules/d3-ease/src/linear.js
function linear(t) {
  return +t;
}

// CONCATENATED MODULE: ./node_modules/d3-ease/src/quad.js
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

// CONCATENATED MODULE: ./node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// CONCATENATED MODULE: ./node_modules/d3-ease/src/poly.js
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

// CONCATENATED MODULE: ./node_modules/d3-ease/src/sin.js
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

// CONCATENATED MODULE: ./node_modules/d3-ease/src/exp.js
function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

// CONCATENATED MODULE: ./node_modules/d3-ease/src/circle.js
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

// CONCATENATED MODULE: ./node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

// CONCATENATED MODULE: ./node_modules/d3-ease/src/back.js
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

// CONCATENATED MODULE: ./node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

// CONCATENATED MODULE: ./node_modules/d3-ease/index.js




















// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/transition.js





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function transition_inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }
  return timing;
}

/* harmony default export */ var selection_transition = (function(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        transition_schedule(node, name, id, i, group, timing || transition_inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/index.js




selection["b" /* default */].prototype.interrupt = selection_interrupt;
selection["b" /* default */].prototype.transition = selection_transition;

// CONCATENATED MODULE: ./node_modules/d3-transition/src/active.js



var root = [null];

/* harmony default export */ var src_active = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/index.js






/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.importAndCheck = importAndCheck;
exports.floatForData = floatForData;
exports.reverse_flux_for_data = reverse_flux_for_data;
exports.gene_string_for_data = gene_string_for_data;
exports.text_for_data = text_for_data;
exports.csv_converter = csv_converter;
exports.genes_for_gene_reaction_rule = genes_for_gene_reaction_rule;
exports.evaluate_gene_reaction_rule = evaluate_gene_reaction_rule;
exports.replace_gene_in_rule = replace_gene_in_rule;
exports.apply_reaction_data_to_reactions = apply_reaction_data_to_reactions;
exports.apply_metabolite_data_to_nodes = apply_metabolite_data_to_nodes;
exports.apply_gene_data_to_reactions = apply_gene_data_to_reactions;

var _utils = __webpack_require__(4);

var utils = _interopRequireWildcard(_utils);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

var _d3Format = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// globals
var RETURN_ARG = function RETURN_ARG(x) {
  return x;
};
var ESCAPE_REG = /([.*+?^=!:${}()|[\]/\\])/g;
var EMPTY_LINES = /\n\s*\n/g;
var TRAILING_NEWLINE = /\n\s*(\)*)\s*$/;
var AND_OR = /([() ])(?:and|or)([)( ])/ig;
var ALL_PARENS = /[()]/g;
// capture an expression surrounded by whitespace and a set of parentheses
var EXCESS_PARENS = /\(\s*(\S+)\s*\)/g;
var OR = /\s+or\s+/i;
var AND = /\s+and\s+/i;
// find ORs
var OR_EXPRESSION = /(^|\()(\s*-?[0-9.]+\s+(?:or\s+-?[0-9.]+\s*)+)(\)|$)/ig;
// find ANDS, respecting order of operations (and before or)
var AND_EXPRESSION = /(^|\(|or\s)(\s*-?[0-9.]+\s+(?:and\s+-?[0-9.]+\s*)+)(\sor|\)|$)/ig;

function parseFloatOrNull(x) {
  // strict number casting
  var f = Number(x);
  // check for null and '', which haven't been caught yet
  return isNaN(f) || parseFloat(x) !== f ? null : f;
}

function alignGeneDataToReactions(data, reactions) {
  var aligned = {};
  var nullVal = [null];
  // make an array of nulls as the default
  for (var firstGeneId in data) {
    nullVal = data[firstGeneId].map(function () {
      return null;
    });
    break;
  }

  var _loop = function _loop(reactionId) {
    var reaction = reactions[reactionId];
    var biggId = reaction.bigg_id;
    var thisGeneData = {};

    reaction.genes.forEach(function (gene) {
      // check both gene id and gene name
      ;['bigg_id', 'name'].forEach(function (kind) {
        var d = data[gene[kind]] || utils.clone(nullVal);
        // merger with existing data if present
        var existingD = thisGeneData[gene.bigg_id];
        if (existingD === undefined) {
          thisGeneData[gene.bigg_id] = d;
        } else {
          for (var i = 0; i < d.length; i++) {
            var pnt = d[i];
            if (pnt !== null) {
              existingD[i] = pnt;
            }
          }
        }
      });
    });
    aligned[biggId] = thisGeneData;
  };

  for (var reactionId in reactions) {
    _loop(reactionId);
  }
  return aligned;
}

function checkFinite(x) {
  return isFinite(x) ? x : null;
}

function abs(x, takeAbs) {
  return takeAbs ? Math.abs(x) : x;
}

function diff(x, y, takeAbs) {
  if (takeAbs) return Math.abs(y - x);else return y - x;
}

function fold(x, y, takeAbs) {
  if (x === 0 || y === 0) return null;
  var fold = y >= x ? y / x : -x / y;
  return takeAbs ? Math.abs(fold) : fold;
}

function log2Fold(x, y, takeAbs) {
  if (x === 0) return null;
  if (y / x < 0) return null;
  var log = Math.log(y / x) / Math.log(2);
  return takeAbs ? Math.abs(log) : log;
}

/**
 * Convert imported data to a style that can be applied to reactions and nodes.
 * @param data - The data object.
 * @param name - Either 'reaction_data', 'metabolite_data', or 'gene_data'
 * @param allReactions - Required for name == 'gene_data'. Must include all GPRs
 *                       for the map and model.
 */
function importAndCheck(data, name, allReactions) {
  // check arguments
  if (!data) return null;

  if (['reaction_data', 'metabolite_data', 'gene_data'].indexOf(name) === -1) {
    throw new Error('Invalid name argument: ' + name);
  }

  // make array
  if (!(data instanceof Array)) {
    data = [data];
  }
  // check data
  var check = function check() {
    if (data === null) {
      return null;
    }
    if (data.length === 1) {
      return null;
    }
    if (data.length === 2) {
      return null;
    }
    return console.warn('Bad data style: ' + name);
  };
  check();
  data = utils.arrayToObject(data);

  if (name === 'gene_data') {
    if (allReactions === undefined) {
      throw new Error('Must pass all_reactions argument for gene_data');
    }
    data = alignGeneDataToReactions(data, allReactions);
  }

  return data;
}

function floatForData(d, styles, compareStyle) {
  // all null
  if (d === null) return null;

  // absolute value
  var takeAbs = styles.indexOf('abs') !== -1;

  if (d.length === 1) {
    // 1 set
    // 1 null
    var f = parseFloatOrNull(d[0]);
    if (f === null) return null;
    return abs(f, takeAbs);
  } else if (d.length === 2) {
    // 2 sets
    // 2 null
    var fs = d.map(parseFloatOrNull);
    if (fs[0] === null || fs[1] === null) return null;

    if (compareStyle === 'diff') {
      return diff(fs[0], fs[1], takeAbs);
    } else if (compareStyle === 'fold') {
      return checkFinite(fold(fs[0], fs[1], takeAbs));
    } else if (compareStyle === 'log2_fold') {
      return checkFinite(log2Fold(fs[0], fs[1], takeAbs));
    }
  } else {
    throw new Error('Data array must be of length 1 or 2');
  }
  throw new Error('Bad data compare_style: ' + compareStyle);
}

function reverse_flux_for_data(d) {
  if (d === null || d[0] === null) {
    return false;
  }
  return d[0] < 0;
}

/**
 * Add gene values to the gene_reaction_rule string.
 * @param {String} rule - The gene reaction rule.
 * @param {} gene_values - The values.
 * @param {} genes - An array of objects specifying the gene bigg_id and name.
 * @param {} styles - The reaction styles.
 * @param {String} identifiers_on_map - The type of identifiers ('bigg_id' or 'name').
 * @param {} compare_style - The comparison style.
 *
 * @return {Array} A list of objects with:
 *
 * {
 *    bigg_id: The bigg ID.
 *    name: The name.
 *    text: The new string with formatted data values.
 * }
 *
 * The text elements should each appear on a new line.
 */
function gene_string_for_data(rule, gene_values, genes, styles, identifiers_on_map, compare_style) {
  var out_text = rule;
  var no_data = gene_values === null;
  // keep track of bigg_ids to remove repeats
  var genes_found = {};

  genes.forEach(function (g_obj) {
    var bigg_id = g_obj.bigg_id;

    // ignore repeats that may have found their way into the genes object
    if (bigg_id in genes_found) return;
    genes_found[bigg_id] = true;

    // generate the string
    if (no_data) {
      out_text = replace_gene_in_rule(out_text, bigg_id, bigg_id + '\n');
    } else {
      if (!(bigg_id in gene_values)) return;
      var d = gene_values[bigg_id];
      var f = floatForData(d, styles, compare_style);
      var format = f === null ? RETURN_ARG : (0, _d3Format.format)('.3g');
      if (d.length === 1) {
        out_text = replace_gene_in_rule(out_text, bigg_id, bigg_id + ' (' + null_or_d(d[0], format) + ')\n');
      } else if (d.length === 2) {
        var new_str;
        // check if they are all text
        var any_num = _underscore2.default.any(d, function (x) {
          return parseFloatOrNull(x) !== null;
        });
        if (any_num) {
          new_str = bigg_id + ' (' + null_or_d(d[0], format) + ', ' + null_or_d(d[1], format) + ': ' + null_or_d(f, format) + ')\n';
        } else {
          new_str = bigg_id + ' (' + null_or_d(d[0], format) + ', ' + null_or_d(d[1], format) + ')\n';
        }
        out_text = replace_gene_in_rule(out_text, bigg_id, new_str);
      }
    }
  });
  out_text = out_text
  // remove empty lines
  .replace(EMPTY_LINES, '\n')
  // remove trailing newline (with or without parens)
  .replace(TRAILING_NEWLINE, '$1');

  // split by newlines, and switch to names if necessary
  var result = out_text.split('\n').map(function (text) {
    for (var i = 0, l = genes.length; i < l; i++) {
      var gene = genes[i];
      if (text.indexOf(gene.bigg_id) !== -1) {
        // replace with names
        if (identifiers_on_map === 'name') text = replace_gene_in_rule(text, gene.bigg_id, gene.name);
        return { bigg_id: gene.bigg_id, name: gene.name, text: text };
      }
    }
    // not found, then none
    return { bigg_id: null, name: null, text: text };
  });
  return result;

  // definitions
  function null_or_d(d, format) {
    return d === null ? 'nd' : format(d);
  }
}

function text_for_data(d, f) {
  if (d === null) {
    return null_or_d(null);
  }
  if (d.length === 1) {
    var format = f === null ? RETURN_ARG : (0, _d3Format.format)('.3g');
    return null_or_d(d[0], format);
  }
  if (d.length === 2) {
    var format = f === null ? RETURN_ARG : (0, _d3Format.format)('.3g'),
        t = null_or_d(d[0], format);
    t += ', ' + null_or_d(d[1], format);
    t += ': ' + null_or_d(f, format);
    return t;
  }
  return '';

  // definitions
  function null_or_d(d, format) {
    return d === null ? '(nd)' : format(d);
  }
}

function csv_converter(csv_rows) {
  /** Convert data from a csv file to json-style data.
       File must include a header row.
   */
  // count rows
  var c = csv_rows[0].length,
      converted = [];
  if (c < 2 || c > 3) throw new Error('CSV file must have 2 or 3 columns');
  // set up rows
  for (var i = 1; i < c; i++) {
    converted[i - 1] = {};
  }
  // fill
  csv_rows.slice(1).forEach(function (row) {
    for (var i = 1, l = row.length; i < l; i++) {
      converted[i - 1][row[0]] = row[i];
    }
  });
  return converted;
}

function genes_for_gene_reaction_rule(rule) {
  /** Find unique genes in gene_reaction_rule string.
       Arguments
      ---------
       rule: A boolean string containing gene names, parentheses, AND's and
      OR's.
       Returns
      -------
       An array of gene strings.
   */
  var genes = rule
  // remove ANDs and ORs, surrounded by space or parentheses
  .replace(AND_OR, '$1$2')
  // remove parentheses
  .replace(ALL_PARENS, '')
  // split on whitespace
  .split(' ').filter(function (x) {
    return x != '';
  });
  // unique strings
  return utils.unique_strings_array(genes);
}

function evaluate_gene_reaction_rule(rule, gene_values, and_method_in_gene_reaction_rule) {
  /** Return a value given the rule and gene_values object.
       Arguments
      ---------
       rule: A boolean string containing gene names, parentheses, AND's and
      OR's.
       gene_values: Object with gene_ids for keys and numbers for values.
       and_method_in_gene_reaction_rule: Either 'mean' or 'min'.
   */

  var null_val = [null],
      l = 1;
  // make an array of nulls as the default
  for (var gene_id in gene_values) {
    null_val = gene_values[gene_id].map(function () {
      return null;
    });
    l = null_val.length;
    break;
  }

  if (rule == '') return utils.clone(null_val);

  // for each element in the arrays
  var out = [];
  for (var i = 0; i < l; i++) {
    // get the rule
    var curr_val = rule;

    // put all the numbers into the expression
    var all_null = true;
    for (var gene_id in gene_values) {
      var f = parseFloatOrNull(gene_values[gene_id][i]);
      if (f === null) {
        f = 0;
      } else {
        all_null = false;
      }
      curr_val = replace_gene_in_rule(curr_val, gene_id, f);
    }
    if (all_null) {
      out.push(null);
      continue;
    }

    // recursively evaluate
    while (true) {
      // arithemtic expressions
      var new_curr_val = curr_val;

      // take out excessive parentheses
      new_curr_val = new_curr_val.replace(EXCESS_PARENS, ' $1 ');

      // or's
      new_curr_val = new_curr_val.replace(OR_EXPRESSION, function (match, p1, p2, p3) {
        // sum
        var nums = p2.split(OR).map(parseFloat),
            sum = nums.reduce(function (a, b) {
          return a + b;
        });
        return p1 + sum + p3;
      });
      // and's
      new_curr_val = new_curr_val.replace(AND_EXPRESSION, function (match, p1, p2, p3) {
        // find min
        var nums = p2.split(AND).map(parseFloat),
            val = and_method_in_gene_reaction_rule == 'min' ? Math.min.apply(null, nums) : nums.reduce(function (a, b) {
          return a + b;
        }) / nums.length;
        return p1 + val + p3;
      });
      // break if there is no change
      if (new_curr_val == curr_val) break;
      curr_val = new_curr_val;
    }
    // strict test for number
    var num = Number(curr_val);
    if (isNaN(num)) {
      console.warn('Could not evaluate ' + rule);
      out.push(null);
    } else {
      out.push(num);
    }
  }
  return out;
}

function replace_gene_in_rule(rule, gene_id, val) {
  // get the escaped string, with surrounding space or parentheses
  var space_or_par_start = '(^|[\\\s\\\(\\\)])';
  var space_or_par_finish = '([\\\s\\\(\\\)]|$)';
  var escaped = space_or_par_start + escape_reg_exp(gene_id) + space_or_par_finish;
  return rule.replace(new RegExp(escaped, 'g'), '$1' + val + '$2');

  // definitions
  function escape_reg_exp(string) {
    return string.replace(ESCAPE_REG, "\\$1");
  }
}

/**
 * Returns True if the scale has changed.
 * @param {Object} reactions -
 * @param {} data -
 * @param {} styles -
 * @param {String} compare_style -
 * @param {Array} keys - (Optional) The keys in reactions to apply data to.
 */
function apply_reaction_data_to_reactions(reactions, data, styles, compare_style, keys) {
  if (_underscore2.default.isUndefined(keys)) keys = Object.keys(reactions);

  var reaction_id;
  var reaction;
  var segment_id;
  var segment;

  if (data === null) {
    keys.map(function (reaction_id) {
      reaction = reactions[reaction_id];
      reaction.data = null;
      reaction.data_string = '';
      for (segment_id in reaction.segments) {
        segment = reaction.segments[segment_id];
        segment.data = null;
      }
      reaction.gene_string = null;
    });
    return false;
  }

  // apply the datasets to the reactions
  keys.map(function (reaction_id) {
    reaction = reactions[reaction_id];
    // check bigg_id and name
    var d = data[reaction.bigg_id] || data[reaction.name] || null;
    var f = floatForData(d, styles, compare_style);
    var r = reverse_flux_for_data(d);
    var s = text_for_data(d, f);
    reaction.data = f;
    reaction.data_string = s;
    reaction.reverse_flux = r;
    reaction.gene_string = null;
    // apply to the segments
    for (segment_id in reaction.segments) {
      segment = reaction.segments[segment_id];
      segment.data = reaction.data;
      segment.reverse_flux = reaction.reverse_flux;
    }
  });
  return true;
}

/**
 * Returns True if the scale has changed.
 * @param {Object} nodes -
 * @param {} data -
 * @param {} styles -
 * @param {String} compare_style -
 * @param {Array} keys - (Optional) The keys in nodes to apply data to.
 */
function apply_metabolite_data_to_nodes(nodes, data, styles, compareStyle, keys) {
  if (_underscore2.default.isUndefined(keys)) keys = Object.keys(nodes);

  if (data === null) {
    keys.map(function (nodeId) {
      nodes[nodeId].data = null;
      nodes[nodeId].data_string = '';
    });
    return false;
  }

  // grab the data
  keys.map(function (nodeId) {
    var node = nodes[nodeId];
    // check bigg_id and name
    var d = data[node.bigg_id] || data[node.name] || null;
    var f = floatForData(d, styles, compareStyle);
    var s = text_for_data(d, f);
    node.data = f;
    node.data_string = s;
  });
  return true;
}

/**
 * Returns true if data is present
 * reactions: The reactions to update.
 * gene_data_obj: The gene data object, with the following style:
 *   { reaction_id: { gene_id: value } }
 * styles:  Gene styles array.
 * identifiers_on_map:
 * compare_style:
 * and_method_in_gene_reaction_rule:
 * @param {Array} keys - (Optional) The keys in reactions to apply data to.
 */
function apply_gene_data_to_reactions(reactions, gene_data_obj, styles, identifiers_on_map, compare_style, and_method_in_gene_reaction_rule, keys) {
  if (_underscore2.default.isUndefined(keys)) keys = Object.keys(reactions);

  if (gene_data_obj === null) {
    keys.map(function (reaction_id) {
      var reaction = reactions[reaction_id];
      reaction.data = null;
      reaction.data_string = '';
      reaction.reverse_flux = false;
      for (var segment_id in reaction.segments) {
        var segment = reaction.segments[segment_id];
        segment.data = null;
      }
      reaction.gene_string = null;
    });
    return false;
  }

  // Get the null val
  var null_val = [null];
  // Make an array of nulls as the default
  for (var reaction_id in gene_data_obj) {
    for (var gene_id in gene_data_obj[reaction_id]) {
      null_val = gene_data_obj[reaction_id][gene_id].map(function () {
        return null;
      });
      break;
    }
    break;
  }

  // Apply the datasets to the reactions
  keys.map(function (reaction_id) {
    var reaction = reactions[reaction_id];
    var rule = reaction.gene_reaction_rule;
    // find the data
    var d, gene_values;
    var r_data = gene_data_obj[reaction.bigg_id];
    if (!_underscore2.default.isUndefined(r_data)) {
      gene_values = r_data;
      d = evaluate_gene_reaction_rule(rule, gene_values, and_method_in_gene_reaction_rule);
    } else {
      gene_values = {};
      d = utils.clone(null_val);
    }
    var f = floatForData(d, styles, compare_style);
    var r = reverse_flux_for_data(d);
    var s = text_for_data(d, f);
    reaction.data = f;
    reaction.data_string = s;
    reaction.reverse_flux = r;
    // apply to the segments
    for (var segment_id in reaction.segments) {
      var segment = reaction.segments[segment_id];
      segment.data = reaction.data;
      segment.reverse_flux = reaction.reverse_flux;
    }
    // always update the gene string
    reaction.gene_string = gene_string_for_data(rule, gene_values, reaction.genes, styles, identifiers_on_map, compare_style);
  });
  return true;
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** CallbackManager */
var CallbackManager = function () {
  function CallbackManager() {
    _classCallCheck(this, CallbackManager);
  }

  /**
   * As in d3 callbacks, you can namespace your callbacks after a period:
   * select_metabolite.direction_arrow, select_metabolite.input. Both are called
   * by select_metabolite.
  */
  CallbackManager.prototype.set = function set(name, fn) {
    if (this.callbacks === undefined) this.callbacks = {};
    if (this.callbacks[name] === undefined) this.callbacks[name] = [];
    this.callbacks[name].push(fn);
  };

  /** Remove a callback by name */


  CallbackManager.prototype.remove = function remove(name) {
    if (this.callbacks === undefined || Object.keys(this.callbacks).length === 0) {
      console.warn('No callbacks to remove');
    } else {
      delete this.callbacks[name];
    }
  };

  /**
   * Run all callbacks that match the portion of name before the period ('.').
   * @param {String} name - The callback name, which can include a tag after a
   * '.' to specificy a particular callback.
   * @param {Any} thisArg = null - The object assigned to `this` in the
   * callback.
  */


  CallbackManager.prototype.run = function run(name) {
    for (var _len = arguments.length, passArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      passArgs[_key - 2] = arguments[_key];
    }

    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (this.callbacks === undefined) return;
    // look for matching callback names
    for (var aName in this.callbacks) {
      var splitName = aName.split('.')[0];
      if (splitName === name) {
        this.callbacks[aName].forEach(function (fn) {
          fn.apply(thisArg, passArgs);
        });
      }
    }
  };

  return CallbackManager;
}();

exports.default = CallbackManager;

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "drag", function() { return /* reexport */ src_drag; });
__webpack_require__.d(__webpack_exports__, "dragDisable", function() { return /* reexport */ nodrag["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "dragEnable", function() { return /* reexport */ nodrag["b" /* yesdrag */]; });

// EXTERNAL MODULE: ./node_modules/d3-dispatch/index.js + 1 modules
var d3_dispatch = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/on.js
var on = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/mouse.js
var mouse = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/select.js
var src_select = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/touch.js
var touch = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/d3-drag/src/nodrag.js
var nodrag = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/d3-drag/src/noevent.js
var noevent = __webpack_require__(8);

// CONCATENATED MODULE: ./node_modules/d3-drag/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-drag/src/event.js
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// CONCATENATED MODULE: ./node_modules/d3-drag/src/drag.js







// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !on["c" /* event */].ctrlKey && !on["c" /* event */].button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: on["c" /* event */].x, y: on["c" /* event */].y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

/* harmony default export */ var src_drag = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(d3_dispatch["a" /* dispatch */])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), mouse["a" /* default */], this, arguments);
    if (!gesture) return;
    Object(src_select["a" /* default */])(on["c" /* event */].view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    Object(nodrag["a" /* default */])(on["c" /* event */].view);
    Object(noevent["b" /* nopropagation */])();
    mousemoving = false;
    mousedownx = on["c" /* event */].clientX;
    mousedowny = on["c" /* event */].clientY;
    gesture("start");
  }

  function mousemoved() {
    Object(noevent["a" /* default */])();
    if (!mousemoving) {
      var dx = on["c" /* event */].clientX - mousedownx, dy = on["c" /* event */].clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    Object(src_select["a" /* default */])(on["c" /* event */].view).on("mousemove.drag mouseup.drag", null);
    Object(nodrag["b" /* yesdrag */])(on["c" /* event */].view, mousemoving);
    Object(noevent["a" /* default */])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = on["c" /* event */].changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, touch["a" /* default */], this, arguments)) {
        Object(noevent["b" /* nopropagation */])();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = on["c" /* event */].changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(noevent["a" /* default */])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = on["c" /* event */].changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(noevent["b" /* nopropagation */])();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!Object(on["a" /* customEvent */])(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((on["c" /* event */].subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      Object(on["a" /* customEvent */])(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});

// CONCATENATED MODULE: ./node_modules/d3-drag/src/index.js




/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ __webpack_exports__["a"] = (function(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
});


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function none() {}

/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].hasOwnProperty(prefix) ? {space: _namespaces__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"][prefix], local: name} : name;
});


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return yesdrag; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);



/* harmony default export */ __webpack_exports__["a"] = (function(view) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);


/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__[/* Selection */ "a"]([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__[/* Selection */ "a"]([[selector]], _selection_index__WEBPACK_IMPORTED_MODULE_0__[/* root */ "c"]);
});


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  var current = _selection_on__WEBPACK_IMPORTED_MODULE_0__[/* event */ "c"], source;
  while (source = current.sourceEvent) current = source;
  return current;
});


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ src_map; });

// UNUSED EXPORTS: nest, set, keys, values, entries

// CONCATENATED MODULE: ./node_modules/d3-collection/src/map.js
var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

/* harmony default export */ var src_map = (map);

// CONCATENATED MODULE: ./node_modules/d3-collection/src/nest.js


/* harmony default export */ var src_nest = (function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = src_map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
});

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return src_map();
}

function setMap(map, key, value) {
  map.set(key, value);
}

// CONCATENATED MODULE: ./node_modules/d3-collection/src/set.js


function Set() {}

var proto = src_map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

/* harmony default export */ var src_set = (set);

// CONCATENATED MODULE: ./node_modules/d3-collection/src/keys.js
/* harmony default export */ var src_keys = (function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
});

// CONCATENATED MODULE: ./node_modules/d3-collection/src/values.js
/* harmony default export */ var src_values = (function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
});

// CONCATENATED MODULE: ./node_modules/d3-collection/src/entries.js
/* harmony default export */ var src_entries = (function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
});

// CONCATENATED MODULE: ./node_modules/d3-collection/index.js








/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "request", function() { return /* reexport */ src_request; });
__webpack_require__.d(__webpack_exports__, "html", function() { return /* reexport */ html; });
__webpack_require__.d(__webpack_exports__, "json", function() { return /* reexport */ json; });
__webpack_require__.d(__webpack_exports__, "text", function() { return /* reexport */ src_text; });
__webpack_require__.d(__webpack_exports__, "xml", function() { return /* reexport */ xml; });
__webpack_require__.d(__webpack_exports__, "csv", function() { return /* reexport */ src_csv; });
__webpack_require__.d(__webpack_exports__, "tsv", function() { return /* reexport */ src_tsv; });

// EXTERNAL MODULE: ./node_modules/d3-collection/index.js + 6 modules
var d3_collection = __webpack_require__(30);

// EXTERNAL MODULE: ./node_modules/d3-dispatch/index.js + 1 modules
var d3_dispatch = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/d3-request/src/request.js



/* harmony default export */ var src_request = (function(url, callback) {
  var request,
      event = Object(d3_dispatch["a" /* dispatch */])("beforesend", "progress", "load", "error"),
      mimeType,
      headers = Object(d3_collection["a" /* map */])(),
      xhr = new XMLHttpRequest,
      user = null,
      password = null,
      response,
      responseType,
      timeout = 0;

  // If IE does not support CORS, use XDomainRequest.
  if (typeof XDomainRequest !== "undefined"
      && !("withCredentials" in xhr)
      && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest;

  "onload" in xhr
      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond
      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };

  function respond(o) {
    var status = xhr.status, result;
    if (!status && hasResponse(xhr)
        || status >= 200 && status < 300
        || status === 304) {
      if (response) {
        try {
          result = response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }
      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function(e) {
    event.call("progress", request, e);
  };

  request = {
    header: function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);
      else headers.set(name, value + "");
      return request;
    },

    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return request;
    },

    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return request;
    },

    timeout: function(value) {
      if (!arguments.length) return timeout;
      timeout = +value;
      return request;
    },

    user: function(value) {
      return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
    },

    password: function(value) {
      return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
    },

    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function(value) {
      response = value;
      return request;
    },

    // Alias for send("GET", …).
    get: function(data, callback) {
      return request.send("GET", data, callback);
    },

    // Alias for send("POST", …).
    post: function(data, callback) {
      return request.send("POST", data, callback);
    },

    // If callback is non-null, it will be used for error and load events.
    send: function(method, data, callback) {
      xhr.open(method, url, true, user, password);
      if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });
      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
      if (responseType != null) xhr.responseType = responseType;
      if (timeout > 0) xhr.timeout = timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function(xhr) { callback(null, xhr); });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },

    abort: function() {
      xhr.abort();
      return request;
    },

    on: function() {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
});

function fixCallback(callback) {
  return function(error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text"
      ? xhr.response // null on error
      : xhr.responseText; // "" on error
}

// CONCATENATED MODULE: ./node_modules/d3-request/src/type.js


/* harmony default export */ var type = (function(defaultMimeType, response) {
  return function(url, callback) {
    var r = src_request(url).mimeType(defaultMimeType).response(response);
    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }
    return r;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-request/src/html.js


/* harmony default export */ var html = (type("text/html", function(xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
}));

// CONCATENATED MODULE: ./node_modules/d3-request/src/json.js


/* harmony default export */ var json = (type("application/json", function(xhr) {
  return JSON.parse(xhr.responseText);
}));

// CONCATENATED MODULE: ./node_modules/d3-request/src/text.js


/* harmony default export */ var src_text = (type("text/plain", function(xhr) {
  return xhr.responseText;
}));

// CONCATENATED MODULE: ./node_modules/d3-request/src/xml.js


/* harmony default export */ var xml = (type("application/xml", function(xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
}));

// EXTERNAL MODULE: ./node_modules/d3-dsv/src/csv.js
var csv = __webpack_require__(14);

// CONCATENATED MODULE: ./node_modules/d3-request/src/dsv.js


/* harmony default export */ var dsv = (function(defaultMimeType, parse) {
  return function(url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = src_request(url).mimeType(defaultMimeType);
    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };
    r.row(row);
    return callback ? r.get(callback) : r;
  };
});

function responseOf(parse, row) {
  return function(request) {
    return parse(request.responseText, row);
  };
}

// CONCATENATED MODULE: ./node_modules/d3-request/src/csv.js



/* harmony default export */ var src_csv = (dsv("text/csv", csv["f" /* csvParse */]));

// EXTERNAL MODULE: ./node_modules/d3-dsv/src/tsv.js
var tsv = __webpack_require__(15);

// CONCATENATED MODULE: ./node_modules/d3-request/src/tsv.js



/* harmony default export */ var src_tsv = (dsv("text/tab-separated-values", tsv["f" /* tsvParse */]));

// CONCATENATED MODULE: ./node_modules/d3-request/index.js









/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return function() {
    return this.matches(selector);
  };
});


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return styleValue; });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(_window__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * PlacedDiv. A container to position an html div to match the coordinates of a
 * SVG element.
 */

var utils = __webpack_require__(4);

var PlacedDiv = utils.make_class();
// instance methods
PlacedDiv.prototype = {
  init: init,
  is_visible: is_visible,
  place: place,
  hide: hide
};
module.exports = PlacedDiv;

function init(div, map) {
  var displacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { x: 0, y: 0 };
  var shouldReposition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  this.div = div;
  this.map = map;
  this.displacement = displacement;
  this.shouldReposition = shouldReposition;
  // begin hidden
  this.visible = true;
  this.hide();
}

function is_visible() {
  return this.visible;
}

/**
 * Position the html div to match the given SVG coordinates.
 */
function place(coords) {
  // show the input
  this.div.style('display', null);

  // move the new input
  var window_translate = this.map.zoomContainer.windowTranslate;
  var window_scale = this.map.zoomContainer.windowScale;
  var map_size = this.map.get_size();

  /**
   * If shouldReposition is true, the div is placed so that it does not render
   * outside of the viewable area of the window. Math.max is used so that it
   * does not overflow to the left and top, Math.min is used so that it does not
   * overflow to the right or bottom. If the screen is tool small to show the
   * entire div, the div will overflow to the right and bottom.
   */
  if (this.shouldReposition) {
    var left = Math.max(20, Math.min(map_size.width - 270, window_scale * coords.x + window_translate.x - this.displacement.x));
    var top = Math.max(20, Math.min(map_size.height - 40, window_scale * coords.y + window_translate.y - this.displacement.y));
    this.div.style('position', 'absolute').style('display', 'block').style('left', left + 'px').style('top', top + 'px');
  } else {
    this.div.style('position', 'absolute').style('display', 'block').style('left', window_scale * coords.x + window_translate.x - this.displacement.x + 'px').style('top', window_scale * coords.y + window_translate.y - this.displacement.y + 'px');
  }
  this.visible = true;
}

/**
 * Hide the PlacedDiv.
 */
function hide() {
  if (this.visible) {
    this.div.style('display', 'none');
    this.visible = false;
  }
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CobraModel
 */

var utils = __webpack_require__(4);
var dataStyles = __webpack_require__(20);

var CobraModel = utils.make_class();
// class methods
CobraModel.from_cobra_json = from_cobra_json;
CobraModel.build_reaction_string = build_reaction_string;
// instance methods
CobraModel.prototype = {
  init: init,
  apply_reaction_data: apply_reaction_data,
  apply_metabolite_data: apply_metabolite_data,
  apply_gene_data: apply_gene_data
};
module.exports = CobraModel;

// class methods

/**
 * Return a reaction string for the given stoichiometries. Adapted from
 * cobra.core.Reaction.build_reaction_string().
 * @param {Object} stoichiometries - An object with metabolites as keys and
 * stoichiometries as values.
 * @param {Boolean} is_reversible - Whether the reaction is reversible.
 */
function build_reaction_string(stoichiometries, is_reversible) {
  var format = function format(number) {
    if (number == 1) {
      return '';
    }
    return String(number) + ' ';
  };
  var reactant_dict = {};
  var product_dict = {};
  var reactant_bits = [];
  var product_bits = [];
  for (var the_metabolite in stoichiometries) {
    var coefficient = stoichiometries[the_metabolite];
    if (coefficient > 0) product_bits.push(format(coefficient) + the_metabolite);else reactant_bits.push(format(Math.abs(coefficient)) + the_metabolite);
  }
  var reaction_string = reactant_bits.join(' + ');
  if (is_reversible) {
    reaction_string += ' ↔ ';
  } else {
    reaction_string += ' → ';
  }
  reaction_string += product_bits.join(' + ');
  return reaction_string;
}

function from_cobra_json(model_data) {
  /** Use a JSON Cobra model exported by COBRApy to make a new CobraModel
      object.
       The COBRA "id" becomes a "bigg_id", and "upper_bound" and "lower_bound"
      bounds become "reversibility".
       Fills out a "genes" list.
   */
  // reactions and metabolites
  if (!(model_data.reactions && model_data.metabolites)) {
    throw new Error('Bad model data.');
  }

  // make a gene dictionary
  var genes = {};
  for (var i = 0, l = model_data.genes.length; i < l; i++) {
    var r = model_data.genes[i],
        the_id = r.id;
    genes[the_id] = r;
  }

  var model = new CobraModel();

  model.reactions = {};
  for (var i = 0, l = model_data.reactions.length; i < l; i++) {
    var r = model_data.reactions[i];
    var the_id = r.id;
    var reaction = utils.clone(r);
    delete reaction.id;
    reaction.bigg_id = the_id;
    reaction.data_string = '';
    // add the appropriate genes
    reaction.genes = [];

    // set reversibility
    reaction.reversibility = reaction.lower_bound < 0 && reaction.upper_bound > 0;
    if (reaction.upper_bound <= 0 && reaction.lower_bound < 0) {
      // reverse stoichiometries
      for (var met_id in reaction.metabolites) {
        reaction.metabolites[met_id] = -reaction.metabolites[met_id];
      }
    }
    delete reaction.lower_bound;
    delete reaction.upper_bound;

    if ('gene_reaction_rule' in reaction) {
      var gene_ids = dataStyles.genes_for_gene_reaction_rule(reaction.gene_reaction_rule);
      gene_ids.forEach(function (gene_id) {
        if (gene_id in genes) {
          var gene = utils.clone(genes[gene_id]);
          // rename id to bigg_id
          gene.bigg_id = gene.id;
          delete gene.id;
          reaction.genes.push(gene);
        } else {
          console.warn('Could not find gene for gene_id ' + gene_id);
        }
      });
    }
    model.reactions[the_id] = reaction;
  }
  model.metabolites = {};
  for (var i = 0, l = model_data.metabolites.length; i < l; i++) {
    var r = model_data.metabolites[i];
    var the_id = r.id;
    var met = utils.clone(r);
    delete met.id;
    met.bigg_id = the_id;
    model.metabolites[the_id] = met;
  }
  return model;
}

// instance methods
function init() {
  this.reactions = {};
  this.metabolites = {};
}

/**
 * Apply data to model. This is only used to display options in
 * BuildInput. apply_reaction_data overrides apply_gene_data.
 */
function apply_reaction_data(reaction_data, styles, compare_style) {
  dataStyles.apply_reaction_data_to_reactions(this.reactions, reaction_data, styles, compare_style);
}

/**
 * Apply data to model. This is only used to display options in BuildInput.
 */
function apply_metabolite_data(metabolite_data, styles, compare_style) {
  dataStyles.apply_metabolite_data_to_nodes(this.metabolites, metabolite_data, styles, compare_style);
}

/**
 * Apply data to model. This is only used to display options in
 * BuildInput. Overrides apply_reaction_data.
 */
function apply_gene_data(gene_data_obj, styles, identifiers_on_map, compare_style, and_method_in_gene_reaction_rule) {
  dataStyles.apply_gene_data_to_reactions(this.reactions, gene_data_obj, styles, identifiers_on_map, compare_style, and_method_in_gene_reaction_rule);
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {
var _slice = Array.prototype.slice;
var Bacon = {
  toString: function () {
    return "Bacon";
  }
};

Bacon.version = '0.7.95';

var Exception = (typeof global !== "undefined" && global !== null ? global : this).Error;
var nop = function () {};
var latter = function (_, x) {
  return x;
};
var former = function (x, _) {
  return x;
};
var cloneArray = function (xs) {
  return xs.slice(0);
};
var assert = function (message, condition) {
  if (!condition) {
    throw new Exception(message);
  }
};
var assertObservableIsProperty = function (x) {
  if ((x != null ? x._isObservable : void 0) && !(x != null ? x._isProperty : void 0)) {
    throw new Exception("Observable is not a Property : " + x);
  }
};
var assertEventStream = function (event) {
  if (!(event != null ? event._isEventStream : void 0)) {
    throw new Exception("not an EventStream : " + event);
  }
};

var assertObservable = function (event) {
  if (!(event != null ? event._isObservable : void 0)) {
    throw new Exception("not an Observable : " + event);
  }
};
var assertFunction = function (f) {
  return assert("not a function : " + f, _.isFunction(f));
};
var isArray = Array.isArray || function (xs) {
  return xs instanceof Array;
};
var isObservable = function (x) {
  return x && x._isObservable;
};
var assertArray = function (xs) {
  if (!isArray(xs)) {
    throw new Exception("not an array : " + xs);
  }
};
var assertNoArguments = function (args) {
  return assert("no arguments supported", args.length === 0);
};
var assertString = function (x) {
  if (typeof x === "string") {
    throw new Exception("not a string : " + x);
  }
};

var extend = function (target) {
  var length = arguments.length;
  for (var i = 1; 1 < length ? i < length : i > length; 1 < length ? i++ : i--) {
    for (var prop in arguments[i]) {
      target[prop] = arguments[i][prop];
    }
  }
  return target;
};

var inherit = function (child, parent) {
  var hasProp = ({}).hasOwnProperty;
  var ctor = function () {};
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
  for (var key in parent) {
    if (hasProp.call(parent, key)) {
      child[key] = parent[key];
    }
  }
  return child;
};

var symbol = function (key) {
  if (typeof Symbol !== "undefined" && Symbol[key]) {
    return Symbol[key];
  } else if (typeof Symbol !== "undefined" && typeof Symbol["for"] === "function") {
    return Symbol[key] = Symbol["for"](key);
  } else {
    return "@@" + key;
  }
};

var _ = {
  indexOf: (function () {
    if (Array.prototype.indexOf) {
      return function (xs, x) {
        return xs.indexOf(x);
      };
    } else {
      return function (xs, x) {
        for (var i = 0, y; i < xs.length; i++) {
          y = xs[i];
          if (x === y) {
            return i;
          }
        }
        return -1;
      };
    }
  })(),
  indexWhere: function (xs, f) {
    for (var i = 0, y; i < xs.length; i++) {
      y = xs[i];
      if (f(y)) {
        return i;
      }
    }
    return -1;
  },
  head: function (xs) {
    return xs[0];
  },
  always: function (x) {
    return function () {
      return x;
    };
  },
  negate: function (f) {
    return function (x) {
      return !f(x);
    };
  },
  empty: function (xs) {
    return xs.length === 0;
  },
  tail: function (xs) {
    return xs.slice(1, xs.length);
  },
  filter: function (f, xs) {
    var filtered = [];
    for (var i = 0, x; i < xs.length; i++) {
      x = xs[i];
      if (f(x)) {
        filtered.push(x);
      }
    }
    return filtered;
  },
  map: function (f, xs) {
    return (function () {
      var result = [];
      for (var i = 0, x; i < xs.length; i++) {
        x = xs[i];
        result.push(f(x));
      }
      return result;
    })();
  },
  each: function (xs, f) {
    for (var key in xs) {
      if (Object.prototype.hasOwnProperty.call(xs, key)) {
        var value = xs[key];
        f(key, value);
      }
    }
  },
  toArray: function (xs) {
    return isArray(xs) ? xs : [xs];
  },
  contains: function (xs, x) {
    return _.indexOf(xs, x) !== -1;
  },
  id: function (x) {
    return x;
  },
  last: function (xs) {
    return xs[xs.length - 1];
  },
  all: function (xs) {
    var f = arguments.length <= 1 || arguments[1] === undefined ? _.id : arguments[1];

    for (var i = 0, x; i < xs.length; i++) {
      x = xs[i];
      if (!f(x)) {
        return false;
      }
    }
    return true;
  },
  any: function (xs) {
    var f = arguments.length <= 1 || arguments[1] === undefined ? _.id : arguments[1];

    for (var i = 0, x; i < xs.length; i++) {
      x = xs[i];
      if (f(x)) {
        return true;
      }
    }
    return false;
  },
  without: function (x, xs) {
    return _.filter(function (y) {
      return y !== x;
    }, xs);
  },
  remove: function (x, xs) {
    var i = _.indexOf(xs, x);
    if (i >= 0) {
      return xs.splice(i, 1);
    }
  },
  fold: function (xs, seed, f) {
    for (var i = 0, x; i < xs.length; i++) {
      x = xs[i];
      seed = f(seed, x);
    }
    return seed;
  },
  flatMap: function (f, xs) {
    return _.fold(xs, [], function (ys, x) {
      return ys.concat(f(x));
    });
  },
  cached: function (f) {
    var value = None;
    return function () {
      if (typeof value !== "undefined" && value !== null ? value._isNone : undefined) {
        value = f();
        f = undefined;
      }
      return value;
    };
  },
  bind: function (fn, me) {
    return function () {
      return fn.apply(me, arguments);
    };
  },
  isFunction: function (f) {
    return typeof f === "function";
  },
  toString: function (obj) {
    var internals, key, value;
    var hasProp = ({}).hasOwnProperty;
    try {
      recursionDepth++;
      if (obj == null) {
        return "undefined";
      } else if (_.isFunction(obj)) {
        return "function";
      } else if (isArray(obj)) {
        if (recursionDepth > 5) {
          return "[..]";
        }
        return "[" + _.map(_.toString, obj).toString() + "]";
      } else if ((obj != null ? obj.toString : void 0) != null && obj.toString !== Object.prototype.toString) {
        return obj.toString();
      } else if (typeof obj === "object") {
        if (recursionDepth > 5) {
          return "{..}";
        }
        internals = (function () {
          var results = [];
          for (key in obj) {
            if (!hasProp.call(obj, key)) continue;
            value = (function () {
              var error;
              try {
                return obj[key];
              } catch (error) {
                return error;
              }
            })();
            results.push(_.toString(key) + ":" + _.toString(value));
          }
          return results;
        })();
        return "{" + internals + "}";
      } else {
        return obj;
      }
    } finally {
      recursionDepth--;
    }
  }
};

var recursionDepth = 0;

Bacon._ = _;

var UpdateBarrier = Bacon.UpdateBarrier = (function () {
  var rootEvent;
  var waiterObs = [];
  var waiters = {};
  var aftersStack = [];
  var aftersStackHeight = 0;
  var flushed = {};

  function ensureStackHeight(h) {
    if (h <= aftersStackHeight) return;
    if (!aftersStack[h - 1]) {
      aftersStack[h - 1] = [[], 0];
    }
    aftersStackHeight = h;
  }

  var afterTransaction = function (obs, f) {
    if (rootEvent || aftersStack.length) {
      ensureStackHeight(1);
      var stackIndexForThisObs = 0;
      while (stackIndexForThisObs < aftersStackHeight - 1) {
        if (containsObs(obs, aftersStack[stackIndexForThisObs][0])) {
          break;
        }
        stackIndexForThisObs++;
      }
      var listFromStack = aftersStack[stackIndexForThisObs][0];
      listFromStack.push([obs, f]);
      if (!rootEvent) {
        processAfters();
      }
    } else {
        return f();
      }
  };

  function containsObs(obs, aftersList) {
    for (var i = 0; i < aftersList.length; i++) {
      if (aftersList[i][0].id == obs.id) return true;
    }
    return false;
  }

  function processAfters() {
    var stackSizeAtStart = aftersStackHeight;
    if (!stackSizeAtStart) return;
    while (aftersStackHeight >= stackSizeAtStart) {
      var topOfStack = aftersStack[aftersStackHeight - 1];
      if (!topOfStack) throw new Error("Unexpected stack top: " + topOfStack);
      var topAfters = topOfStack[0];
      var index = topOfStack[1];

      if (index < topAfters.length) {
        var _topAfters$index = topAfters[index];
        var obs = _topAfters$index[0];
        var after = _topAfters$index[1];

        topOfStack[1]++;
        ensureStackHeight(aftersStackHeight + 1);
        var callSuccess = false;
        try {
          after();
          callSuccess = true;
          while (aftersStackHeight > stackSizeAtStart && aftersStack[aftersStackHeight - 1][0].length == 0) {
            aftersStackHeight--;
          }
        } finally {
          if (!callSuccess) {
            aftersStack = [];
            aftersStackHeight = 0;
          }
        }
      } else {
          topOfStack[0] = [];
          topOfStack[1] = 0;
          break;
        }
    }
  }

  var whenDoneWith = function (obs, f) {
    if (rootEvent) {
      var obsWaiters = waiters[obs.id];
      if (!(typeof obsWaiters !== "undefined" && obsWaiters !== null)) {
        obsWaiters = waiters[obs.id] = [f];
        return waiterObs.push(obs);
      } else {
        return obsWaiters.push(f);
      }
    } else {
      return f();
    }
  };

  var flush = function () {
    while (waiterObs.length > 0) {
      flushWaiters(0, true);
    }
    flushed = {};
  };

  var flushWaiters = function (index, deps) {
    var obs = waiterObs[index];
    var obsId = obs.id;
    var obsWaiters = waiters[obsId];
    waiterObs.splice(index, 1);
    delete waiters[obsId];
    if (deps && waiterObs.length > 0) {
      flushDepsOf(obs);
    }
    for (var i = 0, f; i < obsWaiters.length; i++) {
      f = obsWaiters[i];
      f();
    }
  };

  var flushDepsOf = function (obs) {
    if (flushed[obs.id]) return;
    var deps = obs.internalDeps();
    for (var i = 0, dep; i < deps.length; i++) {
      dep = deps[i];
      flushDepsOf(dep);
      if (waiters[dep.id]) {
        var index = _.indexOf(waiterObs, dep);
        flushWaiters(index, false);
      }
    }
    flushed[obs.id] = true;
  };

  var inTransaction = function (event, context, f, args) {
    if (rootEvent) {
      return f.apply(context, args);
    } else {
      rootEvent = event;
      try {
        var result = f.apply(context, args);

        flush();
      } finally {
        rootEvent = undefined;
        processAfters();
      }
      return result;
    }
  };

  var currentEventId = function () {
    return rootEvent ? rootEvent.id : undefined;
  };

  var wrappedSubscribe = function (obs, sink) {
    var unsubd = false;
    var shouldUnsub = false;
    var doUnsub = function () {
      shouldUnsub = true;
      return shouldUnsub;
    };
    var unsub = function () {
      unsubd = true;
      return doUnsub();
    };
    doUnsub = obs.dispatcher.subscribe(function (event) {
      return afterTransaction(obs, function () {
        if (!unsubd) {
          var reply = sink(event);
          if (reply === Bacon.noMore) {
            return unsub();
          }
        }
      });
    });
    if (shouldUnsub) {
      doUnsub();
    }
    return unsub;
  };

  var hasWaiters = function () {
    return waiterObs.length > 0;
  };

  return { whenDoneWith: whenDoneWith, hasWaiters: hasWaiters, inTransaction: inTransaction, currentEventId: currentEventId, wrappedSubscribe: wrappedSubscribe, afterTransaction: afterTransaction };
})();

function Source(obs, sync) {
  var lazy = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

  this.obs = obs;
  this.sync = sync;
  this.lazy = lazy;
  this.queue = [];
}

extend(Source.prototype, {
  _isSource: true,

  subscribe: function (sink) {
    return this.obs.dispatcher.subscribe(sink);
  },
  toString: function () {
    return this.obs.toString();
  },
  markEnded: function () {
    this.ended = true;
    return true;
  },
  consume: function () {
    if (this.lazy) {
      return { value: _.always(this.queue[0]) };
    } else {
      return this.queue[0];
    }
  },
  push: function (x) {
    this.queue = [x];
    return [x];
  },
  mayHave: function () {
    return true;
  },
  hasAtLeast: function () {
    return this.queue.length;
  },
  flatten: true
});

function ConsumingSource() {
  Source.apply(this, arguments);
}

inherit(ConsumingSource, Source);
extend(ConsumingSource.prototype, {
  consume: function () {
    return this.queue.shift();
  },
  push: function (x) {
    return this.queue.push(x);
  },
  mayHave: function (c) {
    return !this.ended || this.queue.length >= c;
  },
  hasAtLeast: function (c) {
    return this.queue.length >= c;
  },
  flatten: false
});

function BufferingSource(obs) {
  Source.call(this, obs, true);
}

inherit(BufferingSource, Source);
extend(BufferingSource.prototype, {
  consume: function () {
    var values = this.queue;
    this.queue = [];
    return {
      value: function () {
        return values;
      }
    };
  },
  push: function (x) {
    return this.queue.push(x.value());
  },
  hasAtLeast: function () {
    return true;
  }
});

Source.isTrigger = function (s) {
  if (s != null ? s._isSource : void 0) {
    return s.sync;
  } else {
    return s != null ? s._isEventStream : void 0;
  }
};

Source.fromObservable = function (s) {
  if (s != null ? s._isSource : void 0) {
    return s;
  } else if (s != null ? s._isProperty : void 0) {
    return new Source(s, false);
  } else {
    return new ConsumingSource(s, true);
  }
};

function Desc(context, method, args) {
  this.context = context;
  this.method = method;
  this.args = args;
}

extend(Desc.prototype, {
  _isDesc: true,
  deps: function () {
    if (!this.cached) {
      this.cached = findDeps([this.context].concat(this.args));
    }
    return this.cached;
  },
  toString: function () {
    return _.toString(this.context) + "." + _.toString(this.method) + "(" + _.map(_.toString, this.args) + ")";
  }
});

var describe = function (context, method) {
  var ref = context || method;
  if (ref && ref._isDesc) {
    return context || method;
  } else {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return new Desc(context, method, args);
  }
};

var withDesc = function (desc, obs) {
  obs.desc = desc;
  return obs;
};

var findDeps = function (x) {
  if (isArray(x)) {
    return _.flatMap(findDeps, x);
  } else if (isObservable(x)) {
    return [x];
  } else if (typeof x !== "undefined" && x !== null ? x._isSource : undefined) {
    return [x.obs];
  } else {
    return [];
  }
};

Bacon.Desc = Desc;
Bacon.Desc.empty = new Bacon.Desc("", "", []);

var withMethodCallSupport = function (wrapped) {
  return function (f) {
    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    if (typeof f === "object" && args.length) {
      var context = f;
      var methodName = args[0];
      f = function () {
        return context[methodName].apply(context, arguments);
      };
      args = args.slice(1);
    }
    return wrapped.apply(undefined, [f].concat(args));
  };
};

var makeFunctionArgs = function (args) {
  args = Array.prototype.slice.call(args);
  return makeFunction_.apply(undefined, args);
};

var partiallyApplied = function (f, applied) {
  return function () {
    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return f.apply(undefined, applied.concat(args));
  };
};

var toSimpleExtractor = function (args) {
  return function (key) {
    return function (value) {
      if (!(typeof value !== "undefined" && value !== null)) {
        return;
      } else {
        var fieldValue = value[key];
        if (_.isFunction(fieldValue)) {
          return fieldValue.apply(value, args);
        } else {
          return fieldValue;
        }
      }
    };
  };
};

var toFieldExtractor = function (f, args) {
  var parts = f.slice(1).split(".");
  var partFuncs = _.map(toSimpleExtractor(args), parts);
  return function (value) {
    for (var i = 0, f; i < partFuncs.length; i++) {
      f = partFuncs[i];
      value = f(value);
    }
    return value;
  };
};

var isFieldKey = function (f) {
  return typeof f === "string" && f.length > 1 && f.charAt(0) === ".";
};

var makeFunction_ = withMethodCallSupport(function (f) {
  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  if (_.isFunction(f)) {
    if (args.length) {
      return partiallyApplied(f, args);
    } else {
      return f;
    }
  } else if (isFieldKey(f)) {
    return toFieldExtractor(f, args);
  } else {
    return _.always(f);
  }
});

var makeFunction = function (f, args) {
  return makeFunction_.apply(undefined, [f].concat(args));
};

var convertArgsToFunction = function (obs, f, args, method) {
  if (typeof f !== "undefined" && f !== null ? f._isProperty : undefined) {
    var sampled = f.sampledBy(obs, function (p, s) {
      return [p, s];
    });
    return method.call(sampled, function (_ref) {
      var p = _ref[0];
      var s = _ref[1];
      return p;
    }).map(function (_ref2) {
      var p = _ref2[0];
      var s = _ref2[1];
      return s;
    });
  } else {
    f = makeFunction(f, args);
    return method.call(obs, f);
  }
};

var toCombinator = function (f) {
  if (_.isFunction(f)) {
    return f;
  } else if (isFieldKey(f)) {
    var key = toFieldKey(f);
    return function (left, right) {
      return left[key](right);
    };
  } else {
    throw new Exception("not a function or a field key: " + f);
  }
};

var toFieldKey = function (f) {
  return f.slice(1);
};

function Some(value) {
  this.value = value;
}

extend(Some.prototype, {
  _isSome: true,
  getOrElse: function () {
    return this.value;
  },
  get: function () {
    return this.value;
  },
  filter: function (f) {
    if (f(this.value)) {
      return new Some(this.value);
    } else {
      return None;
    }
  },
  map: function (f) {
    return new Some(f(this.value));
  },
  forEach: function (f) {
    return f(this.value);
  },
  isDefined: true,
  toArray: function () {
    return [this.value];
  },
  inspect: function () {
    return "Some(" + this.value + ")";
  },
  toString: function () {
    return this.inspect();
  }
});

var None = {
  _isNone: true,
  getOrElse: function (value) {
    return value;
  },
  filter: function () {
    return None;
  },
  map: function () {
    return None;
  },
  forEach: function () {},
  isDefined: false,
  toArray: function () {
    return [];
  },
  inspect: function () {
    return "None";
  },
  toString: function () {
    return this.inspect();
  }
};

var toOption = function (v) {
  if ((typeof v !== "undefined" && v !== null ? v._isSome : undefined) || (typeof v !== "undefined" && v !== null ? v._isNone : undefined)) {
    return v;
  } else {
    return new Some(v);
  }
};

Bacon.noMore = "<no-more>";
Bacon.more = "<more>";

var eventIdCounter = 0;

function Event() {
  this.id = ++eventIdCounter;
}

Event.prototype._isEvent = true;
Event.prototype.isEvent = function () {
  return true;
};
Event.prototype.isEnd = function () {
  return false;
};
Event.prototype.isInitial = function () {
  return false;
};
Event.prototype.isNext = function () {
  return false;
};
Event.prototype.isError = function () {
  return false;
};
Event.prototype.hasValue = function () {
  return false;
};
Event.prototype.filter = function () {
  return true;
};
Event.prototype.inspect = function () {
  return this.toString();
};
Event.prototype.log = function () {
  return this.toString();
};

function Next(valueF, eager) {
  if (!(this instanceof Next)) {
    return new Next(valueF, eager);
  }

  Event.call(this);

  if (!eager && _.isFunction(valueF) || (valueF != null ? valueF._isNext : void 0)) {
    this.valueF = valueF;
    this.valueInternal = void 0;
  } else {
    this.valueF = void 0;
    this.valueInternal = valueF;
  }
}

inherit(Next, Event);

Next.prototype.isNext = function () {
  return true;
};
Next.prototype.hasValue = function () {
  return true;
};
Next.prototype.value = function () {
  var ref;
  if ((ref = this.valueF) != null ? ref._isNext : void 0) {
    this.valueInternal = this.valueF.value();
    this.valueF = void 0;
  } else if (this.valueF) {
    this.valueInternal = this.valueF();
    this.valueF = void 0;
  }
  return this.valueInternal;
};

Next.prototype.fmap = function (f) {
  var event, value;
  if (this.valueInternal) {
    value = this.valueInternal;
    return this.apply(function () {
      return f(value);
    });
  } else {
    event = this;
    return this.apply(function () {
      return f(event.value());
    });
  }
};

Next.prototype.apply = function (value) {
  return new Next(value);
};
Next.prototype.filter = function (f) {
  return f(this.value());
};
Next.prototype.toString = function () {
  return _.toString(this.value());
};
Next.prototype.log = function () {
  return this.value();
};
Next.prototype._isNext = true;

function Initial(valueF, eager) {
  if (!(this instanceof Initial)) {
    return new Initial(valueF, eager);
  }
  Next.call(this, valueF, eager);
}

inherit(Initial, Next);
Initial.prototype._isInitial = true;
Initial.prototype.isInitial = function () {
  return true;
};
Initial.prototype.isNext = function () {
  return false;
};
Initial.prototype.apply = function (value) {
  return new Initial(value);
};
Initial.prototype.toNext = function () {
  return new Next(this);
};

function End() {
  if (!(this instanceof End)) {
    return new End();
  }
  Event.call(this);
}

inherit(End, Event);
End.prototype.isEnd = function () {
  return true;
};
End.prototype.fmap = function () {
  return this;
};
End.prototype.apply = function () {
  return this;
};
End.prototype.toString = function () {
  return "<end>";
};

function Error(error) {
  if (!(this instanceof Error)) {
    return new Error(error);
  }
  this.error = error;
  Event.call(this);
}

inherit(Error, Event);
Error.prototype.isError = function () {
  return true;
};
Error.prototype.fmap = function () {
  return this;
};
Error.prototype.apply = function () {
  return this;
};
Error.prototype.toString = function () {
  return "<error> " + _.toString(this.error);
};

Bacon.Event = Event;
Bacon.Initial = Initial;
Bacon.Next = Next;
Bacon.End = End;
Bacon.Error = Error;

var initialEvent = function (value) {
  return new Initial(value, true);
};
var nextEvent = function (value) {
  return new Next(value, true);
};
var endEvent = function () {
  return new End();
};
var toEvent = function (x) {
  if (x && x._isEvent) {
    return x;
  } else {
    return nextEvent(x);
  }
};

var idCounter = 0;
var registerObs = function () {};

function Observable(desc) {
  this.desc = desc;
  this.id = ++idCounter;
  this.initialDesc = this.desc;
}

extend(Observable.prototype, {
  _isObservable: true,

  subscribe: function (sink) {
    return UpdateBarrier.wrappedSubscribe(this, sink);
  },

  subscribeInternal: function (sink) {
    return this.dispatcher.subscribe(sink);
  },

  onValue: function () {
    var f = makeFunctionArgs(arguments);
    return this.subscribe(function (event) {
      if (event.hasValue()) {
        return f(event.value());
      }
    });
  },

  onValues: function (f) {
    return this.onValue(function (args) {
      return f.apply(undefined, args);
    });
  },

  onError: function () {
    var f = makeFunctionArgs(arguments);
    return this.subscribe(function (event) {
      if (event.isError()) {
        return f(event.error);
      }
    });
  },

  onEnd: function () {
    var f = makeFunctionArgs(arguments);
    return this.subscribe(function (event) {
      if (event.isEnd()) {
        return f();
      }
    });
  },

  name: function (name) {
    this._name = name;
    return this;
  },

  withDescription: function () {
    this.desc = describe.apply(undefined, arguments);
    return this;
  },

  toString: function () {
    if (this._name) {
      return this._name;
    } else {
      return this.desc.toString();
    }
  },

  deps: function () {
    return this.desc.deps();
  },

  internalDeps: function () {
    return this.initialDesc.deps();
  }
});

Observable.prototype.assign = Observable.prototype.onValue;
Observable.prototype.forEach = Observable.prototype.onValue;
Observable.prototype.inspect = Observable.prototype.toString;

Bacon.Observable = Observable;

function CompositeUnsubscribe() {
  var ss = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

  this.unsubscribe = _.bind(this.unsubscribe, this);
  this.unsubscribed = false;
  this.subscriptions = [];
  this.starting = [];
  for (var i = 0, s; i < ss.length; i++) {
    s = ss[i];
    this.add(s);
  }
}

extend(CompositeUnsubscribe.prototype, {
  add: function (subscription) {
    var _this2 = this;

    if (this.unsubscribed) {
      return;
    }
    var ended = false;
    var unsub = nop;
    this.starting.push(subscription);
    var unsubMe = function () {
      if (_this2.unsubscribed) {
        return;
      }
      ended = true;
      _this2.remove(unsub);
      return _.remove(subscription, _this2.starting);
    };
    unsub = subscription(this.unsubscribe, unsubMe);
    if (!(this.unsubscribed || ended)) {
      this.subscriptions.push(unsub);
    } else {
      unsub();
    }
    _.remove(subscription, this.starting);
    return unsub;
  },

  remove: function (unsub) {
    if (this.unsubscribed) {
      return;
    }
    if (_.remove(unsub, this.subscriptions) !== undefined) {
      return unsub();
    }
  },

  unsubscribe: function () {
    if (this.unsubscribed) {
      return;
    }
    this.unsubscribed = true;
    var iterable = this.subscriptions;
    for (var i = 0; i < iterable.length; i++) {
      iterable[i]();
    }
    this.subscriptions = [];
    this.starting = [];
    return [];
  },

  count: function () {
    if (this.unsubscribed) {
      return 0;
    }
    return this.subscriptions.length + this.starting.length;
  },

  empty: function () {
    return this.count() === 0;
  }
});

Bacon.CompositeUnsubscribe = CompositeUnsubscribe;

function Dispatcher(_subscribe, _handleEvent) {
  this._subscribe = _subscribe;
  this._handleEvent = _handleEvent;
  this.subscribe = _.bind(this.subscribe, this);
  this.handleEvent = _.bind(this.handleEvent, this);
  this.pushing = false;
  this.ended = false;
  this.prevError = undefined;
  this.unsubSrc = undefined;
  this.subscriptions = [];
  this.queue = [];
}

Dispatcher.prototype.hasSubscribers = function () {
  return this.subscriptions.length > 0;
};

Dispatcher.prototype.removeSub = function (subscription) {
  this.subscriptions = _.without(subscription, this.subscriptions);
  return this.subscriptions;
};

Dispatcher.prototype.push = function (event) {
  if (event.isEnd()) {
    this.ended = true;
  }
  return UpdateBarrier.inTransaction(event, this, this.pushIt, [event]);
};

Dispatcher.prototype.pushToSubscriptions = function (event) {
  try {
    var tmp = this.subscriptions;
    var len = tmp.length;
    for (var i = 0; i < len; i++) {
      var sub = tmp[i];
      var reply = sub.sink(event);
      if (reply === Bacon.noMore || event.isEnd()) {
        this.removeSub(sub);
      }
    }
    return true;
  } catch (error) {
    this.pushing = false;
    this.queue = [];
    throw error;
  }
};

Dispatcher.prototype.pushIt = function (event) {
  if (!this.pushing) {
    if (event === this.prevError) {
      return;
    }
    if (event.isError()) {
      this.prevError = event;
    }
    this.pushing = true;
    this.pushToSubscriptions(event);
    this.pushing = false;
    while (this.queue.length) {
      event = this.queue.shift();
      this.push(event);
    }
    if (this.hasSubscribers()) {
      return Bacon.more;
    } else {
      this.unsubscribeFromSource();
      return Bacon.noMore;
    }
  } else {
    this.queue.push(event);
    return Bacon.more;
  }
};

Dispatcher.prototype.handleEvent = function (event) {
  if (this._handleEvent) {
    return this._handleEvent(event);
  } else {
    return this.push(event);
  }
};

Dispatcher.prototype.unsubscribeFromSource = function () {
  if (this.unsubSrc) {
    this.unsubSrc();
  }
  this.unsubSrc = undefined;
};

Dispatcher.prototype.subscribe = function (sink) {
  var subscription;
  if (this.ended) {
    sink(endEvent());
    return nop;
  } else {
    assertFunction(sink);
    subscription = {
      sink: sink
    };
    this.subscriptions.push(subscription);
    if (this.subscriptions.length === 1) {
      this.unsubSrc = this._subscribe(this.handleEvent);
      assertFunction(this.unsubSrc);
    }
    return (function (_this) {
      return function () {
        _this.removeSub(subscription);
        if (!_this.hasSubscribers()) {
          return _this.unsubscribeFromSource();
        }
      };
    })(this);
  }
};

Bacon.Dispatcher = Dispatcher;

function EventStream(desc, subscribe, handler) {
  if (!(this instanceof EventStream)) {
    return new EventStream(desc, subscribe, handler);
  }
  if (_.isFunction(desc)) {
    handler = subscribe;
    subscribe = desc;
    desc = Desc.empty;
  }
  Observable.call(this, desc);
  assertFunction(subscribe);
  this.dispatcher = new Dispatcher(subscribe, handler);
  registerObs(this);
}

inherit(EventStream, Observable);
extend(EventStream.prototype, {
  _isEventStream: true,

  toProperty: function (initValue_) {
    var initValue = arguments.length === 0 ? None : toOption(function () {
      return initValue_;
    });
    var disp = this.dispatcher;
    var desc = new Bacon.Desc(this, "toProperty", [initValue_]);
    return new Property(desc, function (sink) {
      var initSent = false;
      var subbed = false;
      var unsub = nop;
      var reply = Bacon.more;
      var sendInit = function () {
        if (!initSent) {
          return initValue.forEach(function (value) {
            initSent = true;
            reply = sink(new Initial(value));
            if (reply === Bacon.noMore) {
              unsub();
              unsub = nop;
              return nop;
            }
          });
        }
      };

      unsub = disp.subscribe(function (event) {
        if (event.hasValue()) {
          if (event.isInitial() && !subbed) {
            initValue = new Some(function () {
              return event.value();
            });
            return Bacon.more;
          } else {
            if (!event.isInitial()) {
              sendInit();
            }
            initSent = true;
            initValue = new Some(event);
            return sink(event);
          }
        } else {
          if (event.isEnd()) {
            reply = sendInit();
          }
          if (reply !== Bacon.noMore) {
            return sink(event);
          }
        }
      });
      subbed = true;
      sendInit();
      return unsub;
    });
  },

  toEventStream: function () {
    return this;
  },

  withHandler: function (handler) {
    return new EventStream(new Bacon.Desc(this, "withHandler", [handler]), this.dispatcher.subscribe, handler);
  }
});

Bacon.EventStream = EventStream;

Bacon.never = function () {
  return new EventStream(describe(Bacon, "never"), function (sink) {
    sink(endEvent());
    return nop;
  });
};

Bacon.when = function () {
  if (arguments.length === 0) {
    return Bacon.never();
  }
  var len = arguments.length;
  var usage = "when: expecting arguments in the form (Observable+,function)+";

  assert(usage, len % 2 === 0);
  var sources = [];
  var pats = [];
  var i = 0;
  var patterns = [];
  while (i < len) {
    patterns[i] = arguments[i];
    patterns[i + 1] = arguments[i + 1];
    var patSources = _.toArray(arguments[i]);
    var f = constantToFunction(arguments[i + 1]);
    var pat = { f: f, ixs: [] };
    var triggerFound = false;
    for (var j = 0, s; j < patSources.length; j++) {
      s = patSources[j];
      var index = _.indexOf(sources, s);
      if (!triggerFound) {
        triggerFound = Source.isTrigger(s);
      }
      if (index < 0) {
        sources.push(s);
        index = sources.length - 1;
      }
      for (var k = 0, ix; k < pat.ixs.length; k++) {
        ix = pat.ixs[k];
        if (ix.index === index) {
          ix.count++;
        }
      }
      pat.ixs.push({ index: index, count: 1 });
    }

    assert("At least one EventStream required", triggerFound || !patSources.length);

    if (patSources.length > 0) {
      pats.push(pat);
    }
    i = i + 2;
  }

  if (!sources.length) {
    return Bacon.never();
  }

  sources = _.map(Source.fromObservable, sources);
  var needsBarrier = _.any(sources, function (s) {
    return s.flatten;
  }) && containsDuplicateDeps(_.map(function (s) {
    return s.obs;
  }, sources));

  var desc = new Bacon.Desc(Bacon, "when", patterns);
  var resultStream = new EventStream(desc, function (sink) {
    var triggers = [];
    var ends = false;
    var match = function (p) {
      for (var i1 = 0, i; i1 < p.ixs.length; i1++) {
        i = p.ixs[i1];
        if (!sources[i.index].hasAtLeast(i.count)) {
          return false;
        }
      }
      return true;
    };
    var cannotSync = function (source) {
      return !source.sync || source.ended;
    };
    var cannotMatch = function (p) {
      for (var i1 = 0, i; i1 < p.ixs.length; i1++) {
        i = p.ixs[i1];
        if (!sources[i.index].mayHave(i.count)) {
          return true;
        }
      }
    };
    var nonFlattened = function (trigger) {
      return !trigger.source.flatten;
    };
    var part = function (source) {
      return function (unsubAll) {
        var flushLater = function () {
          return UpdateBarrier.whenDoneWith(resultStream, flush);
        };
        var flushWhileTriggers = function () {
          if (triggers.length > 0) {
            var reply = Bacon.more;
            var trigger = triggers.pop();
            for (var i1 = 0, p; i1 < pats.length; i1++) {
              p = pats[i1];
              if (match(p)) {
                var events = (function () {
                  var result = [];
                  for (var i2 = 0, i; i2 < p.ixs.length; i2++) {
                    i = p.ixs[i2];
                    result.push(sources[i.index].consume());
                  }
                  return result;
                })();
                reply = sink(trigger.e.apply(function () {
                  var _p;

                  var values = (function () {
                    var result = [];
                    for (var i2 = 0, event; i2 < events.length; i2++) {
                      event = events[i2];
                      result.push(event.value());
                    }
                    return result;
                  })();

                  return (_p = p).f.apply(_p, values);
                }));
                if (triggers.length) {
                  triggers = _.filter(nonFlattened, triggers);
                }
                if (reply === Bacon.noMore) {
                  return reply;
                } else {
                  return flushWhileTriggers();
                }
              }
            }
          } else {
            return Bacon.more;
          }
        };
        var flush = function () {
          var reply = flushWhileTriggers();
          if (ends) {
            if (_.all(sources, cannotSync) || _.all(pats, cannotMatch)) {
              reply = Bacon.noMore;
              sink(endEvent());
            }
          }
          if (reply === Bacon.noMore) {
            unsubAll();
          }

          return reply;
        };
        return source.subscribe(function (e) {
          if (e.isEnd()) {
            ends = true;
            source.markEnded();
            flushLater();
          } else if (e.isError()) {
            var reply = sink(e);
          } else {
            source.push(e);
            if (source.sync) {
              triggers.push({ source: source, e: e });
              if (needsBarrier || UpdateBarrier.hasWaiters()) {
                flushLater();
              } else {
                flush();
              }
            }
          }
          if (reply === Bacon.noMore) {
            unsubAll();
          }
          return reply || Bacon.more;
        });
      };
    };

    return new Bacon.CompositeUnsubscribe((function () {
      var result = [];
      for (var i1 = 0, s; i1 < sources.length; i1++) {
        s = sources[i1];
        result.push(part(s));
      }
      return result;
    })()).unsubscribe;
  });
  return resultStream;
};

var containsDuplicateDeps = function (observables) {
  var state = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

  var checkObservable = function (obs) {
    if (_.contains(state, obs)) {
      return true;
    } else {
      var deps = obs.internalDeps();
      if (deps.length) {
        state.push(obs);
        return _.any(deps, checkObservable);
      } else {
        state.push(obs);
        return false;
      }
    }
  };

  return _.any(observables, checkObservable);
};

var constantToFunction = function (f) {
  if (_.isFunction(f)) {
    return f;
  } else {
    return _.always(f);
  }
};

Bacon.groupSimultaneous = function () {
  for (var _len5 = arguments.length, streams = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    streams[_key5] = arguments[_key5];
  }

  if (streams.length === 1 && isArray(streams[0])) {
    streams = streams[0];
  }
  var sources = (function () {
    var result = [];
    for (var i = 0, s; i < streams.length; i++) {
      s = streams[i];
      result.push(new BufferingSource(s));
    }
    return result;
  })();
  return withDesc(new Bacon.Desc(Bacon, "groupSimultaneous", streams), Bacon.when(sources, function () {
    for (var _len6 = arguments.length, xs = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      xs[_key6] = arguments[_key6];
    }

    return xs;
  }));
};

function PropertyDispatcher(property, subscribe, handleEvent) {
  Dispatcher.call(this, subscribe, handleEvent);
  this.property = property;
  this.subscribe = _.bind(this.subscribe, this);
  this.current = None;
  this.currentValueRootId = undefined;
  this.propertyEnded = false;
}

inherit(PropertyDispatcher, Dispatcher);
extend(PropertyDispatcher.prototype, {
  push: function (event) {
    if (event.isEnd()) {
      this.propertyEnded = true;
    }
    if (event.hasValue()) {
      this.current = new Some(event);
      this.currentValueRootId = UpdateBarrier.currentEventId();
    }
    return Dispatcher.prototype.push.call(this, event);
  },

  maybeSubSource: function (sink, reply) {
    if (reply === Bacon.noMore) {
      return nop;
    } else if (this.propertyEnded) {
      sink(endEvent());
      return nop;
    } else {
      return Dispatcher.prototype.subscribe.call(this, sink);
    }
  },

  subscribe: function (sink) {
    var _this3 = this;

    var initSent = false;

    var reply = Bacon.more;

    if (this.current.isDefined && (this.hasSubscribers() || this.propertyEnded)) {
      var dispatchingId = UpdateBarrier.currentEventId();
      var valId = this.currentValueRootId;
      if (!this.propertyEnded && valId && dispatchingId && dispatchingId !== valId) {
        UpdateBarrier.whenDoneWith(this.property, function () {
          if (_this3.currentValueRootId === valId) {
            return sink(initialEvent(_this3.current.get().value()));
          }
        });

        return this.maybeSubSource(sink, reply);
      } else {
        UpdateBarrier.inTransaction(undefined, this, function () {
          reply = sink(initialEvent(this.current.get().value()));
          return reply;
        }, []);
        return this.maybeSubSource(sink, reply);
      }
    } else {
      return this.maybeSubSource(sink, reply);
    }
  }
});

function Property(desc, subscribe, handler) {
  Observable.call(this, desc);
  assertFunction(subscribe);
  this.dispatcher = new PropertyDispatcher(this, subscribe, handler);
  registerObs(this);
}

inherit(Property, Observable);
extend(Property.prototype, {
  _isProperty: true,

  changes: function () {
    var _this4 = this;

    return new EventStream(new Bacon.Desc(this, "changes", []), function (sink) {
      return _this4.dispatcher.subscribe(function (event) {
        if (!event.isInitial()) {
          return sink(event);
        }
      });
    });
  },

  withHandler: function (handler) {
    return new Property(new Bacon.Desc(this, "withHandler", [handler]), this.dispatcher.subscribe, handler);
  },

  toProperty: function () {
    assertNoArguments(arguments);
    return this;
  },

  toEventStream: function () {
    var _this5 = this;

    return new EventStream(new Bacon.Desc(this, "toEventStream", []), function (sink) {
      return _this5.dispatcher.subscribe(function (event) {
        if (event.isInitial()) {
          event = event.toNext();
        }
        return sink(event);
      });
    });
  }
});

Bacon.Property = Property;

Bacon.constant = function (value) {
  return new Property(new Bacon.Desc(Bacon, "constant", [value]), function (sink) {
    sink(initialEvent(value));
    sink(endEvent());
    return nop;
  });
};

Bacon.fromBinder = function (binder) {
  var eventTransformer = arguments.length <= 1 || arguments[1] === undefined ? _.id : arguments[1];

  var desc = new Bacon.Desc(Bacon, "fromBinder", [binder, eventTransformer]);
  return new EventStream(desc, function (sink) {
    var unbound = false;
    var shouldUnbind = false;
    var unbind = function () {
      if (!unbound) {
        if (typeof unbinder !== "undefined" && unbinder !== null) {
          unbinder();
          return unbound = true;
        } else {
          return shouldUnbind = true;
        }
      }
    };
    var unbinder = binder(function () {
      var ref;

      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      var value = eventTransformer.apply(this, args);
      if (!(isArray(value) && ((ref = _.last(value)) != null ? ref._isEvent : undefined))) {
        value = [value];
      }
      var reply = Bacon.more;
      for (var i = 0, event; i < value.length; i++) {
        event = value[i];
        reply = sink(event = toEvent(event));
        if (reply === Bacon.noMore || event.isEnd()) {
          unbind();
          return reply;
        }
      }
      return reply;
    });
    if (shouldUnbind) {
      unbind();
    }
    return unbind;
  });
};

Bacon.Observable.prototype.map = function (p) {
  for (var _len8 = arguments.length, args = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
    args[_key8 - 1] = arguments[_key8];
  }

  return convertArgsToFunction(this, p, args, function (f) {
    return withDesc(new Bacon.Desc(this, "map", [f]), this.withHandler(function (event) {
      return this.push(event.fmap(f));
    }));
  });
};

var argumentsToObservables = function (args) {
  if (isArray(args[0])) {
    return args[0];
  } else {
    return Array.prototype.slice.call(args);
  }
};

var argumentsToObservablesAndFunction = function (args) {
  if (_.isFunction(args[0])) {
    return [argumentsToObservables(Array.prototype.slice.call(args, 1)), args[0]];
  } else {
    return [argumentsToObservables(Array.prototype.slice.call(args, 0, args.length - 1)), _.last(args)];
  }
};

Bacon.combineAsArray = function () {
  var streams = argumentsToObservables(arguments);
  if (streams.length) {
    var sources = [];
    for (var i = 0; i < streams.length; i++) {
      var stream = isObservable(streams[i]) ? streams[i] : Bacon.constant(streams[i]);
      sources.push(new Source(stream, true));
    }
    return withDesc(new Bacon.Desc(Bacon, "combineAsArray", streams), Bacon.when(sources, function () {
      for (var _len9 = arguments.length, xs = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        xs[_key9] = arguments[_key9];
      }

      return xs;
    }).toProperty());
  } else {
    return Bacon.constant([]);
  }
};

Bacon.onValues = function () {
  return Bacon.combineAsArray(Array.prototype.slice.call(arguments, 0, arguments.length - 1)).onValues(arguments[arguments.length - 1]);
};

Bacon.combineWith = function () {
  var _argumentsToObservablesAndFunction = argumentsToObservablesAndFunction(arguments);

  var streams = _argumentsToObservablesAndFunction[0];
  var f = _argumentsToObservablesAndFunction[1];

  var desc = new Bacon.Desc(Bacon, "combineWith", [f].concat(streams));
  return withDesc(desc, Bacon.combineAsArray(streams).map(function (values) {
    return f.apply(undefined, values);
  }));
};

Bacon.Observable.prototype.combine = function (other, f) {
  var combinator = toCombinator(f);
  var desc = new Bacon.Desc(this, "combine", [other, f]);
  return withDesc(desc, Bacon.combineAsArray(this, other).map(function (values) {
    return combinator(values[0], values[1]);
  }));
};

Bacon.Observable.prototype.withStateMachine = function (initState, f) {
  var state = initState;
  var desc = new Bacon.Desc(this, "withStateMachine", [initState, f]);
  return withDesc(desc, this.withHandler(function (event) {
    var fromF = f(state, event);
    var newState = fromF[0];
    var outputs = fromF[1];

    state = newState;
    var reply = Bacon.more;
    for (var i = 0, output; i < outputs.length; i++) {
      output = outputs[i];
      reply = this.push(output);
      if (reply === Bacon.noMore) {
        return reply;
      }
    }
    return reply;
  }));
};

var equals = function (a, b) {
  return a === b;
};

var isNone = function (object) {
  return typeof object !== "undefined" && object !== null ? object._isNone : false;
};

Bacon.Observable.prototype.skipDuplicates = function () {
  var isEqual = arguments.length <= 0 || arguments[0] === undefined ? equals : arguments[0];

  var desc = new Bacon.Desc(this, "skipDuplicates", []);
  return withDesc(desc, this.withStateMachine(None, function (prev, event) {
    if (!event.hasValue()) {
      return [prev, [event]];
    } else if (event.isInitial() || isNone(prev) || !isEqual(prev.get(), event.value())) {
      return [new Some(event.value()), [event]];
    } else {
      return [prev, []];
    }
  }));
};

Bacon.Observable.prototype.awaiting = function (other) {
  var desc = new Bacon.Desc(this, "awaiting", [other]);
  return withDesc(desc, Bacon.groupSimultaneous(this, other).map(function (values) {
    return values[1].length === 0;
  }).toProperty(false).skipDuplicates());
};

Bacon.Observable.prototype.not = function () {
  return withDesc(new Bacon.Desc(this, "not", []), this.map(function (x) {
    return !x;
  }));
};

Bacon.Property.prototype.and = function (other) {
  return withDesc(new Bacon.Desc(this, "and", [other]), this.combine(other, function (x, y) {
    return x && y;
  }));
};

Bacon.Property.prototype.or = function (other) {
  return withDesc(new Bacon.Desc(this, "or", [other]), this.combine(other, function (x, y) {
    return x || y;
  }));
};

Bacon.scheduler = {
  setTimeout: function (f, d) {
    return setTimeout(f, d);
  },
  setInterval: function (f, i) {
    return setInterval(f, i);
  },
  clearInterval: function (id) {
    return clearInterval(id);
  },
  clearTimeout: function (id) {
    return clearTimeout(id);
  },
  now: function () {
    return new Date().getTime();
  }
};

Bacon.EventStream.prototype.bufferWithTime = function (delay) {
  return withDesc(new Bacon.Desc(this, "bufferWithTime", [delay]), this.bufferWithTimeOrCount(delay, Number.MAX_VALUE));
};

Bacon.EventStream.prototype.bufferWithCount = function (count) {
  return withDesc(new Bacon.Desc(this, "bufferWithCount", [count]), this.bufferWithTimeOrCount(undefined, count));
};

Bacon.EventStream.prototype.bufferWithTimeOrCount = function (delay, count) {
  var flushOrSchedule = function (buffer) {
    if (buffer.values.length === count) {
      return buffer.flush();
    } else if (delay !== undefined) {
      return buffer.schedule();
    }
  };
  var desc = new Bacon.Desc(this, "bufferWithTimeOrCount", [delay, count]);
  return withDesc(desc, this.buffer(delay, flushOrSchedule, flushOrSchedule));
};

Bacon.EventStream.prototype.buffer = function (delay) {
  var onInput = arguments.length <= 1 || arguments[1] === undefined ? nop : arguments[1];
  var onFlush = arguments.length <= 2 || arguments[2] === undefined ? nop : arguments[2];

  var buffer = {
    scheduled: null,
    end: undefined,
    values: [],
    flush: function () {
      if (this.scheduled) {
        Bacon.scheduler.clearTimeout(this.scheduled);
        this.scheduled = null;
      }
      if (this.values.length > 0) {
        var valuesToPush = this.values;
        this.values = [];
        var reply = this.push(nextEvent(valuesToPush));
        if (this.end != null) {
          return this.push(this.end);
        } else if (reply !== Bacon.noMore) {
          return onFlush(this);
        }
      } else {
        if (this.end != null) {
          return this.push(this.end);
        }
      }
    },
    schedule: function () {
      var _this6 = this;

      if (!this.scheduled) {
        return this.scheduled = delay(function () {
          return _this6.flush();
        });
      }
    }
  };
  var reply = Bacon.more;
  if (!_.isFunction(delay)) {
    var delayMs = delay;
    delay = function (f) {
      return Bacon.scheduler.setTimeout(f, delayMs);
    };
  }
  return withDesc(new Bacon.Desc(this, "buffer", []), this.withHandler(function (event) {
    var _this7 = this;

    buffer.push = function (event) {
      return _this7.push(event);
    };
    if (event.isError()) {
      reply = this.push(event);
    } else if (event.isEnd()) {
      buffer.end = event;
      if (!buffer.scheduled) {
        buffer.flush();
      }
    } else {
      buffer.values.push(event.value());

      onInput(buffer);
    }
    return reply;
  }));
};

Bacon.Observable.prototype.filter = function (f) {
  assertObservableIsProperty(f);

  for (var _len10 = arguments.length, args = Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
    args[_key10 - 1] = arguments[_key10];
  }

  return convertArgsToFunction(this, f, args, function (f) {
    return withDesc(new Bacon.Desc(this, "filter", [f]), this.withHandler(function (event) {
      if (event.filter(f)) {
        return this.push(event);
      } else {
        return Bacon.more;
      }
    }));
  });
};

Bacon.once = function (value) {
  return new EventStream(new Desc(Bacon, "once", [value]), function (sink) {
    sink(toEvent(value));
    sink(endEvent());
    return nop;
  });
};

Bacon.EventStream.prototype.concat = function (right) {
  var left = this;
  return new EventStream(new Bacon.Desc(left, "concat", [right]), function (sink) {
    var unsubRight = nop;
    var unsubLeft = left.dispatcher.subscribe(function (e) {
      if (e.isEnd()) {
        unsubRight = right.toEventStream().dispatcher.subscribe(sink);
        return unsubRight;
      } else {
        return sink(e);
      }
    });
    return function () {
      return unsubLeft(), unsubRight();
    };
  });
};

Bacon.Property.prototype.concat = function (right) {
  return addPropertyInitValueToStream(this, this.changes().concat(right));
};

Bacon.concatAll = function () {
  var streams = argumentsToObservables(arguments);
  if (streams.length) {
    return withDesc(new Bacon.Desc(Bacon, "concatAll", streams), _.fold(_.tail(streams), _.head(streams).toEventStream(), function (a, b) {
      return a.concat(b);
    }));
  } else {
    return Bacon.never();
  }
};

var addPropertyInitValueToStream = function (property, stream) {
  var justInitValue = new EventStream(describe(property, "justInitValue"), function (sink) {
    var value = undefined;
    var unsub = property.dispatcher.subscribe(function (event) {
      if (!event.isEnd()) {
        value = event;
      }
      return Bacon.noMore;
    });
    UpdateBarrier.whenDoneWith(justInitValue, function () {
      if (typeof value !== "undefined" && value !== null) {
        sink(value);
      }
      return sink(endEvent());
    });
    return unsub;
  });
  return justInitValue.concat(stream).toProperty();
};

Bacon.Observable.prototype.flatMap = function () {
  return flatMap_(this, makeSpawner(arguments));
};

Bacon.Observable.prototype.flatMapFirst = function () {
  return flatMap_(this, makeSpawner(arguments), true);
};

var makeSpawner = function (args) {
  if (args.length === 1 && isObservable(args[0])) {
    return _.always(args[0]);
  } else {
    return makeFunctionArgs(args);
  }
};

var makeObservable = function (x) {
  if (isObservable(x)) {
    return x;
  } else {
    return Bacon.once(x);
  }
};

var flatMap_ = function (root, f, firstOnly, limit) {
  var rootDep = [root];
  var childDeps = [];
  var desc = new Bacon.Desc(root, "flatMap" + (firstOnly ? "First" : ""), [f]);
  var result = new EventStream(desc, function (sink) {
    var composite = new CompositeUnsubscribe();
    var queue = [];
    var spawn = function (event) {
      var child = makeObservable(f(event.value()));
      childDeps.push(child);
      return composite.add(function (unsubAll, unsubMe) {
        return child.dispatcher.subscribe(function (event) {
          if (event.isEnd()) {
            _.remove(child, childDeps);
            checkQueue();
            checkEnd(unsubMe);
            return Bacon.noMore;
          } else {
            if (typeof event !== "undefined" && event !== null ? event._isInitial : undefined) {
              event = event.toNext();
            }
            var reply = sink(event);
            if (reply === Bacon.noMore) {
              unsubAll();
            }
            return reply;
          }
        });
      });
    };
    var checkQueue = function () {
      var event = queue.shift();
      if (event) {
        return spawn(event);
      }
    };
    var checkEnd = function (unsub) {
      unsub();
      if (composite.empty()) {
        return sink(endEvent());
      }
    };
    composite.add(function (__, unsubRoot) {
      return root.dispatcher.subscribe(function (event) {
        if (event.isEnd()) {
          return checkEnd(unsubRoot);
        } else if (event.isError()) {
          return sink(event);
        } else if (firstOnly && composite.count() > 1) {
          return Bacon.more;
        } else {
          if (composite.unsubscribed) {
            return Bacon.noMore;
          }
          if (limit && composite.count() > limit) {
            return queue.push(event);
          } else {
            return spawn(event);
          }
        }
      });
    });
    return composite.unsubscribe;
  });
  result.internalDeps = function () {
    if (childDeps.length) {
      return rootDep.concat(childDeps);
    } else {
      return rootDep;
    }
  };
  return result;
};

Bacon.Observable.prototype.flatMapWithConcurrencyLimit = function (limit) {
  for (var _len11 = arguments.length, args = Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
    args[_key11 - 1] = arguments[_key11];
  }

  var desc = new Bacon.Desc(this, "flatMapWithConcurrencyLimit", [limit].concat(args));
  return withDesc(desc, flatMap_(this, makeSpawner(args), false, limit));
};

Bacon.Observable.prototype.flatMapConcat = function () {
  var desc = new Bacon.Desc(this, "flatMapConcat", Array.prototype.slice.call(arguments, 0));
  return withDesc(desc, this.flatMapWithConcurrencyLimit.apply(this, [1].concat(_slice.call(arguments))));
};

Bacon.later = function (delay, value) {
  return withDesc(new Bacon.Desc(Bacon, "later", [delay, value]), Bacon.fromBinder(function (sink) {
    var sender = function () {
      return sink([value, endEvent()]);
    };
    var id = Bacon.scheduler.setTimeout(sender, delay);
    return function () {
      return Bacon.scheduler.clearTimeout(id);
    };
  }));
};

Bacon.Observable.prototype.bufferingThrottle = function (minimumInterval) {
  var desc = new Bacon.Desc(this, "bufferingThrottle", [minimumInterval]);
  return withDesc(desc, this.flatMapConcat(function (x) {
    return Bacon.once(x).concat(Bacon.later(minimumInterval).filter(false));
  }));
};

Bacon.Property.prototype.bufferingThrottle = function () {
  return Bacon.Observable.prototype.bufferingThrottle.apply(this, arguments).toProperty();
};

function Bus() {
  if (!(this instanceof Bus)) {
    return new Bus();
  }

  this.unsubAll = _.bind(this.unsubAll, this);
  this.subscribeAll = _.bind(this.subscribeAll, this);
  this.guardedSink = _.bind(this.guardedSink, this);

  this.sink = undefined;
  this.subscriptions = [];
  this.ended = false;
  EventStream.call(this, new Bacon.Desc(Bacon, "Bus", []), this.subscribeAll);
}

inherit(Bus, EventStream);
extend(Bus.prototype, {
  unsubAll: function () {
    var iterable = this.subscriptions;
    for (var i = 0, sub; i < iterable.length; i++) {
      sub = iterable[i];
      if (typeof sub.unsub === "function") {
        sub.unsub();
      }
    }
  },

  subscribeAll: function (newSink) {
    if (this.ended) {
      newSink(endEvent());
    } else {
      this.sink = newSink;
      var iterable = cloneArray(this.subscriptions);
      for (var i = 0, subscription; i < iterable.length; i++) {
        subscription = iterable[i];
        this.subscribeInput(subscription);
      }
    }
    return this.unsubAll;
  },

  guardedSink: function (input) {
    var _this8 = this;

    return function (event) {
      if (event.isEnd()) {
        _this8.unsubscribeInput(input);
        return Bacon.noMore;
      } else {
        return _this8.sink(event);
      }
    };
  },

  subscribeInput: function (subscription) {
    subscription.unsub = subscription.input.dispatcher.subscribe(this.guardedSink(subscription.input));
    return subscription.unsub;
  },

  unsubscribeInput: function (input) {
    var iterable = this.subscriptions;
    for (var i = 0, sub; i < iterable.length; i++) {
      sub = iterable[i];
      if (sub.input === input) {
        if (typeof sub.unsub === "function") {
          sub.unsub();
        }
        this.subscriptions.splice(i, 1);
        return;
      }
    }
  },

  plug: function (input) {
    var _this9 = this;

    assertObservable(input);
    if (this.ended) {
      return;
    }
    var sub = { input: input };
    this.subscriptions.push(sub);
    if (typeof this.sink !== "undefined") {
      this.subscribeInput(sub);
    }
    return function () {
      return _this9.unsubscribeInput(input);
    };
  },

  end: function () {
    this.ended = true;
    this.unsubAll();
    if (typeof this.sink === "function") {
      return this.sink(endEvent());
    }
  },

  push: function (value) {
    if (!this.ended && typeof this.sink === "function") {
      var rootPush = !this.pushing;
      if (!rootPush) {
        if (!this.pushQueue) this.pushQueue = [];
        this.pushQueue.push(value);

        return;
      }
      this.pushing = true;
      try {
        return this.sink(nextEvent(value));
      } finally {
        if (rootPush && this.pushQueue) {
          var i = 0;
          while (i < this.pushQueue.length) {
            var value = this.pushQueue[i];
            this.sink(nextEvent(value));
            i++;
          }
          this.pushQueue = null;
        }
        this.pushing = false;
      }
    }
  },

  error: function (error) {
    if (typeof this.sink === "function") {
      return this.sink(new Error(error));
    }
  }
});

Bacon.Bus = Bus;

var liftCallback = function (desc, wrapped) {
  return withMethodCallSupport(function (f) {
    var stream = partiallyApplied(wrapped, [function (values, callback) {
      return f.apply(undefined, values.concat([callback]));
    }]);

    for (var _len12 = arguments.length, args = Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
      args[_key12 - 1] = arguments[_key12];
    }

    return withDesc(new Bacon.Desc(Bacon, desc, [f].concat(args)), Bacon.combineAsArray(args).flatMap(stream));
  });
};

Bacon.fromCallback = liftCallback("fromCallback", function (f) {
  for (var _len13 = arguments.length, args = Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
    args[_key13 - 1] = arguments[_key13];
  }

  return Bacon.fromBinder(function (handler) {
    makeFunction(f, args)(handler);
    return nop;
  }, function (value) {
    return [value, endEvent()];
  });
});

Bacon.fromNodeCallback = liftCallback("fromNodeCallback", function (f) {
  for (var _len14 = arguments.length, args = Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
    args[_key14 - 1] = arguments[_key14];
  }

  return Bacon.fromBinder(function (handler) {
    makeFunction(f, args)(handler);
    return nop;
  }, function (error, value) {
    if (error) {
      return [new Error(error), endEvent()];
    }
    return [value, endEvent()];
  });
});

Bacon.combineTemplate = function (template) {
  function current(ctxStack) {
    return ctxStack[ctxStack.length - 1];
  }
  function setValue(ctxStack, key, value) {
    current(ctxStack)[key] = value;
    return value;
  }
  function applyStreamValue(key, index) {
    return function (ctxStack, values) {
      setValue(ctxStack, key, values[index]);
    };
  }
  function constantValue(key, value) {
    return function (ctxStack) {
      setValue(ctxStack, key, value);
    };
  }

  function mkContext(template) {
    return isArray(template) ? [] : {};
  }

  function pushContext(key, value) {
    return function (ctxStack) {
      var newContext = mkContext(value);
      setValue(ctxStack, key, newContext);
      ctxStack.push(newContext);
    };
  }

  function containsObservables(value) {
    if (isObservable(value)) {
      return true;
    } else if (value && (value.constructor == Object || value.constructor == Array)) {
      for (var key in value) {
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          var child = value[key];
          if (containsObservables(child)) return true;
        }
      }
    }
  }

  function compile(key, value) {
    if (isObservable(value)) {
      streams.push(value);
      funcs.push(applyStreamValue(key, streams.length - 1));
    } else if (containsObservables(value)) {
      var popContext = function (ctxStack) {
        ctxStack.pop();
      };
      funcs.push(pushContext(key, value));
      compileTemplate(value);
      funcs.push(popContext);
    } else {
      funcs.push(constantValue(key, value));
    }
  }

  function combinator(values) {
    var rootContext = mkContext(template);
    var ctxStack = [rootContext];
    for (var i = 0, f; i < funcs.length; i++) {
      f = funcs[i];
      f(ctxStack, values);
    }
    return rootContext;
  }

  function compileTemplate(template) {
    _.each(template, compile);
  }

  var funcs = [];
  var streams = [];

  var resultProperty = containsObservables(template) ? (compileTemplate(template), Bacon.combineAsArray(streams).map(combinator)) : Bacon.constant(template);

  return withDesc(new Bacon.Desc(Bacon, "combineTemplate", [template]), resultProperty);
};

Bacon.Observable.prototype.mapEnd = function () {
  var f = makeFunctionArgs(arguments);
  return withDesc(new Bacon.Desc(this, "mapEnd", [f]), this.withHandler(function (event) {
    if (event.isEnd()) {
      this.push(nextEvent(f(event)));
      this.push(endEvent());
      return Bacon.noMore;
    } else {
      return this.push(event);
    }
  }));
};

Bacon.Observable.prototype.skipErrors = function () {
  return withDesc(new Bacon.Desc(this, "skipErrors", []), this.withHandler(function (event) {
    if (event.isError()) {
      return Bacon.more;
    } else {
      return this.push(event);
    }
  }));
};

Bacon.EventStream.prototype.takeUntil = function (stopper) {
  var endMarker = {};
  return withDesc(new Bacon.Desc(this, "takeUntil", [stopper]), Bacon.groupSimultaneous(this.mapEnd(endMarker), stopper.skipErrors()).withHandler(function (event) {
    if (!event.hasValue()) {
      return this.push(event);
    } else {
      var _event$value = event.value();

      var data = _event$value[0];
      var stopper = _event$value[1];

      if (stopper.length) {
        return this.push(endEvent());
      } else {
        var reply = Bacon.more;
        for (var i = 0, value; i < data.length; i++) {
          value = data[i];
          if (value === endMarker) {
            reply = this.push(endEvent());
          } else {
            reply = this.push(nextEvent(value));
          }
        }
        return reply;
      }
    }
  }));
};

Bacon.Property.prototype.takeUntil = function (stopper) {
  var changes = this.changes().takeUntil(stopper);
  return withDesc(new Bacon.Desc(this, "takeUntil", [stopper]), addPropertyInitValueToStream(this, changes));
};

Bacon.Observable.prototype.flatMapLatest = function () {
  var f = makeSpawner(arguments);
  var stream = this.toEventStream();
  return withDesc(new Bacon.Desc(this, "flatMapLatest", [f]), stream.flatMap(function (value) {
    return makeObservable(f(value)).takeUntil(stream);
  }));
};

Bacon.Property.prototype.delayChanges = function (desc, f) {
  return withDesc(desc, addPropertyInitValueToStream(this, f(this.changes())));
};

Bacon.EventStream.prototype.delayChanges = function (desc, f) {
  return withDesc(desc, f(this));
};

Bacon.Observable.prototype.delay = function (delay) {
  return this.delayChanges(new Bacon.Desc(this, "delay", [delay]), function (changes) {
    return changes.flatMap(function (value) {
      return Bacon.later(delay, value);
    });
  });
};

Bacon.Observable.prototype.debounce = function (delay) {
  return this.delayChanges(new Bacon.Desc(this, "debounce", [delay]), function (changes) {
    return changes.flatMapLatest(function (value) {
      return Bacon.later(delay, value);
    });
  });
};

Bacon.Observable.prototype.debounceImmediate = function (delay) {
  return this.delayChanges(new Bacon.Desc(this, "debounceImmediate", [delay]), function (changes) {
    return changes.flatMapFirst(function (value) {
      return Bacon.once(value).concat(Bacon.later(delay).filter(false));
    });
  });
};

Bacon.Observable.prototype.decode = function (cases) {
  return withDesc(new Bacon.Desc(this, "decode", [cases]), this.combine(Bacon.combineTemplate(cases), function (key, values) {
    return values[key];
  }));
};

Bacon.Observable.prototype.scan = function (seed, f) {
  var _this10 = this;

  var resultProperty;
  f = toCombinator(f);
  var acc = toOption(seed);
  var initHandled = false;
  var subscribe = function (sink) {
    var initSent = false;
    var unsub = nop;
    var reply = Bacon.more;
    var sendInit = function () {
      if (!initSent) {
        return acc.forEach(function (value) {
          initSent = initHandled = true;
          reply = sink(new Initial(function () {
            return value;
          }));
          if (reply === Bacon.noMore) {
            unsub();
            unsub = nop;
            return unsub;
          }
        });
      }
    };
    unsub = _this10.dispatcher.subscribe(function (event) {
      if (event.hasValue()) {
        if (initHandled && event.isInitial()) {
          return Bacon.more;
        } else {
            if (!event.isInitial()) {
              sendInit();
            }
            initSent = initHandled = true;
            var prev = acc.getOrElse(undefined);
            var next = f(prev, event.value());

            acc = new Some(next);
            return sink(event.apply(function () {
              return next;
            }));
          }
      } else {
        if (event.isEnd()) {
          reply = sendInit();
        }
        if (reply !== Bacon.noMore) {
          return sink(event);
        }
      }
    });
    UpdateBarrier.whenDoneWith(resultProperty, sendInit);
    return unsub;
  };
  resultProperty = new Property(new Bacon.Desc(this, "scan", [seed, f]), subscribe);
  return resultProperty;
};

Bacon.Observable.prototype.diff = function (start, f) {
  f = toCombinator(f);
  return withDesc(new Bacon.Desc(this, "diff", [start, f]), this.scan([start], function (prevTuple, next) {
    return [next, f(prevTuple[0], next)];
  }).filter(function (tuple) {
    return tuple.length === 2;
  }).map(function (tuple) {
    return tuple[1];
  }));
};

Bacon.Observable.prototype.doAction = function () {
  var f = makeFunctionArgs(arguments);
  return withDesc(new Bacon.Desc(this, "doAction", [f]), this.withHandler(function (event) {
    if (event.hasValue()) {
      f(event.value());
    }
    return this.push(event);
  }));
};

Bacon.Observable.prototype.doEnd = function () {
  var f = makeFunctionArgs(arguments);
  return withDesc(new Bacon.Desc(this, "doEnd", [f]), this.withHandler(function (event) {
    if (event.isEnd()) {
      f();
    }
    return this.push(event);
  }));
};

Bacon.Observable.prototype.doError = function () {
  var f = makeFunctionArgs(arguments);
  return withDesc(new Bacon.Desc(this, "doError", [f]), this.withHandler(function (event) {
    if (event.isError()) {
      f(event.error);
    }
    return this.push(event);
  }));
};

Bacon.Observable.prototype.doLog = function () {
  for (var _len15 = arguments.length, args = Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
    args[_key15] = arguments[_key15];
  }

  return withDesc(new Bacon.Desc(this, "doLog", args), this.withHandler(function (event) {
    if (typeof console !== "undefined" && console !== null && typeof console.log === "function") {
      console.log.apply(console, args.concat([event.log()]));
    }
    return this.push(event);
  }));
};

Bacon.Observable.prototype.endOnError = function (f) {
  if (!(typeof f !== "undefined" && f !== null)) {
    f = true;
  }

  for (var _len16 = arguments.length, args = Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {
    args[_key16 - 1] = arguments[_key16];
  }

  return convertArgsToFunction(this, f, args, function (f) {
    return withDesc(new Bacon.Desc(this, "endOnError", []), this.withHandler(function (event) {
      if (event.isError() && f(event.error)) {
        this.push(event);
        return this.push(endEvent());
      } else {
        return this.push(event);
      }
    }));
  });
};

Observable.prototype.errors = function () {
  return withDesc(new Bacon.Desc(this, "errors", []), this.filter(function () {
    return false;
  }));
};

Bacon.Observable.prototype.take = function (count) {
  if (count <= 0) {
    return Bacon.never();
  }
  return withDesc(new Bacon.Desc(this, "take", [count]), this.withHandler(function (event) {
    if (!event.hasValue()) {
      return this.push(event);
    } else {
      count--;
      if (count > 0) {
        return this.push(event);
      } else {
        if (count === 0) {
          this.push(event);
        }
        this.push(endEvent());
        return Bacon.noMore;
      }
    }
  }));
};

Bacon.Observable.prototype.first = function () {
  return withDesc(new Bacon.Desc(this, "first", []), this.take(1));
};

Bacon.Observable.prototype.mapError = function () {
  var f = makeFunctionArgs(arguments);
  return withDesc(new Bacon.Desc(this, "mapError", [f]), this.withHandler(function (event) {
    if (event.isError()) {
      return this.push(nextEvent(f(event.error)));
    } else {
      return this.push(event);
    }
  }));
};

Bacon.Observable.prototype.flatMapError = function (fn) {
  var desc = new Bacon.Desc(this, "flatMapError", [fn]);
  return withDesc(desc, this.mapError(function (err) {
    return new Error(err);
  }).flatMap(function (x) {
    if (x instanceof Error) {
      return fn(x.error);
    } else {
      return Bacon.once(x);
    }
  }));
};

Bacon.EventStream.prototype.flatScan = function (seed, f) {
  var current = seed;
  return this.flatMapConcat(function (next) {
    return makeObservable(f(current, next)).doAction(function (updated) {
      return current = updated;
    });
  }).toProperty(seed);
};

Bacon.EventStream.prototype.sampledBy = function (sampler, combinator) {
  return withDesc(new Bacon.Desc(this, "sampledBy", [sampler, combinator]), this.toProperty().sampledBy(sampler, combinator));
};

Bacon.Property.prototype.sampledBy = function (sampler, combinator) {
  var lazy = false;
  if (typeof combinator !== "undefined" && combinator !== null) {
    combinator = toCombinator(combinator);
  } else {
    lazy = true;
    combinator = function (f) {
      return f.value();
    };
  }
  var thisSource = new Source(this, false, lazy);
  var samplerSource = new Source(sampler, true, lazy);
  var stream = Bacon.when([thisSource, samplerSource], combinator);
  var result = sampler._isProperty ? stream.toProperty() : stream;
  return withDesc(new Bacon.Desc(this, "sampledBy", [sampler, combinator]), result);
};

Bacon.Property.prototype.sample = function (interval) {
  return withDesc(new Bacon.Desc(this, "sample", [interval]), this.sampledBy(Bacon.interval(interval, {})));
};

Bacon.Observable.prototype.map = function (p) {
  if (p && p._isProperty) {
    return p.sampledBy(this, former);
  } else {
    for (var _len17 = arguments.length, args = Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {
      args[_key17 - 1] = arguments[_key17];
    }

    return convertArgsToFunction(this, p, args, function (f) {
      return withDesc(new Bacon.Desc(this, "map", [f]), this.withHandler(function (event) {
        return this.push(event.fmap(f));
      }));
    });
  }
};

Bacon.Observable.prototype.fold = function (seed, f) {
  return withDesc(new Bacon.Desc(this, "fold", [seed, f]), this.scan(seed, f).sampledBy(this.filter(false).mapEnd().toProperty()));
};

Observable.prototype.reduce = Observable.prototype.fold;

var eventMethods = [["addEventListener", "removeEventListener"], ["addListener", "removeListener"], ["on", "off"], ["bind", "unbind"]];

var findHandlerMethods = function (target) {
  var pair;
  for (var i = 0; i < eventMethods.length; i++) {
    pair = eventMethods[i];
    var methodPair = [target[pair[0]], target[pair[1]]];
    if (methodPair[0] && methodPair[1]) {
      return methodPair;
    }
  }
  for (var j = 0; j < eventMethods.length; j++) {
    pair = eventMethods[j];
    var addListener = target[pair[0]];
    if (addListener) {
      return [addListener, function () {}];
    }
  }
  throw new Error("No suitable event methods in " + target);
};

Bacon.fromEventTarget = function (target, eventName, eventTransformer) {
  var _findHandlerMethods = findHandlerMethods(target);

  var sub = _findHandlerMethods[0];
  var unsub = _findHandlerMethods[1];

  var desc = new Bacon.Desc(Bacon, "fromEvent", [target, eventName]);
  return withDesc(desc, Bacon.fromBinder(function (handler) {
    sub.call(target, eventName, handler);
    return function () {
      return unsub.call(target, eventName, handler);
    };
  }, eventTransformer));
};

Bacon.fromEvent = Bacon.fromEventTarget;

Bacon.fromPoll = function (delay, poll) {
  var desc = new Bacon.Desc(Bacon, "fromPoll", [delay, poll]);
  return withDesc(desc, Bacon.fromBinder(function (handler) {
    var id = Bacon.scheduler.setInterval(handler, delay);
    return function () {
      return Bacon.scheduler.clearInterval(id);
    };
  }, poll));
};

function valueAndEnd(value) {
  return [value, endEvent()];
}

Bacon.fromPromise = function (promise, abort) {
  var eventTransformer = arguments.length <= 2 || arguments[2] === undefined ? valueAndEnd : arguments[2];

  return withDesc(new Bacon.Desc(Bacon, "fromPromise", [promise]), Bacon.fromBinder(function (handler) {
    var bound = promise.then(handler, function (e) {
      return handler(new Error(e));
    });
    if (bound && typeof bound.done === "function") {
      bound.done();
    }

    if (abort) {
      return function () {
        if (typeof promise.abort === "function") {
          return promise.abort();
        }
      };
    } else {
      return function () {};
    }
  }, eventTransformer));
};

Bacon.Observable.prototype.groupBy = function (keyF) {
  var limitF = arguments.length <= 1 || arguments[1] === undefined ? Bacon._.id : arguments[1];

  var streams = {};
  var src = this;
  return src.filter(function (x) {
    return !streams[keyF(x)];
  }).map(function (x) {
    var key = keyF(x);
    var similar = src.filter(function (x) {
      return keyF(x) === key;
    });
    var data = Bacon.once(x).concat(similar);
    var limited = limitF(data, x).withHandler(function (event) {
      this.push(event);
      if (event.isEnd()) {
        return delete streams[key];
      }
    });
    streams[key] = limited;
    return limited;
  });
};

Bacon.fromArray = function (values) {
  assertArray(values);
  if (!values.length) {
    return withDesc(new Bacon.Desc(Bacon, "fromArray", values), Bacon.never());
  } else {
    var i = 0;
    var stream = new EventStream(new Bacon.Desc(Bacon, "fromArray", [values]), function (sink) {
      var unsubd = false;
      var reply = Bacon.more;
      var pushing = false;
      var pushNeeded = false;
      function push() {
        pushNeeded = true;
        if (pushing) {
          return;
        }
        pushing = true;
        while (pushNeeded) {
          pushNeeded = false;
          if (reply !== Bacon.noMore && !unsubd) {
            var value = values[i++];
            reply = sink(toEvent(value));
            if (reply !== Bacon.noMore) {
              if (i === values.length) {
                sink(endEvent());
              } else {
                UpdateBarrier.afterTransaction(stream, push);
              }
            }
          }
        }
        pushing = false;
        return pushing;
      };

      push();
      return function () {
        unsubd = true;
        return unsubd;
      };
    });
    return stream;
  }
};

Bacon.EventStream.prototype.holdWhen = function (valve) {
  var onHold = false;
  var bufferedValues = [];
  var src = this;
  var srcIsEnded = false;
  return new EventStream(new Bacon.Desc(this, "holdWhen", [valve]), function (sink) {
    var composite = new CompositeUnsubscribe();
    var subscribed = false;
    var endIfBothEnded = function (unsub) {
      if (typeof unsub === "function") {
        unsub();
      }
      if (composite.empty() && subscribed) {
        return sink(endEvent());
      }
    };
    composite.add(function (unsubAll, unsubMe) {
      return valve.subscribeInternal(function (event) {
        if (event.hasValue()) {
          onHold = event.value();
          if (!onHold) {
            var toSend = bufferedValues;
            bufferedValues = [];
            return (function () {
              var result = [];
              for (var i = 0, value; i < toSend.length; i++) {
                value = toSend[i];
                result.push(sink(nextEvent(value)));
              }
              if (srcIsEnded) {
                result.push(sink(endEvent()));
                unsubMe();
              }
              return result;
            })();
          }
        } else if (event.isEnd()) {
          return endIfBothEnded(unsubMe);
        } else {
          return sink(event);
        }
      });
    });
    composite.add(function (unsubAll, unsubMe) {
      return src.subscribeInternal(function (event) {
        if (onHold && event.hasValue()) {
          return bufferedValues.push(event.value());
        } else if (event.isEnd() && bufferedValues.length) {
          srcIsEnded = true;
          return endIfBothEnded(unsubMe);
        } else {
          return sink(event);
        }
      });
    });
    subscribed = true;
    endIfBothEnded();
    return composite.unsubscribe;
  });
};

Bacon.interval = function (delay) {
  var value = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  return withDesc(new Bacon.Desc(Bacon, "interval", [delay, value]), Bacon.fromPoll(delay, function () {
    return nextEvent(value);
  }));
};

Bacon.$ = {};
Bacon.$.asEventStream = function (eventName, selector, eventTransformer) {
  var _this11 = this;

  if (_.isFunction(selector)) {
    eventTransformer = selector;
    selector = undefined;
  }

  return withDesc(new Bacon.Desc(this.selector || this, "asEventStream", [eventName]), Bacon.fromBinder(function (handler) {
    _this11.on(eventName, selector, handler);
    return function () {
      return _this11.off(eventName, selector, handler);
    };
  }, eventTransformer));
};

if (typeof jQuery !== "undefined" && jQuery) {
  jQuery.fn.asEventStream = Bacon.$.asEventStream;
}

if (typeof Zepto !== "undefined" && Zepto) {
  Zepto.fn.asEventStream = Bacon.$.asEventStream;
}

Bacon.Observable.prototype.last = function () {
  var lastEvent;

  return withDesc(new Bacon.Desc(this, "last", []), this.withHandler(function (event) {
    if (event.isEnd()) {
      if (lastEvent) {
        this.push(lastEvent);
      }
      this.push(endEvent());
      return Bacon.noMore;
    } else {
      lastEvent = event;
    }
  }));
};

Bacon.Observable.prototype.log = function () {
  for (var _len18 = arguments.length, args = Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
    args[_key18] = arguments[_key18];
  }

  this.subscribe(function (event) {
    if (typeof console !== "undefined" && typeof console.log === "function") {
      console.log.apply(console, args.concat([event.log()]));
    }
  });
  return this;
};

Bacon.EventStream.prototype.merge = function (right) {
  assertEventStream(right);
  var left = this;
  return withDesc(new Bacon.Desc(left, "merge", [right]), Bacon.mergeAll(this, right));
};

Bacon.mergeAll = function () {
  var streams = argumentsToObservables(arguments);
  if (streams.length) {
    return new EventStream(new Bacon.Desc(Bacon, "mergeAll", streams), function (sink) {
      var ends = 0;
      var smartSink = function (obs) {
        return function (unsubBoth) {
          return obs.dispatcher.subscribe(function (event) {
            if (event.isEnd()) {
              ends++;
              if (ends === streams.length) {
                return sink(endEvent());
              } else {
                return Bacon.more;
              }
            } else {
              var reply = sink(event);
              if (reply === Bacon.noMore) {
                unsubBoth();
              }
              return reply;
            }
          });
        };
      };
      var sinks = _.map(smartSink, streams);
      return new Bacon.CompositeUnsubscribe(sinks).unsubscribe;
    });
  } else {
    return Bacon.never();
  }
};

Bacon.repeatedly = function (delay, values) {
  var index = 0;
  return withDesc(new Bacon.Desc(Bacon, "repeatedly", [delay, values]), Bacon.fromPoll(delay, function () {
    return values[index++ % values.length];
  }));
};

Bacon.repeat = function (generator) {
  var index = 0;
  return Bacon.fromBinder(function (sink) {
    var flag = false;
    var reply = Bacon.more;
    var unsub = function () {};
    function handleEvent(event) {
      if (event.isEnd()) {
        if (!flag) {
          return flag = true;
        } else {
          return subscribeNext();
        }
      } else {
        return reply = sink(event);
      }
    };
    function subscribeNext() {
      var next;
      flag = true;
      while (flag && reply !== Bacon.noMore) {
        next = generator(index++);
        flag = false;
        if (next) {
          unsub = next.subscribeInternal(handleEvent);
        } else {
          sink(endEvent());
        }
      }
      return flag = true;
    };
    subscribeNext();
    return function () {
      return unsub();
    };
  });
};

Bacon.retry = function (options) {
  if (!_.isFunction(options.source)) {
    throw new Exception("'source' option has to be a function");
  }
  var source = options.source;
  var retries = options.retries || 0;
  var retriesDone = 0;
  var delay = options.delay || function () {
    return 0;
  };
  var isRetryable = options.isRetryable || function () {
    return true;
  };
  var finished = false;
  var error = null;

  return withDesc(new Bacon.Desc(Bacon, "retry", [options]), Bacon.repeat(function (count) {
    function valueStream() {
      return source(count).endOnError().withHandler(function (event) {
        if (event.isError()) {
          error = event;
          if (!(isRetryable(error.error) && (retries === 0 || retriesDone < retries))) {
            finished = true;
            return this.push(event);
          }
        } else {
          if (event.hasValue()) {
            error = null;
            finished = true;
          }
          return this.push(event);
        }
      });
    }

    if (finished) {
      return null;
    } else if (error) {
      var context = {
        error: error.error,
        retriesDone: retriesDone
      };
      var pause = Bacon.later(delay(context)).filter(false);
      retriesDone++;
      return pause.concat(Bacon.once().flatMap(valueStream));
    } else {
      return valueStream();
    }
  }));
};

Bacon.sequentially = function (delay, values) {
  var index = 0;
  return withDesc(new Bacon.Desc(Bacon, "sequentially", [delay, values]), Bacon.fromPoll(delay, function () {
    var value = values[index++];
    if (index < values.length) {
      return value;
    } else if (index === values.length) {
      return [value, endEvent()];
    } else {
      return endEvent();
    }
  }));
};

Bacon.Observable.prototype.skip = function (count) {
  return withDesc(new Bacon.Desc(this, "skip", [count]), this.withHandler(function (event) {
    if (!event.hasValue()) {
      return this.push(event);
    } else if (count > 0) {
      count--;
      return Bacon.more;
    } else {
      return this.push(event);
    }
  }));
};

Bacon.EventStream.prototype.skipUntil = function (starter) {
  var started = starter.take(1).map(true).toProperty(false);
  return withDesc(new Bacon.Desc(this, "skipUntil", [starter]), this.filter(started));
};

Bacon.EventStream.prototype.skipWhile = function (f) {
  assertObservableIsProperty(f);
  var ok = false;

  for (var _len19 = arguments.length, args = Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) {
    args[_key19 - 1] = arguments[_key19];
  }

  return convertArgsToFunction(this, f, args, function (f) {
    return withDesc(new Bacon.Desc(this, "skipWhile", [f]), this.withHandler(function (event) {
      if (ok || !event.hasValue() || !f(event.value())) {
        if (event.hasValue()) {
          ok = true;
        }
        return this.push(event);
      } else {
        return Bacon.more;
      }
    }));
  });
};

Bacon.Observable.prototype.slidingWindow = function (n) {
  var minValues = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

  return withDesc(new Bacon.Desc(this, "slidingWindow", [n, minValues]), this.scan([], function (window, value) {
    return window.concat([value]).slice(-n);
  }).filter(function (values) {
    return values.length >= minValues;
  }));
};

var spies = [];
var registerObs = function (obs) {
  if (spies.length) {
    if (!registerObs.running) {
      try {
        registerObs.running = true;
        spies.forEach(function (spy) {
          spy(obs);
        });
      } finally {
        delete registerObs.running;
      }
    }
  }
};

Bacon.spy = function (spy) {
  return spies.push(spy);
};

Bacon.Property.prototype.startWith = function (seed) {
  return withDesc(new Bacon.Desc(this, "startWith", [seed]), this.scan(seed, function (prev, next) {
    return next;
  }));
};

Bacon.EventStream.prototype.startWith = function (seed) {
  return withDesc(new Bacon.Desc(this, "startWith", [seed]), Bacon.once(seed).concat(this));
};

Bacon.Observable.prototype.takeWhile = function (f) {
  assertObservableIsProperty(f);

  for (var _len20 = arguments.length, args = Array(_len20 > 1 ? _len20 - 1 : 0), _key20 = 1; _key20 < _len20; _key20++) {
    args[_key20 - 1] = arguments[_key20];
  }

  return convertArgsToFunction(this, f, args, function (f) {
    return withDesc(new Bacon.Desc(this, "takeWhile", [f]), this.withHandler(function (event) {
      if (event.filter(f)) {
        return this.push(event);
      } else {
        this.push(endEvent());
        return Bacon.noMore;
      }
    }));
  });
};

Bacon.Observable.prototype.throttle = function (delay) {
  return this.delayChanges(new Bacon.Desc(this, "throttle", [delay]), function (changes) {
    return changes.bufferWithTime(delay).map(function (values) {
      return values[values.length - 1];
    });
  });
};

Observable.prototype.firstToPromise = function (PromiseCtr) {
  var _this12 = this;

  if (typeof PromiseCtr !== "function") {
    if (typeof Promise === "function") {
      PromiseCtr = Promise;
    } else {
      throw new Exception("There isn't default Promise, use shim or parameter");
    }
  }

  return new PromiseCtr(function (resolve, reject) {
    return _this12.subscribe(function (event) {
      if (event.hasValue()) {
        resolve(event.value());
      }
      if (event.isError()) {
        reject(event.error);
      }

      return Bacon.noMore;
    });
  });
};

Observable.prototype.toPromise = function (PromiseCtr) {
  return this.last().firstToPromise(PromiseCtr);
};

Bacon["try"] = function (f) {
  return function (value) {
    try {
      return Bacon.once(f(value));
    } catch (e) {
      return new Bacon.Error(e);
    }
  };
};

Bacon.update = function (initial) {
  function lateBindFirst(f) {
    return function () {
      for (var _len22 = arguments.length, args = Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
        args[_key22] = arguments[_key22];
      }

      return function (i) {
        return f.apply(undefined, [i].concat(args));
      };
    };
  }

  for (var _len21 = arguments.length, patterns = Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) {
    patterns[_key21 - 1] = arguments[_key21];
  }

  var i = patterns.length - 1;
  while (i > 0) {
    if (!(patterns[i] instanceof Function)) {
      patterns[i] = _.always(patterns[i]);
    }
    patterns[i] = lateBindFirst(patterns[i]);
    i = i - 2;
  }
  return withDesc(new Bacon.Desc(Bacon, "update", [initial].concat(patterns)), Bacon.when.apply(Bacon, patterns).scan(initial, function (x, f) {
    return f(x);
  }));
};

Bacon.zipAsArray = function () {
  for (var _len23 = arguments.length, args = Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
    args[_key23] = arguments[_key23];
  }

  var streams = argumentsToObservables(args);
  return withDesc(new Bacon.Desc(Bacon, "zipAsArray", streams), Bacon.zipWith(streams, function () {
    for (var _len24 = arguments.length, xs = Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
      xs[_key24] = arguments[_key24];
    }

    return xs;
  }));
};

Bacon.zipWith = function () {
  for (var _len25 = arguments.length, args = Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
    args[_key25] = arguments[_key25];
  }

  var observablesAndFunction = argumentsToObservablesAndFunction(args);
  var streams = observablesAndFunction[0];
  var f = observablesAndFunction[1];

  streams = _.map(function (s) {
    return s.toEventStream();
  }, streams);
  return withDesc(new Bacon.Desc(Bacon, "zipWith", [f].concat(streams)), Bacon.when(streams, f));
};

Bacon.Observable.prototype.zip = function (other, f) {
  return withDesc(new Bacon.Desc(this, "zip", [other]), Bacon.zipWith([this, other], f || Array));
};

function ESObservable(observable) {
  this.observable = observable;
}

ESObservable.prototype.subscribe = function (observerOrOnNext, onError, onComplete) {
  var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;
  var subscription = {
    closed: false,
    unsubscribe: function () {
      subscription.closed = true;
      cancel();
    }
  };

  var cancel = this.observable.subscribe(function (event) {
    if (event.isError()) {
      if (observer.error) observer.error(event.error);
      subscription.unsubscribe();
    } else if (event.isEnd()) {
      subscription.closed = true;
      if (observer.complete) observer.complete();
    } else if (observer.next) {
      observer.next(event.value());
    }
  });
  return subscription;
};

ESObservable.prototype[symbol('observable')] = function () {
  return this;
};

Bacon.Observable.prototype.toESObservable = function () {
  return new ESObservable(this);
};

Bacon.Observable.prototype[symbol('observable')] = Bacon.Observable.prototype.toESObservable;

Bacon.fromESObservable = function (_observable) {
  var observable;
  if (_observable[symbol("observable")]) {
    observable = _observable[symbol("observable")]();
  } else {
    observable = _observable;
  }

  var desc = new Bacon.Desc(Bacon, "fromESObservable", [observable]);
  return new Bacon.EventStream(desc, function (sink) {
    var cancel = observable.subscribe({
      error: function () {
        sink(new Bacon.Error());
        sink(new Bacon.End());
      },
      next: function (value) {
        sink(new Bacon.Next(value, true));
      },
      complete: function () {
        sink(new Bacon.End());
      }
    });

    if (cancel.unsubscribe) {
      return function () {
        cancel.unsubscribe();
      };
    } else {
      return cancel;
    }
  });
};

if ( true && __webpack_require__(44) !== null && __webpack_require__(45) != null) {
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return Bacon;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  if (typeof this !== "undefined" && this !== null) {
    this.Bacon = Bacon;
  }
} else if ( true && module !== null && module.exports != null) {
  module.exports = Bacon;
  Bacon.Bacon = Bacon;
} else {
    this.Bacon = Bacon;
  }
}).call(this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41), __webpack_require__(66)(module)))

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "dsvFormat", function() { return /* reexport */ dsv["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "csvParse", function() { return /* reexport */ csv["f" /* csvParse */]; });
__webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return /* reexport */ csv["g" /* csvParseRows */]; });
__webpack_require__.d(__webpack_exports__, "csvFormat", function() { return /* reexport */ csv["a" /* csvFormat */]; });
__webpack_require__.d(__webpack_exports__, "csvFormatBody", function() { return /* reexport */ csv["b" /* csvFormatBody */]; });
__webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return /* reexport */ csv["d" /* csvFormatRows */]; });
__webpack_require__.d(__webpack_exports__, "csvFormatRow", function() { return /* reexport */ csv["c" /* csvFormatRow */]; });
__webpack_require__.d(__webpack_exports__, "csvFormatValue", function() { return /* reexport */ csv["e" /* csvFormatValue */]; });
__webpack_require__.d(__webpack_exports__, "tsvParse", function() { return /* reexport */ tsv["f" /* tsvParse */]; });
__webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return /* reexport */ tsv["g" /* tsvParseRows */]; });
__webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return /* reexport */ tsv["a" /* tsvFormat */]; });
__webpack_require__.d(__webpack_exports__, "tsvFormatBody", function() { return /* reexport */ tsv["b" /* tsvFormatBody */]; });
__webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return /* reexport */ tsv["d" /* tsvFormatRows */]; });
__webpack_require__.d(__webpack_exports__, "tsvFormatRow", function() { return /* reexport */ tsv["c" /* tsvFormatRow */]; });
__webpack_require__.d(__webpack_exports__, "tsvFormatValue", function() { return /* reexport */ tsv["e" /* tsvFormatValue */]; });
__webpack_require__.d(__webpack_exports__, "autoType", function() { return /* reexport */ autoType; });

// EXTERNAL MODULE: ./node_modules/d3-dsv/src/dsv.js
var dsv = __webpack_require__(23);

// EXTERNAL MODULE: ./node_modules/d3-dsv/src/csv.js
var csv = __webpack_require__(14);

// EXTERNAL MODULE: ./node_modules/d3-dsv/src/tsv.js
var tsv = __webpack_require__(15);

// CONCATENATED MODULE: ./node_modules/d3-dsv/src/autoType.js
function autoType(object) {
  for (var key in object) {
    var value = object[key].trim(), number, m;
    if (!value) value = null;
    else if (value === "true") value = true;
    else if (value === "false") value = false;
    else if (value === "NaN") value = NaN;
    else if (!isNaN(number = +value)) value = number;
    else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    }
    else continue;
    object[key] = value;
  }
  return object;
}

// https://github.com/d3/d3-dsv/issues/45
var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
// CONCATENATED MODULE: ./node_modules/d3-dsv/src/index.js






/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * For documentation of this class, see docs/javascript_api.rst
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

/** @jsx h */


// Include custom font set for icons


// Include GUI CSS normally with webpack


// Import CSS as a string to embed. This also works from lib because css/src get
// uploaded to NPM.
// eslint-disable-next-line import/no-webpack-loader-syntax


var _utils = __webpack_require__(4);

var utils = _interopRequireWildcard(_utils);

var _BuildInput = __webpack_require__(60);

var _BuildInput2 = _interopRequireDefault(_BuildInput);

var _ZoomContainer = __webpack_require__(46);

var _ZoomContainer2 = _interopRequireDefault(_ZoomContainer);

var _Map = __webpack_require__(47);

var _Map2 = _interopRequireDefault(_Map);

var _CobraModel = __webpack_require__(36);

var _CobraModel2 = _interopRequireDefault(_CobraModel);

var _Brush = __webpack_require__(67);

var _Brush2 = _interopRequireDefault(_Brush);

var _CallbackManager = __webpack_require__(21);

var _CallbackManager2 = _interopRequireDefault(_CallbackManager);

var _Settings = __webpack_require__(55);

var _Settings2 = _interopRequireDefault(_Settings);

var _TextEditInput = __webpack_require__(68);

var _TextEditInput2 = _interopRequireDefault(_TextEditInput);

var _dataStyles = __webpack_require__(20);

var dataStyles = _interopRequireWildcard(_dataStyles);

var _renderWrapper = __webpack_require__(56);

var _renderWrapper2 = _interopRequireDefault(_renderWrapper);

var _SettingsMenu = __webpack_require__(69);

var _SettingsMenu2 = _interopRequireDefault(_SettingsMenu);

var _MenuBar = __webpack_require__(83);

var _MenuBar2 = _interopRequireDefault(_MenuBar);

var _SearchBar = __webpack_require__(88);

var _SearchBar2 = _interopRequireDefault(_SearchBar);

var _ButtonPanel = __webpack_require__(91);

var _ButtonPanel2 = _interopRequireDefault(_ButtonPanel);

var _TooltipContainer = __webpack_require__(94);

var _TooltipContainer2 = _interopRequireDefault(_TooltipContainer);

var _DefaultTooltip = __webpack_require__(95);

var _DefaultTooltip2 = _interopRequireDefault(_DefaultTooltip);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

var _d3Selection = __webpack_require__(2);

__webpack_require__(98);

__webpack_require__(106);

var _BuilderEmbed = __webpack_require__(108);

var _BuilderEmbed2 = _interopRequireDefault(_BuilderEmbed);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Builder = function () {
  function Builder(mapData, modelData, embeddedCss, selection, options) {
    var _this = this;

    _classCallCheck(this, Builder);

    // Defaults
    if (!selection) {
      selection = (0, _d3Selection.select)('body').append('div');
    } else if (selection instanceof _d3Selection.selection) {
      // D3 V4 selection
    } else if ('node' in selection) {
      // If user passes in a selection from an different d3 version/instance,
      // then reselect.
      selection = (0, _d3Selection.select)(selection.node());
    } else {
      // HTML Element
      selection = (0, _d3Selection.select)(selection);
    }
    if (!options) {
      options = {};
    }
    if (!embeddedCss) {
      embeddedCss = _BuilderEmbed2.default;
    }

    this.map_data = mapData;
    this.model_data = modelData;
    this.embeddedCss = embeddedCss;
    this.selection = selection;
    this.menu_div = null;
    this.button_div = null;
    this.search_bar_div = null;
    this.searchBarRef = null;
    this.semanticOptions = null;
    this.mode = 'zoom';

    // apply this object as data for the selection
    this.selection.datum(this);
    this.selection.__builder__ = this;

    // Remember if the user provided a custom value for reaction_styles
    this.has_custom_reaction_styles = Boolean(options.reaction_styles);

    // set defaults
    var optionsWithDefaults = utils.set_options(options, {
      // view options
      menu: 'all',
      scroll_behavior: 'pan',
      use_3d_transform: false,
      enable_editing: true,
      enable_keys: true,
      enable_search: true,
      fill_screen: false,
      zoom_to_element: null,
      full_screen_button: false,
      ignore_bootstrap: false,
      disabled_buttons: null,
      semantic_zoom: null,
      // map, model, and styles
      starting_reaction: null,
      never_ask_before_quit: false,
      unique_map_id: null, // deprecated
      primary_metabolite_radius: 20,
      secondary_metabolite_radius: 10,
      marker_radius: 5,
      gene_font_size: 18,
      hide_secondary_metabolites: false,
      show_gene_reaction_rules: false,
      hide_all_labels: false,
      canvas_size_and_loc: null,
      // applied data
      // reaction
      reaction_data: null,
      reaction_styles: ['color', 'size', 'text'],
      reaction_compare_style: 'log2_fold',
      reaction_scale: null,
      reaction_scale_preset: 'GaBuGeRd',
      reaction_no_data_color: '#dcdcdc',
      reaction_no_data_size: 8,
      // gene
      gene_data: null,
      and_method_in_gene_reaction_rule: 'mean',
      // metabolite
      metabolite_data: null,
      metabolite_styles: ['color', 'size', 'text'],
      metabolite_compare_style: 'log2_fold',
      metabolite_scale: null,
      metabolite_scale_preset: 'WhYlRd',
      metabolite_no_data_color: '#ffffff',
      metabolite_no_data_size: 10,
      // View and build options
      identifiers_on_map: 'bigg_id',
      highlight_missing: false,
      allow_building_duplicate_reactions: false,
      cofactors: ['atp', 'adp', 'nad', 'nadh', 'nadp', 'nadph', 'gtp', 'gdp', 'h', 'coa', 'ump', 'h2o', 'ppi'],
      // Extensions
      tooltip_component: _DefaultTooltip2.default,
      enable_tooltips: ['label'],
      enable_keys_with_tooltip: true,
      // Callbacks
      first_load_callback: null
    }, {
      primary_metabolite_radius: true,
      secondary_metabolite_radius: true,
      marker_radius: true,
      gene_font_size: true,
      reaction_no_data_size: true,
      metabolite_no_data_size: true
    });

    // Check the location
    if (utils.check_for_parent_tag(this.selection, 'svg')) {
      throw new Error('Builder cannot be placed within an svg node ' + 'because UI elements are html-based.');
    }

    // The options that are erased when the settings menu is canceled
    var conditional = ['identifiers_on_map', 'scroll_behavior', 'hide_secondary_metabolites', 'show_gene_reaction_rules', 'hide_all_labels', 'allow_building_duplicate_reactions', 'highlight_missing', 'enable_tooltips', 'reaction_scale_preset', 'reaction_no_data_color', 'reaction_no_data_size', 'reaction_scale', 'reaction_styles', 'reaction_compare_style', 'and_method_in_gene_reaction_rule', 'metabolite_scale_preset', 'metabolite_scale', 'metabolite_styles', 'metabolite_compare_style', 'metabolite_no_data_color', 'metabolite_no_data_size'];
    // this.options and this.settings used to have different functions, but now
    // they are aliases
    this.settings = new _Settings2.default(optionsWithDefaults, conditional);

    // Warn if full/fill screen options conflict
    if (this.settings.get('fill_screen') && this.settings.get('full_screen_button')) {
      this.settings.set('full_screen_button', false);
      console.warn('The option full_screen_button has no effect when fill_screen is true');
    }

    // force full screen for fill_screen option
    this.isFullScreen = false;
    if (this.settings.get('fill_screen')) {
      (0, _d3Selection.select)('html').classed('fill-screen', true);
      (0, _d3Selection.select)('body').classed('fill-screen', true);
      this.selection.classed('fill-screen-div', true);
      this.isFullScreen = true;
    }
    this.savedFullScreenSettings = null;
    this.savedFullScreenParent = null;
    this.clearFullScreenEscape = null;

    // Set up this callback manager
    this.callback_manager = new _CallbackManager2.default();
    var firstLoadCallback = this.settings.get('first_load_callback');
    if (firstLoadCallback !== null) {
      this.callback_manager.set('first_load', function () {
        firstLoadCallback(_this);
      });
    }

    // Set up the zoom container
    this.zoom_container = new _ZoomContainer2.default(this.selection, this.settings.get('scroll_behavior'), this.settings.get('use_3d_transform'));
    // Zoom container status changes
    // this.zoom_container.callbackManager.set('svg_start', () => {
    //   if (this.map) this.map.set_status('Drawing ...')
    // })
    // this.zoom_container.callbackManager.set('svg_finish', () => {
    //   if (this.map) this.map.set_status('')
    // })
    this.zoom_container.callbackManager.set('zoom_change', function () {
      if (_this.settings.get('semantic_zoom')) {
        var scale = _this.zoom_container.windowScale;
        var optionObject = _this.settings.get('semantic_zoom').sort(function (a, b) {
          return a.zoomLevel - b.zoomLevel;
        }).find(function (a) {
          return a.zoomLevel > scale;
        });
        if (optionObject) {
          var didChange = false;
          _underscore2.default.mapObject(optionObject.options, function (value, key) {
            if (_this.settings.get(key) !== value) {
              _this.settings.set(key, value);
              didChange = true;
            }
          });
          if (didChange) _this._updateData(false, true);
        }
      }
    });
    this.settings.streams.use_3d_transform.onValue(function (val) {
      _this.zoom_container.setUse3dTransform(val);
    });
    this.settings.streams.scroll_behavior.onValue(function (val) {
      _this.zoom_container.setScrollBehavior(val);
    });

    // Reactive tooltip settings
    this.settings.streams.enable_tooltips.onValue(function (val) {
      _this._updateTooltipSetting(val);
    });

    // Make a container for other map-related tools that will be reset on map load
    // TODO only create these once in the Builder constructor
    this.mapToolsContainer = this.selection.append('div').attr('class', 'map-tools-container');

    // Status in both modes
    this._createStatus(this.selection);

    // Load the model, map, and update data in both
    this.load_model(this.model_data, false);

    // Append the bars and menu divs to the document
    var s = this.selection.append('div').attr('class', 'search-menu-container').append('div').attr('class', 'search-menu-container-inline');
    this.menu_div = s.append('div');
    this.search_bar_div = s.append('div');
    this.button_div = this.selection.append('div');

    // Need to defer map loading to let webpack CSS load properly. Hack:
    // Delaying 50ms to make sure the css calculations on map size take
    // place.
    _underscore2.default.delay(function () {
      _this.load_map(_this.map_data, false);

      var messageFn = _this._reactionCheckAddAbs();
      _this._updateData(true, true);

      // Setting callbacks. TODO enable atomic updates. Right now, every time the
      // menu closes, everything is drawn.
      _this.settings.statusBus.onValue(function (x) {
        if (x === 'accept') {
          _this._updateData(true, true, ['reaction', 'metabolite'], false);
          if (_this.zoom_container !== null) {
            // TODO make this automatic
            var newBehavior = _this.settings.get('scroll_behavior');
            _this.zoom_container.setScrollBehavior(newBehavior);
          }
          if (_this.map !== null) {
            _this.map.draw_all_nodes(false);
            _this.map.draw_all_reactions(true, false);
            _this.map.select_none();
          }
        }
      });

      if (messageFn !== null) setTimeout(messageFn, 500);

      // Finally run callback
      _underscore2.default.defer(function () {
        return _this.callback_manager.run('first_load', _this);
      });
    }, 50);
  }

  // builder.options is deprecated


  /**
   * For documentation of this function, see docs/javascript_api.rst.
   */
  Builder.prototype.load_model = function load_model(modelData) {
    var shouldUpdateData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    // eslint-disable-line camelcase
    // Check the cobra model
    if (_underscore2.default.isNull(modelData)) {
      this.cobra_model = null;
    } else {
      this.cobra_model = _CobraModel2.default.from_cobra_json(modelData);
    }

    if (this.map) {
      this.map.cobra_model = this.cobra_model;
      if (shouldUpdateData) {
        this._updateData(true, false);
      }
      if (this.settings.get('highlight_missing')) {
        this.map.draw_all_reactions(false, false);
      }
    }

    this.callback_manager.run('load_model', null, modelData, shouldUpdateData);
  };

  /**
   * For documentation of this function, see docs/javascript_api.rst
   */


  Builder.prototype.load_map = function load_map(mapData) {
    var _this2 = this;

    var shouldUpdateData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    // eslint-disable-line camelcase
    // Store map options that might be changed by semantic_zoom function
    var tempSemanticOptions = {};
    if (this.settings.get('semantic_zoom')) {
      for (var _iterator = this.settings.get('semantic_zoom'), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var level = _ref;

        Object.keys(level.options).map(function (option) {
          if (tempSemanticOptions[option] === undefined) {
            tempSemanticOptions[option] = _this2.settings.get(option);
          }
        });
      }
      this.semanticOptions = Object.assign({}, tempSemanticOptions);
    }

    // remove the old map and related divs
    utils.remove_child_nodes(this.zoom_container.zoomedSel);
    utils.remove_child_nodes(this.mapToolsContainer);

    var zoomedSel = this.zoom_container.zoomedSel;
    var svg = this.zoom_container.svg;

    // remove the old map side effects
    if (this.map) {
      this.map.key_manager.toggle(false);
    }

    if (mapData !== null) {
      // import map
      this.map = _Map2.default.from_data(mapData, svg, this.embeddedCss, zoomedSel, this.zoom_container, this.settings, this.cobra_model, this.settings.get('enable_search'));
    } else {
      // new map
      this.map = new _Map2.default(svg, this.embeddedCss, zoomedSel, this.zoom_container, this.settings, this.cobra_model, this.settings.get('canvas_size_and_loc'), this.settings.get('enable_search'));
    }

    // Connect status bar
    this._setupStatus(this.map);
    this.map.set_status('Loading map ...');

    // Connect tooltips
    this._updateTooltipSetting(this.settings.get('enable_tooltips'));

    // Set the data for the map
    if (shouldUpdateData) {
      this._updateData(false, true);
    }

    // Set up the reaction input with complete.ly
    this.build_input = new _BuildInput2.default(this.mapToolsContainer, this.map, this.zoom_container, this.settings);

    // Set up the text edit input
    this.text_edit_input = new _TextEditInput2.default(this.mapToolsContainer, this.map, this.zoom_container);

    // Set up the Brush
    this.brush = new _Brush2.default(zoomedSel, false, this.map, '.canvas-group');
    // reset brush when canvas resizes in brush mode
    this.map.canvas.callbackManager.set('resize', function () {
      if (_this2.mode === 'brush') _this2.brush.toggle(true);
    });

    // Set up menus
    this.setUpSettingsMenu(this.mapToolsContainer);
    this.setUpButtonPanel(this.mapToolsContainer);

    // share a parent container for menu bar and search bar
    var sel = this.mapToolsContainer.append('div').attr('class', 'search-menu-container').append('div').attr('class', 'search-menu-container-inline');
    this.setUpMenuBar(sel);
    this.setUpSearchBar(sel);

    // Set up the tooltip container
    this.tooltip_container = new _TooltipContainer2.default(this.mapToolsContainer, this.settings.get('tooltip_component'), this.zoom_container, this.map, this.settings);

    // Set up key manager
    this.map.key_manager.assignedKeys = this.getKeys();
    // Tell the key manager about the reaction input and search bar
    this.map.key_manager.inputList = [this.build_input, this.searchBarRef, function () {
      return _this2.settingsMenuRef;
    }, this.text_edit_input];
    if (!this.settings.get('enable_keys_with_tooltip')) {
      this.map.key_manager.inputList.push(this.tooltip_container);
    }
    // Make sure the key manager remembers all those changes
    this.map.key_manager.update();
    // Turn it on/off
    this.map.key_manager.toggle(this.settings.get('enable_keys'));
    this.settings.streams.enable_keys.onValue(function (val) {
      // get keys given latest settings
      _this2.map.key_manager.toggle(val);
    });

    // Disable clears
    var newDisabledButtons = this.settings.get('disabled_buttons') || [];
    if (!this.settings.get('reaction_data')) {
      newDisabledButtons.push('Clear reaction data');
    }
    if (!this.settings.get('gene_data')) {
      newDisabledButtons.push('Clear gene data');
    }
    if (!this.settings.get('metabolite_data')) {
      newDisabledButtons.push('Clear metabolite data');
    }
    if (!this.settings.get('enable_search')) {
      newDisabledButtons.push('Find');
    }
    if (!this.settings.get('enable_editing')) {
      newDisabledButtons.push('Show control points');
    }
    this.settings.set('disabled_buttons', newDisabledButtons);

    // Set up selection box
    if (this.settings.get('zoom_to_element')) {
      var type = this.settings.get('zoom_to_element').type;
      var elementId = this.settings.get('zoom_to_element').id;
      if (_underscore2.default.isUndefined(type) || ['reaction', 'node'].indexOf(type) === -1) {
        throw new Error('zoom_to_element type must be "reaction" or "node"');
      }
      if (_underscore2.default.isUndefined(elementId)) {
        throw new Error('zoom_to_element must include id');
      }
      if (type === 'reaction') {
        this.map.zoom_to_reaction(elementId);
      } else if (type === 'node') {
        this.map.zoom_to_node(elementId);
      }
    } else if (mapData) {
      this.map.zoom_extent_canvas();
    } else {
      if (this.settings.get('starting_reaction') && this.cobra_model !== null) {
        // Draw default reaction if no map is provided
        var size = this.zoom_container.get_size();
        var startCoords = { x: size.width / 2, y: size.height / 4 };
        this.map.new_reaction_from_scratch(this.settings.get('starting_reaction'), startCoords, 90);
        this.map.zoom_extent_nodes();
      } else {
        this.map.zoom_extent_canvas();
      }
    }

    // Start in zoom mode for builder, view mode for viewer
    if (this.settings.get('enable_editing')) {
      this.zoom_mode();
    } else {
      this.view_mode();
    }
    // when enabled_editing changes, go to view mode
    this.settings.streams.enable_editing.onValue(function (val) {
      if (val) _this2.zoom_mode();else _this2.view_mode();
    });

    // confirm before leaving the page
    if (this.settings.get('enable_editing')) {
      this._setupConfirmBeforeExit();
    }

    // draw
    this.map.draw_everything();

    this.map.set_status('');

    this.callback_manager.run('load_map', null, mapData, shouldUpdateData);
  };

  /**
   * Function to pass props for the settings menu. Run without an argument to
   * rerender the component
   * @param {Object} props - Props that the settings menu will use
   */


  Builder.prototype.passPropsSettingsMenu = function passPropsSettingsMenu() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this.map.callback_manager.run('pass_props_settings_menu', null, props);
  };

  /**
   * Initialize the settings menu
   */


  Builder.prototype.setUpSettingsMenu = function setUpSettingsMenu(sel) {
    var _this3 = this;

    this.settingsMenuRef = null;
    (0, _renderWrapper2.default)(_SettingsMenu2.default, function (instance) {
      _this3.settingsMenuRef = instance;
    }, function (passProps) {
      return _this3.map.callback_manager.set('pass_props_settings_menu', passProps);
    }, sel.append('div').node());
    this.passPropsSettingsMenu({
      display: false,
      settings: this.settings,
      map: this.map
    });

    // redraw menu when settings change
    _underscore2.default.mapObject(this.settings.streams, function (stream, key) {
      stream.onValue(function (value) {
        _this3.passPropsSettingsMenu();
      });
    });

    // recalculate data when switching to/from absolute value
    this.settings.streams.reaction_styles.map(function (x) {
      return _underscore2.default.contains(x, 'abs');
    }).skipDuplicates().onValue(function () {
      return _this3._updateData(false, true);
    });
    this.settings.streams.metabolite_styles.map(function (x) {
      return _underscore2.default.contains(x, 'abs');
    }).skipDuplicates().onValue(function () {
      return _this3._updateData(false, true);
    });
  };

  /**
   * Function to pass props for the menu bar
   * @param {Object} props - Props that the menu bar will use
   */


  Builder.prototype.passPropsMenuBar = function passPropsMenuBar() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this.map.callback_manager.run('pass_props_menu_bar', null, props);
  };

  /**
   * Initialize the menu bar
   * @param {D3 Selection} sel - The d3 selection to render in.
   */


  Builder.prototype.setUpMenuBar = function setUpMenuBar(sel) {
    var _this4 = this;

    this.menuBarRef = null;
    (0, _renderWrapper2.default)(_MenuBar2.default, function (instance) {
      _this4.menuBarRef = instance;
    }, function (passProps) {
      return _this4.map.callback_manager.set('pass_props_menu_bar', passProps);
    }, sel.append('div').node());
    this.passPropsMenuBar({
      display: this.settings.get('menu') === 'all',
      settings: this.settings,
      sel: this.selection,
      mode: this.mode,
      map: this.map,
      saveMap: function saveMap() {
        // Revert options changed by semanticZoom to their original values if option is active
        if (_this4.semanticOptions) {
          Object.entries(_this4.semanticOptions).map(function (_ref2) {
            var key = _ref2[0],
                value = _ref2[1];

            _this4.settings.set(key, value);
          });
          _this4._updateData();
        }
        _this4.map.save();
      },
      loadMap: function loadMap(file) {
        return _this4.load_map(file);
      },
      assignKeyLoadMap: function assignKeyLoadMap(fn) {
        // connect the key for this input
        _this4.map.key_manager.assignedKeys.load_map.fn = fn;
      },
      save_svg: function save_svg() {
        return _this4.map.save_svg();
      },
      save_png: function save_png() {
        return _this4.map.save_png();
      },
      clear_map: function clear_map() {
        _this4.clear_map();
      },
      loadModel: function loadModel(file) {
        return _this4.load_model(file, true);
      },
      assignKeyLoadModel: function assignKeyLoadModel(fn) {
        // connect the key for this input
        _this4.map.key_manager.assignedKeys.load_model.fn = fn;
      },
      clearModel: function clearModel() {
        _this4.load_model(null);
        _this4.callback_manager.run('clear_model');
      },
      updateRules: function updateRules() {
        return _this4.map.convert_map();
      },
      setReactionData: function setReactionData(d) {
        return _this4.set_reaction_data(d);
      },
      clearReactionData: function clearReactionData() {
        return _this4.set_reaction_data(null);
      },
      setGeneData: function setGeneData(d) {
        return _this4.set_gene_data(d);
      },
      clearGeneData: function clearGeneData() {
        return _this4.set_gene_data(null, true);
      },
      setMetaboliteData: function setMetaboliteData(d) {
        return _this4.set_metabolite_data(d);
      },
      clearMetaboliteData: function clearMetaboliteData(d) {
        return _this4.set_metabolite_data(null);
      },
      setMode: function setMode(mode) {
        return _this4._setMode(mode);
      },
      deleteSelected: function deleteSelected() {
        return _this4.map.delete_selected();
      },
      undo: function undo() {
        return _this4.map.undo_stack.undo();
      },
      redo: function redo() {
        return _this4.map.undo_stack.redo();
      },
      align_vertical: function align_vertical() {
        return _this4.map.align_vertical();
      },
      align_horizontal: function align_horizontal() {
        return _this4.map.align_horizontal();
      },
      togglePrimary: function togglePrimary() {
        return _this4.map.toggle_selected_node_primary();
      },
      cyclePrimary: function cyclePrimary() {
        return _this4.map.cycle_primary_node();
      },
      selectAll: function selectAll() {
        return _this4.map.select_all();
      },
      selectNone: function selectNone() {
        return _this4.map.select_none();
      },
      invertSelection: function invertSelection() {
        return _this4.map.invert_selection();
      },
      zoom_in: function zoom_in() {
        return _this4.zoom_container.zoom_in();
      },
      zoom_out: function zoom_out() {
        return _this4.zoom_container.zoom_out();
      },
      zoomExtentNodes: function zoomExtentNodes() {
        return _this4.map.zoom_extent_nodes();
      },
      zoomExtentCanvas: function zoomExtentCanvas() {
        return _this4.map.zoom_extent_canvas();
      },
      full_screen: function full_screen() {
        return _this4.full_screen();
      },
      search: function search() {
        return _this4.passPropsSearchBar({ display: true });
      },
      toggleBeziers: function toggleBeziers() {
        return _this4.map.toggle_beziers();
      },
      renderSettingsMenu: function renderSettingsMenu() {
        return _this4.passPropsSettingsMenu({ display: true });
      }
    });

    // redraw when beziers change
    this.map.callback_manager.set('toggle_beziers', function () {
      _this4.passPropsMenuBar();
    });

    // redraw when disabledButtons change
    this.settings.streams.disabled_buttons.onValue(function (value) {
      _this4.passPropsMenuBar();
    });

    // redraw when mode changes
    this.callback_manager.set('set_mode', function (mode) {
      _this4.passPropsMenuBar({ mode: mode });
    });

    // redraw when menu option changes
    this.settings.streams.menu.onValue(function (menu) {
      _this4.passPropsMenuBar({ display: menu === 'all' });
    });

    // redraw when full screen button changes
    this.settings.streams.full_screen_button.onValue(function (value) {
      _this4.passPropsMenuBar();
    });
  };

  /**
   * Function to pass props for the search bar
   * @param {Object} props - Props that the search bar will use
   */


  Builder.prototype.passPropsSearchBar = function passPropsSearchBar() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this.map.callback_manager.run('pass_props_search_bar', null, props);
  };

  /**
   * Initialize the search bar
   * @param {D3 Selection} sel - The d3 selection to render in.
   */


  Builder.prototype.setUpSearchBar = function setUpSearchBar(sel) {
    var _this5 = this;

    this.searchBarRef = null;
    (0, _renderWrapper2.default)(_SearchBar2.default, function (instance) {
      _this5.searchBarRef = instance;
    }, function (passProps) {
      return _this5.map.callback_manager.set('pass_props_search_bar', passProps);
    }, sel.append('div').node());
    this.passPropsSearchBar({
      display: false,
      searchIndex: this.map.search_index,
      map: this.map
    });
  };

  /**
   * Function to pass props for the button panel
   * @param {Object} props - Props that the tooltip will use
   */


  Builder.prototype.passPropsButtonPanel = function passPropsButtonPanel() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this.map.callback_manager.run('pass_props_button_panel', null, props);
  };

  /**
   * Initialize the button panel
   */


  Builder.prototype.setUpButtonPanel = function setUpButtonPanel(sel) {
    var _this6 = this;

    (0, _renderWrapper2.default)(_ButtonPanel2.default, null, function (passProps) {
      return _this6.map.callback_manager.set('pass_props_button_panel', passProps);
    }, sel.append('div').node());
    this.passPropsButtonPanel({
      display: _underscore2.default.contains(['all', 'zoom'], this.settings.get('menu')),
      mode: this.mode,
      settings: this.settings,
      setMode: function setMode(mode) {
        return _this6._setMode(mode);
      },
      zoomContainer: this.zoom_container,
      map: this.map,
      buildInput: this.build_input,
      full_screen: function full_screen() {
        return _this6.full_screen();
      }
    });

    // redraw when mode changes
    this.callback_manager.set('set_mode', function (mode) {
      _this6.passPropsButtonPanel({ mode: mode });
    });

    // redraw when full screen button changes
    this.settings.streams.full_screen_button.onValue(function (value) {
      _this6.passPropsButtonPanel();
    });
  };

  /**
   * Set the mode
   */


  Builder.prototype._setMode = function _setMode(mode) {
    this.mode = mode;

    // input
    this.build_input.toggle(mode === 'build');
    this.build_input.direction_arrow.toggle(mode === 'build');
    // brush
    this.brush.toggle(mode === 'brush');
    // zoom
    this.zoom_container.togglePanDrag(mode === 'zoom' || mode === 'view');
    // resize canvas
    this.map.canvas.toggleResize(mode !== 'view');

    // Behavior. Be careful of the order becuase rotation and
    // toggle_selectable_drag both use Behavior.selectableDrag.
    if (mode === 'rotate') {
      this.map.behavior.toggleSelectableDrag(false); // before toggle_rotation_mode
      this.map.behavior.toggleRotationMode(true); // XX
    } else {
      this.map.behavior.toggleRotationMode(mode === 'rotate'); // before toggleSelectableDrag
      this.map.behavior.toggleSelectableDrag(mode === 'brush'); // XX
    }
    this.map.behavior.toggleSelectableClick(mode === 'build' || mode === 'brush'); // XX
    this.map.behavior.toggleLabelDrag(mode === 'brush'); // XX
    this.map.behavior.toggleTextLabelEdit(mode === 'text'); // XX
    this.map.behavior.toggleBezierDrag(mode === 'brush'); // XX

    // edit selections
    if (mode === 'view' || mode === 'text') {
      this.map.select_none();
    }
    if (mode === 'rotate') {
      this.map.deselect_text_labels();
    }

    this.map.draw_everything();
    // what's not allowing me to delete this? XX above

    // callback
    this.callback_manager.run('set_mode', null, mode);
  };

  /** For documentation of this function, see docs/javascript_api.rst. */


  Builder.prototype.view_mode = function view_mode() {
    // eslint-disable-line camelcase
    this.callback_manager.run('view_mode');
    this._setMode('view');
  };

  /** For documentation of this function, see docs/javascript_api.rst. */


  Builder.prototype.build_mode = function build_mode() {
    // eslint-disable-line camelcase
    this.callback_manager.run('build_mode');
    this._setMode('build');
  };

  /** For documentation of this function, see docs/javascript_api.rst. */


  Builder.prototype.brush_mode = function brush_mode() {
    // eslint-disable-line camelcase
    this.callback_manager.run('brush_mode');
    this._setMode('brush');
  };

  /** For documentation of this function, see docs/javascript_api.rst. */


  Builder.prototype.zoom_mode = function zoom_mode() {
    // eslint-disable-line camelcase
    this.callback_manager.run('zoom_mode');
    this._setMode('zoom');
  };

  /** For documentation of this function, see docs/javascript_api.rst. */


  Builder.prototype.rotate_mode = function rotate_mode() {
    // eslint-disable-line camelcase
    this.callback_manager.run('rotate_mode');
    this._setMode('rotate');
  };

  /** For documentation of this function, see docs/javascript_api.rst. */


  Builder.prototype.text_mode = function text_mode() {
    // eslint-disable-line camelcase
    this.callback_manager.run('text_mode');
    this._setMode('text');
  };

  Builder.prototype._reactionCheckAddAbs = function _reactionCheckAddAbs() {
    var _this7 = this;

    var currStyle = this.settings.get('reaction_styles');
    if (this.settings.get('reaction_data') && !this.has_custom_reaction_styles && !_underscore2.default.contains(currStyle, 'abs')) {
      this.settings.set('reaction_styles', currStyle.concat('abs'));
      return function () {
        _this7.map.set_status('Visualizing absolute value of reaction data. ' + 'Change this option in Settings.', 5000);
      };
    }
    return null;
  };

  /**
   * For documentation of this function, see docs/javascript_api.rst.
   */


  Builder.prototype.set_reaction_data = function set_reaction_data(data) {
    // eslint-disable-line camelcase
    this.settings.set('reaction_data', data);

    // clear gene data
    if (data) {
      this.settings._options.gene_data = null;
    }

    var messageFn = this._reactionCheckAddAbs();

    this._updateData(true, true, ['reaction']);

    if (messageFn) messageFn();else this.map.set_status('');

    var disabledButtons = this.settings.get('disabled_buttons') || [];
    var buttonName = 'Clear reaction data';
    var geneButtonName = 'Clear gene data';
    var index = disabledButtons.indexOf(buttonName);
    if (data && index !== -1) {
      disabledButtons.splice(index, 1);
      var gInd = disabledButtons.indexOf(geneButtonName);
      if (gInd === -1) disabledButtons.push(geneButtonName);
      this.settings.set('disabled_buttons', disabledButtons);
    } else if (!data && index === -1) {
      disabledButtons.push(buttonName);
      this.settings.set('disabled_buttons', disabledButtons);
    }
  };

  /**
   * For documentation of this function, see docs/javascript_api.rst.
   */


  Builder.prototype.set_gene_data = function set_gene_data(data) {
    var clearGeneReactionRules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    // eslint-disable-line camelcase
    this.settings.set('gene_data', data);

    if (clearGeneReactionRules) {
      this.settings.set('show_gene_reaction_rules', false);
    }

    // clear reaction data; show gene reaction rules
    if (data) {
      this.settings._options.reaction_data = null;
      this.settings.set('show_gene_reaction_rules', true);
    }

    this._updateData(true, true, ['reaction']);
    this.map.set_status('');

    var disabledButtons = this.settings.get('disabled_buttons') || [];
    var index = disabledButtons.indexOf('Clear gene data');
    var buttonName = 'Clear gene data';
    var reactionButtonName = 'Clear reaction data';
    if (index > -1 && data) {
      disabledButtons.splice(index, 1);
      var rInd = disabledButtons.indexOf('Clear reaction data');
      if (rInd === -1) disabledButtons.push(reactionButtonName);
      this.settings.set('disabled_buttons', disabledButtons);
    } else if (index === -1 && !data) {
      disabledButtons.push(buttonName);
      this.settings.set('disabled_buttons', disabledButtons);
    }
  };

  /**
   * For documentation of this function, see docs/javascript_api.rst.
   */


  Builder.prototype.set_metabolite_data = function set_metabolite_data(data) {
    // eslint-disable-line camelcase
    this.settings.set('metabolite_data', data);

    this._updateData(true, true, ['metabolite']);
    this.map.set_status('');

    var disabledButtons = this.settings.get('disabled_buttons') || [];
    var buttonName = 'Clear metabolite data';
    var index = disabledButtons.indexOf(buttonName);
    if (index > -1 && data) {
      disabledButtons.splice(index, 1);
      this.settings.set('disabled_buttons', disabledButtons);
    } else if (index === -1 && !data) {
      disabledButtons.push(buttonName);
      this.settings.set('disabled_buttons', disabledButtons);
    }
  };

  Builder.prototype._makeGeneDataObject = function _makeGeneDataObject(geneData, cobraModel, map) {
    var allReactions = {};
    if (cobraModel !== null) {
      utils.extend(allReactions, cobraModel.reactions);
    }
    // extend, overwrite
    if (map !== null) {
      utils.extend(allReactions, map.reactions, true);
    }

    // this object has reaction keys and values containing associated genes
    return dataStyles.importAndCheck(geneData, 'gene_data', allReactions);
  };

  /**
   * Clear the map
   */


  Builder.prototype.clear_map = function clear_map() {
    // eslint-disable-line camelcase
    this.callback_manager.run('clear_map');
    this.map.clearMapData();
    this._updateData(true, true, ['reaction', 'metabolite'], false);
    this.map.draw_everything();
  };

  /**
   * Set data and settings for the model.
   * update_model: (Boolean) Update data for the model.
   * update_map: (Boolean) Update data for the map.
   * kind: (Optional, Default: all) An array defining which data is being updated
   * that can include any of: ['reaction', 'metabolite'].
   * should_draw: (Optional, Default: true) Whether to redraw the update sections
   * of the map.
   */


  Builder.prototype._updateData = function _updateData() {
    var updateModel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var updateMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var _this8 = this;

    var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['reaction', 'metabolite'];
    var shouldDraw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    var updateReactionData = _underscore2.default.contains(kind, 'reaction');
    var updateMetaboliteData = _underscore2.default.contains(kind, 'metabolite');
    var metaboliteDataObject = void 0;
    var reactionDataObject = void 0;
    var geneDataObject = void 0;

    // -------------------
    // First map, and draw
    // -------------------

    // metabolite data
    if (updateMetaboliteData && updateMap && this.map !== null) {
      metaboliteDataObject = dataStyles.importAndCheck(this.settings.get('metabolite_data'), 'metabolite_data');
      this.map.apply_metabolite_data_to_map(metaboliteDataObject);
      if (shouldDraw) {
        this.map.draw_all_nodes(false);
      }
    }

    // reaction data
    if (updateReactionData) {
      if (this.settings.get('reaction_data') && updateMap && this.map !== null) {
        reactionDataObject = dataStyles.importAndCheck(this.settings.get('reaction_data'), 'reaction_data');
        this.map.apply_reaction_data_to_map(reactionDataObject);
        if (shouldDraw) {
          this.map.draw_all_reactions(false, false);
        }
      } else if (this.settings.get('gene_data') && updateMap && this.map !== null) {
        geneDataObject = this._makeGeneDataObject(this.settings.get('gene_data'), this.cobra_model, this.map);
        this.map.apply_gene_data_to_map(geneDataObject);
        if (shouldDraw) {
          this.map.draw_all_reactions(false, false);
        }
      } else if (updateMap && this.map !== null) {
        // clear the data
        this.map.apply_reaction_data_to_map(null);
        if (shouldDraw) {
          this.map.draw_all_reactions(false, false);
        }
      }
    }

    // ----------------------------------------------------------------
    // Then the model, after drawing. Delay by 5ms so the the map draws
    // first.
    // ----------------------------------------------------------------

    // If this function runs again, cancel the previous model update
    if (this.update_model_timer) {
      clearTimeout(this.update_model_timer);
    }

    var delay = 5;
    this.update_model_timer = setTimeout(function () {
      // metabolite_data
      if (updateMetaboliteData && updateModel && _this8.cobra_model !== null) {
        // if we haven't already made this
        if (!metaboliteDataObject) {
          metaboliteDataObject = dataStyles.importAndCheck(_this8.settings.get('metabolite_data'), 'metabolite_data');
        }
        _this8.cobra_model.apply_metabolite_data(metaboliteDataObject, _this8.settings.get('metabolite_styles'), _this8.settings.get('metabolite_compare_style'));
      }

      // reaction data
      if (updateReactionData) {
        if (_this8.settings.get('reaction_data') && updateModel && _this8.cobra_model !== null) {
          // if we haven't already made this
          if (!reactionDataObject) {
            reactionDataObject = dataStyles.importAndCheck(_this8.settings.get('reaction_data'), 'reaction_data');
          }
          _this8.cobra_model.apply_reaction_data(reactionDataObject, _this8.settings.get('reaction_styles'), _this8.settings.get('reaction_compare_style'));
        } else if (_this8.settings.get('gene_data') && updateModel && _this8.cobra_model !== null) {
          if (!geneDataObject) {
            geneDataObject = _this8._makeGeneDataObject(_this8.settings.get('gene_data'), _this8.cobra_model, _this8.map);
          }
          _this8.cobra_model.apply_gene_data(geneDataObject, _this8.settings.get('reaction_styles'), _this8.settings.get('identifiers_on_map'), _this8.settings.get('reaction_compare_style'), _this8.settings.get('and_method_in_gene_reaction_rule'));
        } else if (updateModel && _this8.cobra_model !== null) {
          // clear the data
          _this8.cobra_model.apply_reaction_data(null, _this8.settings.get('reaction_styles'), _this8.settings.get('reaction_compare_style'));
        }
      }

      // callback
      _this8.callback_manager.run('update_data', null, updateModel, updateMap, kind, shouldDraw);
    }, delay);
  };

  Builder.prototype._createStatus = function _createStatus(selection) {
    this.status_bar = selection.append('div').attr('id', 'status');
  };

  Builder.prototype._setupStatus = function _setupStatus(map) {
    var _this9 = this;

    map.callback_manager.set('set_status', function (status) {
      return _this9.status_bar.html(status);
    });
  };

  Builder.prototype._updateTooltipSetting = function _updateTooltipSetting(setting) {
    this.map.behavior.toggleLabelMouseover(setting && setting.includes('label'));
    this.map.behavior.toggleObjectMouseover(setting && setting.includes('object'));
  };

  /**
   * Define keyboard shortcuts
   */


  Builder.prototype.getKeys = function getKeys() {
    var _this10 = this;

    var map = this.map;
    var zoom_container = this.zoom_container; // eslint-disable-line camelcase
    return {
      save: {
        key: 'ctrl+s',
        target: map,
        fn: map.save
      },
      save_svg: {
        key: 'ctrl+shift+s',
        target: map,
        fn: map.save_svg
      },
      save_png: {
        key: 'ctrl+shift+p',
        target: map,
        fn: map.save_png
      },
      load_map: {
        key: 'ctrl+o',
        fn: null // defined by button
      },
      convert_map: {
        target: map,
        fn: map.convert_map
      },
      load_model: {
        key: 'ctrl+m',
        fn: null // defined by button
      },
      zoom_in_ctrl: {
        key: 'ctrl+=',
        target: zoom_container,
        fn: zoom_container.zoom_in
      },
      zoom_in: {
        key: '=',
        target: zoom_container,
        fn: zoom_container.zoom_in,
        ignoreWithInput: true
      },
      zoom_out_ctrl: {
        key: 'ctrl+-',
        target: zoom_container,
        fn: zoom_container.zoom_out
      },
      zoom_out: {
        key: '-',
        target: zoom_container,
        fn: zoom_container.zoom_out,
        ignoreWithInput: true
      },
      extent_nodes_ctrl: {
        key: 'ctrl+0',
        target: map,
        fn: map.zoom_extent_nodes
      },
      extent_nodes: {
        key: '0',
        target: map,
        fn: map.zoom_extent_nodes,
        ignoreWithInput: true
      },
      extent_canvas_ctrl: {
        key: 'ctrl+1',
        target: map,
        fn: map.zoom_extent_canvas
      },
      extent_canvas: {
        key: '1',
        target: map,
        fn: map.zoom_extent_canvas,
        ignoreWithInput: true
      },
      view_mode: {
        target: this,
        fn: this.view_mode,
        ignoreWithInput: true
      },
      show_settings_ctrl: {
        key: 'ctrl+,',
        fn: function fn() {
          return _this10.passPropsSettingsMenu({ display: true });
        }
      },
      show_settings: {
        key: ',',
        fn: function fn() {
          return _this10.passPropsSettingsMenu({ display: true });
        },
        ignoreWithInput: true
      },
      build_mode: {
        key: 'n',
        target: this,
        fn: this.build_mode,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      zoom_mode: {
        key: 'z',
        target: this,
        fn: this.zoom_mode,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      brush_mode: {
        key: 'v',
        target: this,
        fn: this.brush_mode,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      rotate_mode: {
        key: 'r',
        target: this,
        fn: this.rotate_mode,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      text_mode: {
        key: 't',
        target: this,
        fn: this.text_mode,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      toggle_beziers: {
        key: 'b',
        target: map,
        fn: map.toggle_beziers,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      delete_ctrl: {
        key: 'ctrl+backspace',
        target: map,
        fn: map.delete_selected,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      delete: {
        key: 'backspace',
        target: map,
        fn: map.delete_selected,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      delete_del: {
        key: 'del',
        target: map,
        fn: map.delete_selected,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      align_vertical: {
        key: 'alt+l',
        target: map,
        fn: map.align_vertical
      },
      align_horizontal: {
        key: 'shift+alt+l',
        target: map,
        fn: map.align_horizontal
      },
      toggle_primary: {
        key: 'p',
        target: map,
        fn: map.toggle_selected_node_primary,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      cycle_primary: {
        key: 'c',
        target: map,
        fn: map.cycle_primary_node,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      direction_arrow_right: {
        key: 'right',
        target: this.build_input.direction_arrow,
        fn: this.build_input.direction_arrow.right,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      direction_arrow_down: {
        key: 'down',
        target: this.build_input.direction_arrow,
        fn: this.build_input.direction_arrow.down,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      direction_arrow_left: {
        key: 'left',
        target: this.build_input.direction_arrow,
        fn: this.build_input.direction_arrow.left,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      direction_arrow_up: {
        key: 'up',
        target: this.build_input.direction_arrow,
        fn: this.build_input.direction_arrow.up,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      undo: {
        key: 'ctrl+z',
        target: map.undo_stack,
        fn: map.undo_stack.undo,
        requires: 'enable_editing'
      },
      redo: {
        key: 'ctrl+shift+z',
        target: map.undo_stack,
        fn: map.undo_stack.redo,
        requires: 'enable_editing'
      },
      select_all: {
        key: 'ctrl+a',
        target: map,
        fn: map.select_all,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      select_none: {
        key: 'ctrl+shift+a',
        target: map,
        fn: map.select_none,
        ignoreWithInput: true,
        requires: 'enable_editing'
      },
      invert_selection: {
        target: map,
        fn: map.invert_selection,
        requires: 'enable_editing'
      },
      search_ctrl: {
        key: 'ctrl+f',
        fn: function fn() {
          return _this10.passPropsSearchBar({ display: true });
        },
        requires: 'enable_search'
      },
      search: {
        key: 'f',
        fn: function fn() {
          return _this10.passPropsSearchBar({ display: true });
        },
        ignoreWithInput: true,
        requires: 'enable_search'
      }
    };
  };

  /**
   * Ask if the user wants to exit the page (to avoid unplanned refresh).
   */


  Builder.prototype._setupConfirmBeforeExit = function _setupConfirmBeforeExit() {
    var _this11 = this;

    window.onbeforeunload = function (_) {
      return _this11.settings.get('never_ask_before_quit') ? null : 'You will lose any unsaved changes.';
    };
  };

  /**
   * Toggle full screen mode.
   */


  Builder.prototype.full_screen = function full_screen() {
    var _this12 = this;

    // eslint-disable-line camelcase
    // these settings can update in full screen if provided
    var fullScreenSettings = ['menu', 'scroll_behavior', 'enable_editing', 'enable_keys', 'enable_tooltips'];

    if (this.isFullScreen) {
      (0, _d3Selection.select)('html').classed('fill-screen', false);
      (0, _d3Selection.select)('body').classed('fill-screen', false);
      this.selection.classed('fill-screen-div', false);
      this.isFullScreen = false;

      // clear escape listener
      if (this.clearFullScreenEscape) {
        this.clearFullScreenEscape();
        this.clearFullScreenEscape = null;
      }

      // hack for full screen in jupyterlab / notebook
      if (this.savedFullScreenParent) {
        var parentNode = this.savedFullScreenParent.node();
        parentNode.insertBefore(this.selection.remove().node(), parentNode.firstChild);
        this.savedFullScreenParent = null;
      }

      // apply the saved settings
      if (this.savedFullScreenSettings !== null) {
        _underscore2.default.mapObject(this.savedFullScreenSettings, function (v, k) {
          _this12.settings.set(k, v);
        });
      }
      this.savedFullScreenSettings = null;
    } else {
      // save current settings
      var fullScreenButton = this.settings.get('full_screen_button');
      if (_underscore2.default.isObject(fullScreenButton)) {
        this.savedFullScreenSettings = _underscore2.default.chain(fullScreenButton).pairs().map(function (_ref3) {
          var k = _ref3[0],
              v = _ref3[1];

          if (_underscore2.default.contains(fullScreenSettings, k)) {
            var currentSetting = _this12.settings.get(k);
            _this12.settings.set(k, v);
            return [k, currentSetting];
          } else {
            console.warn(k + ' not recognized as an option for full_screen_button');
            return [null, null];
          }
        }).filter(function (_ref4) {
          var k = _ref4[0],
              v = _ref4[1];
          return k;
        }).object().value();
      }

      (0, _d3Selection.select)('html').classed('fill-screen', true);
      (0, _d3Selection.select)('body').classed('fill-screen', true);
      this.selection.classed('fill-screen-div', true);
      this.isFullScreen = true;

      // hack for full screen in jupyterlab
      this.savedFullScreenParent = (0, _d3Selection.select)(this.selection.node().parentNode);
      var bodyNode = (0, _d3Selection.select)('body').node();
      bodyNode.insertBefore(this.selection.remove().node(), bodyNode.firstChild);

      // set escape listener
      this.clearFullScreenEscape = this.map.key_manager.addEscapeListener(function () {
        return _this12.full_screen();
      });
    }
    this.map.zoom_extent_canvas();
    this.passPropsButtonPanel({ isFullScreen: this.isFullScreen });
    this.passPropsMenuBar({ isFullScreen: this.isFullScreen });
  };

  _createClass(Builder, [{
    key: 'options',
    get: function get() {
      throw new Error('builder.options is deprecated. Use builder.settings.get() ' + 'and builder.settings.set() instead.');
    },
    set: function set(_) {
      throw new Error('builder.options is deprecated. Use builder.settings.get() ' + 'and builder.settings.set() instead.');
    }
  }]);

  return Builder;
}();

exports.default = utils.class_with_optional_new(Builder);

/***/ }),
/* 40 */
/***/ (function(module, exports) {

/**
* vkBeautify - javascript plugin to pretty-print or minify text in XML, JSON, CSS and SQL formats.
*
* Copyright (c) 2012 Vadim Kiryukhin
* vkiryukhin @ gmail.com
* http://www.eslinstructor.net/vkbeautify/
*
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*
*   Pretty print
*
*        vkbeautify.xml(text [,indent_pattern]);
*        vkbeautify.json(text [,indent_pattern]);
*        vkbeautify.css(text [,indent_pattern]);
*        vkbeautify.sql(text [,indent_pattern]);
*
*        @text - String; text to beatufy;
*        @indent_pattern - Integer | String;
*                Integer:  number of white spaces;
*                String:   character string to visualize indentation ( can also be a set of white spaces )
*   Minify
*
*        vkbeautify.xmlmin(text [,preserve_comments]);
*        vkbeautify.jsonmin(text);
*        vkbeautify.cssmin(text [,preserve_comments]);
*        vkbeautify.sqlmin(text);
*
*        @text - String; text to minify;
*        @preserve_comments - Bool; [optional];
*                Set this flag to true to prevent removing comments from @text ( minxml and mincss functions only. )
*
*   Examples:
*        vkbeautify.xml(text); // pretty print XML
*        vkbeautify.json(text, 4 ); // pretty print JSON
*        vkbeautify.css(text, '. . . .'); // pretty print CSS
*        vkbeautify.sql(text, '----'); // pretty print SQL
*
*        vkbeautify.xmlmin(text, true);// minify XML, preserve comments
*        vkbeautify.jsonmin(text);// minify JSON
*        vkbeautify.cssmin(text);// minify CSS, remove comments ( default )
*        vkbeautify.sqlmin(text);// minify SQL
*
*/
function createShiftArr(step) {

	var space = '    ';

	if ( isNaN(parseInt(step)) ) {  // argument is string
		space = step;
	} else { // argument is integer
		switch(step) {
			case 1: space = ' '; break;
			case 2: space = '  '; break;
			case 3: space = '   '; break;
			case 4: space = '    '; break;
			case 5: space = '     '; break;
			case 6: space = '      '; break;
			case 7: space = '       '; break;
			case 8: space = '        '; break;
			case 9: space = '         '; break;
			case 10: space = '          '; break;
			case 11: space = '           '; break;
			case 12: space = '            '; break;
		}
	}

	var shift = ['\n']; // array of shifts
	for(var ix=0;ix<100;ix++) {
		shift.push(shift[ix]+space);
	}
	return shift;
}

function vkbeautify(){
	this.step = '    '; // 4 spaces
	this.shift = createShiftArr(this.step);
};

vkbeautify.prototype.xml = function(text,step) {

	var ar = text.replace(/>\s{0,}</g,"><")
				 .replace(/</g,"~::~<")
				 .replace(/\s*xmlns\:/g,"~::~xmlns:")
				 .replace(/\s*xmlns\=/g,"~::~xmlns=")
				 .split('~::~'),
		len = ar.length,
		inComment = false,
		deep = 0,
		str = '',
		ix = 0,
		shift = step ? createShiftArr(step) : this.shift;

		for(ix=0;ix<len;ix++) {
			// start comment or <![CDATA[...]]> or <!DOCTYPE //
			if(ar[ix].search(/<!/) > -1) {
				str += shift[deep]+ar[ix];
				inComment = true;
				// end comment  or <![CDATA[...]]> //
				if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) {
					inComment = false;
				}
			} else
			// end comment  or <![CDATA[...]]> //
			if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1) {
				str += ar[ix];
				inComment = false;
			} else
			// <elm></elm> //
			if( /^<\w/.exec(ar[ix-1]) && /^<\/\w/.exec(ar[ix]) &&
				/^<[\w:\-\.\,]+/.exec(ar[ix-1]) == /^<\/[\w:\-\.\,]+/.exec(ar[ix])[0].replace('/','')) {
				str += ar[ix];
				if(!inComment) deep--;
			} else
			 // <elm> //
			if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) == -1 && ar[ix].search(/\/>/) == -1 ) {
				str = !inComment ? str += shift[deep++]+ar[ix] : str += ar[ix];
			} else
			 // <elm>...</elm> //
			if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) > -1) {
				str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
			} else
			// </elm> //
			if(ar[ix].search(/<\//) > -1) {
				str = !inComment ? str += shift[--deep]+ar[ix] : str += ar[ix];
			} else
			// <elm/> //
			if(ar[ix].search(/\/>/) > -1 ) {
				str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
			} else
			// <? xml ... ?> //
			if(ar[ix].search(/<\?/) > -1) {
				str += shift[deep]+ar[ix];
			} else
			// xmlns //
			if( ar[ix].search(/xmlns\:/) > -1  || ar[ix].search(/xmlns\=/) > -1) {
				str += shift[deep]+ar[ix];
			}

			else {
				str += ar[ix];
			}
		}

	return  (str[0] == '\n') ? str.slice(1) : str;
}

vkbeautify.prototype.json = function(text,step) {

	var step = step ? step : this.step;

	if (typeof JSON === 'undefined' ) return text;

	if ( typeof text === "string" ) return JSON.stringify(JSON.parse(text), null, step);
	if ( typeof text === "object" ) return JSON.stringify(text, null, step);

	return text; // text is not string nor object
}

vkbeautify.prototype.css = function(text, step) {

	var ar = text.replace(/\s{1,}/g,' ')
				.replace(/\{/g,"{~::~")
				.replace(/\}/g,"~::~}~::~")
				.replace(/\;/g,";~::~")
				.replace(/\/\*/g,"~::~/*")
				.replace(/\*\//g,"*/~::~")
				.replace(/~::~\s{0,}~::~/g,"~::~")
				.split('~::~'),
		len = ar.length,
		deep = 0,
		str = '',
		ix = 0,
		shift = step ? createShiftArr(step) : this.shift;

		for(ix=0;ix<len;ix++) {

			if( /\{/.exec(ar[ix]))  {
				str += shift[deep++]+ar[ix];
			} else
			if( /\}/.exec(ar[ix]))  {
				str += shift[--deep]+ar[ix];
			} else
			if( /\*\\/.exec(ar[ix]))  {
				str += shift[deep]+ar[ix];
			}
			else {
				str += shift[deep]+ar[ix];
			}
		}
		return str.replace(/^\n{1,}/,'');
}

//----------------------------------------------------------------------------

function isSubquery(str, parenthesisLevel) {
	return  parenthesisLevel - (str.replace(/\(/g,'').length - str.replace(/\)/g,'').length )
}

function split_sql(str, tab) {

	return str.replace(/\s{1,}/g," ")

				.replace(/ AND /ig,"~::~"+tab+tab+"AND ")
				.replace(/ BETWEEN /ig,"~::~"+tab+"BETWEEN ")
				.replace(/ CASE /ig,"~::~"+tab+"CASE ")
				.replace(/ ELSE /ig,"~::~"+tab+"ELSE ")
				.replace(/ END /ig,"~::~"+tab+"END ")
				.replace(/ FROM /ig,"~::~FROM ")
				.replace(/ GROUP\s{1,}BY/ig,"~::~GROUP BY ")
				.replace(/ HAVING /ig,"~::~HAVING ")
				//.replace(/ SET /ig," SET~::~")
				.replace(/ IN /ig," IN ")

				.replace(/ JOIN /ig,"~::~JOIN ")
				.replace(/ CROSS~::~{1,}JOIN /ig,"~::~CROSS JOIN ")
				.replace(/ INNER~::~{1,}JOIN /ig,"~::~INNER JOIN ")
				.replace(/ LEFT~::~{1,}JOIN /ig,"~::~LEFT JOIN ")
				.replace(/ RIGHT~::~{1,}JOIN /ig,"~::~RIGHT JOIN ")

				.replace(/ ON /ig,"~::~"+tab+"ON ")
				.replace(/ OR /ig,"~::~"+tab+tab+"OR ")
				.replace(/ ORDER\s{1,}BY/ig,"~::~ORDER BY ")
				.replace(/ OVER /ig,"~::~"+tab+"OVER ")

				.replace(/\(\s{0,}SELECT /ig,"~::~(SELECT ")
				.replace(/\)\s{0,}SELECT /ig,")~::~SELECT ")

				.replace(/ THEN /ig," THEN~::~"+tab+"")
				.replace(/ UNION /ig,"~::~UNION~::~")
				.replace(/ USING /ig,"~::~USING ")
				.replace(/ WHEN /ig,"~::~"+tab+"WHEN ")
				.replace(/ WHERE /ig,"~::~WHERE ")
				.replace(/ WITH /ig,"~::~WITH ")

				//.replace(/\,\s{0,}\(/ig,",~::~( ")
				//.replace(/\,/ig,",~::~"+tab+tab+"")

				.replace(/ ALL /ig," ALL ")
				.replace(/ AS /ig," AS ")
				.replace(/ ASC /ig," ASC ")
				.replace(/ DESC /ig," DESC ")
				.replace(/ DISTINCT /ig," DISTINCT ")
				.replace(/ EXISTS /ig," EXISTS ")
				.replace(/ NOT /ig," NOT ")
				.replace(/ NULL /ig," NULL ")
				.replace(/ LIKE /ig," LIKE ")
				.replace(/\s{0,}SELECT /ig,"SELECT ")
				.replace(/\s{0,}UPDATE /ig,"UPDATE ")
				.replace(/ SET /ig," SET ")

				.replace(/~::~{1,}/g,"~::~")
				.split('~::~');
}

vkbeautify.prototype.sql = function(text,step) {

	var ar_by_quote = text.replace(/\s{1,}/g," ")
							.replace(/\'/ig,"~::~\'")
							.split('~::~'),
		len = ar_by_quote.length,
		ar = [],
		deep = 0,
		tab = this.step,//+this.step,
		inComment = true,
		inQuote = false,
		parenthesisLevel = 0,
		str = '',
		ix = 0,
		shift = step ? createShiftArr(step) : this.shift;;

		for(ix=0;ix<len;ix++) {
			if(ix%2) {
				ar = ar.concat(ar_by_quote[ix]);
			} else {
				ar = ar.concat(split_sql(ar_by_quote[ix], tab) );
			}
		}

		len = ar.length;
		for(ix=0;ix<len;ix++) {

			parenthesisLevel = isSubquery(ar[ix], parenthesisLevel);

			if( /\s{0,}\s{0,}SELECT\s{0,}/.exec(ar[ix]))  {
				ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"")
			}

			if( /\s{0,}\s{0,}SET\s{0,}/.exec(ar[ix]))  {
				ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"")
			}

			if( /\s{0,}\(\s{0,}SELECT\s{0,}/.exec(ar[ix]))  {
				deep++;
				str += shift[deep]+ar[ix];
			} else
			if( /\'/.exec(ar[ix]) )  {
				if(parenthesisLevel<1 && deep) {
					deep--;
				}
				str += ar[ix];
			}
			else  {
				str += shift[deep]+ar[ix];
				if(parenthesisLevel<1 && deep) {
					deep--;
				}
			}
			var junk = 0;
		}

		str = str.replace(/^\n{1,}/,'').replace(/\n{1,}/g,"\n");
		return str;
}


vkbeautify.prototype.xmlmin = function(text, preserveComments) {

	var str = preserveComments ? text
							   : text.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g,"")
									 .replace(/[ \r\n\t]{1,}xmlns/g, ' xmlns');
	return  str.replace(/>\s{0,}</g,"><");
}

vkbeautify.prototype.jsonmin = function(text) {

	if (typeof JSON === 'undefined' ) return text;

	return JSON.stringify(JSON.parse(text), null, 0);

}

vkbeautify.prototype.cssmin = function(text, preserveComments) {

	var str = preserveComments ? text
							   : text.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g,"") ;

	return str.replace(/\s{1,}/g,' ')
			  .replace(/\{\s{1,}/g,"{")
			  .replace(/\}\s{1,}/g,"}")
			  .replace(/\;\s{1,}/g,";")
			  .replace(/\/\*\s{1,}/g,"/*")
			  .replace(/\*\/\s{1,}/g,"*/");
}

vkbeautify.prototype.sqlmin = function(text) {
	return text.replace(/\s{1,}/g," ").replace(/\s{1,}\(/,"(").replace(/\s{1,}\)/,")");
}

module.exports = new vkbeautify();


/***/ }),
/* 41 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);



/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  var event = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])();
  if (event.changedTouches) event = event.changedTouches[0];
  return Object(_point__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(node, event);
});


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);



/* harmony default export */ __webpack_exports__["a"] = (function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return Object(_point__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(node, touch);
    }
  }

  return null;
});


/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),
/* 45 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(4);

var _utils2 = _interopRequireDefault(_utils);

var _CallbackManager = __webpack_require__(21);

var _CallbackManager2 = _interopRequireDefault(_CallbackManager);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

var _d3Selection = __webpack_require__(2);

var _d3Zoom = __webpack_require__(113);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * ZoomContainer
 */
var ZoomContainer = function () {
  /**
   * Make a container that will manage panning and zooming. Creates a new SVG
   * element, with a parent div for CSS3 3D transforms.
   * @param {D3 Selection} selection - A d3 selection of a HTML node to put the
   * zoom container in. Should have a defined width and height.
   * @param {String} scroll_behavior - Either 'zoom' or 'pan'.
   * @param {Boolean} use3dTransform - If true, then use CSS3 3D transform to
   * speed up pan and zoom.
   */
  function ZoomContainer(selection, scrollBehavior, use3dTransform) {
    _classCallCheck(this, ZoomContainer);

    // set the selection class
    selection.classed('escher-container', true);

    // Stop scrolling on mobile
    // Only necessary for Safari because touch-action CSS is supported by all other browsers
    // TODO Zak needs to figure out why this doesn't work on Safari
    if (navigator && navigator.userAgent && navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Mozilla') === -1) {
      selection.on('touchstart touchmove', function () {
        _d3Selection.event.stopPropagation();
      });
    }

    // make the svg
    var container = selection.append('div').attr('class', 'escher-zoom-container');
    var css3TransformContainer = container.append('div').attr('class', 'escher-3d-transform-container');

    var svg = css3TransformContainer.append('svg').attr('class', 'escher-svg').attr('xmlns', 'http://www.w3.org/2000/svg');

    // set up the zoom container
    svg.select('.zoom-g').remove();
    var zoomedSel = svg.append('g').attr('class', 'zoom-g');

    // attributes
    this.selection = selection;
    this.container = container;
    this.css3TransformContainer = css3TransformContainer;
    this.svg = svg;
    this.zoomedSel = zoomedSel;
    this.windowTranslate = { x: 0, y: 0 };
    this.windowScale = 1.0;

    this._scrollBehavior = scrollBehavior;
    this._use3dTransform = use3dTransform;
    this._panDragOn = true;
    this._zoomBehavior = null;
    this._zoomTimeout = null;
    this._svgScale = this.windowScale;
    this._svgTranslate = this.windowTranslate;
    this._3dTransform = null;
    this._requestedFrame = false;
    // this._lastSvgMs = null

    // set up the callbacks
    this.callbackManager = new _CallbackManager2.default();

    // update the scroll behavior
    this._updateScroll();
  }

  /**
   * Set up pan or zoom on scroll.
   * @param {String} scroll_behavior - 'none', 'pan' or 'zoom'.
   */


  ZoomContainer.prototype.setScrollBehavior = function setScrollBehavior(scrollBehavior) {
    this._scrollBehavior = scrollBehavior;
    this._updateScroll();
  };

  /**
   * Set the option use3dTransform
   */


  ZoomContainer.prototype.setUse3dTransform = function setUse3dTransform(use3dTransform) {
    this._use3dTransform = use3dTransform;
  };

  /**
   * Toggle the zoom drag and the cursor UI for it.
   */


  ZoomContainer.prototype.togglePanDrag = function togglePanDrag(onOff) {
    if (_underscore2.default.isUndefined(onOff)) {
      this._panDragOn = !this._panDragOn;
    } else {
      this._panDragOn = onOff;
    }

    if (this._panDragOn) {
      // turn on the hand. Performance note: In previous versions of Escher, we
      // enabled the "grabbing" cursor during pan events. However, this causes a
      // browser layout and costs about 400ms, so we turned it off.
      this.zoomedSel.style('cursor', 'grab');
    } else {
      // turn off the hand
      if (this.zoomedSel.style('cursor') === 'grab') {
        this.zoomedSel.style('cursor', null);
      }
    }

    // update the behaviors
    this._updateScroll();
  };

  /**
   * Update the pan and zoom behaviors. The behaviors are applied to the
   * css3TransformContainer node.
   */


  ZoomContainer.prototype._updateScroll = function _updateScroll() {
    var _this = this;

    if (!_underscore2.default.contains(['zoom', 'pan', 'none'], this._scrollBehavior)) {
      throw Error('Bad value for scroll_behavior: ' + this._scrollBehavior);
    }

    // clear all behaviors
    this.container.on('mousewheel.zoom', null) // zoom scroll behaviors
    .on('DOMMouseScroll.zoom', null) // disables older versions of Firefox
    .on('wheel.zoom', null) // disables newer versions of Firefox
    .on('dblclick.zoom', null).on('mousewheel.escher', null) // pan scroll behaviors
    .on('DOMMouseScroll.escher', null).on('wheel.escher', null).on('mousedown.zoom', null) // drag behaviors
    .on('touchstart.zoom', null).on('touchmove.zoom', null).on('touchend.zoom', null);

    // This handles dragging to pan, and touch events (in any scroll mode). It
    // also handles scrolling to zoom (only 'zoom' mode). It also raises an
    // exception in node, so catch that during testing. This may be a bug with
    // d3 related to d3 using the global this.document. TODO look into this.
    this._zoomBehavior = (0, _d3Zoom.zoom)().on('start', function () {
      // Prevent default zoom behavior, specifically for mobile pinch zoom
      if (_d3Selection.event.sourceEvent !== null) {
        _d3Selection.event.sourceEvent.stopPropagation();
        _d3Selection.event.sourceEvent.preventDefault();
      }
    }).on('zoom', function () {
      _this._goToCallback(_d3Selection.event.transform.k, {
        x: _d3Selection.event.transform.x,
        y: _d3Selection.event.transform.y
      });
    });

    // Set it up
    this.container.call(this._zoomBehavior);

    // Always turn off double-clicking to zoom
    this.container.on('dblclick.zoom', null);

    // If panning is off, then turn off these listeners
    if (!this._panDragOn) {
      this.container.on('mousedown.zoom', null).on('touchstart.zoom', null).on('touchmove.zoom', null).on('touchend.zoom', null);
    }

    // If scroll to zoom is off, then turn off these listeners
    if (this._scrollBehavior !== 'zoom') {
      this.container.on('mousewheel.zoom', null) // zoom scroll behaviors
      .on('DOMMouseScroll.zoom', null) // disables older versions of Firefox
      .on('wheel.zoom', null); // disables newer versions of Firefox
    }

    // add listeners for scrolling to pan
    if (this._scrollBehavior === 'pan') {
      // Add the wheel listener
      var wheelFn = function wheelFn() {
        var ev = _d3Selection.event;
        var sensitivity = 0.5;
        // stop scroll in parent elements
        ev.stopPropagation();
        ev.preventDefault();
        ev.returnValue = false;
        // change the location
        var getDirectionalDisp = function getDirectionalDisp(wheelDelta, delta) {
          var theDelt = _underscore2.default.isUndefined(wheelDelta) ? delta : -wheelDelta / 1.5;
          return theDelt * sensitivity;
        };
        var newTranslate = {
          x: _this.windowTranslate.x - getDirectionalDisp(ev.wheelDeltaX, ev.deltaX),
          y: _this.windowTranslate.y - getDirectionalDisp(ev.wheelDeltaY, ev.deltaY)
        };
        _this.goTo(_this.windowScale, newTranslate);
      };

      // apply it
      this.container.on('mousewheel.escher', wheelFn);
      this.container.on('DOMMouseScroll.escher', wheelFn);
      this.container.on('wheel.escher', wheelFn);
    }

    // Set current location
    this.goTo(this.windowScale, this.windowTranslate);
  };

  // ------------------------------------------------------------
  // Functions to scale and translate
  // ------------------------------------------------------------

  /**
   * Zoom the container to a specified location.
   * @param {Number} scale - The scale, between 0 and 1.
   * @param {Object} translate - The location, of the form {x: 2.0, y: 3.0}.
   */


  ZoomContainer.prototype.goTo = function goTo(scale, translate) {
    // Check inputs
    if (!scale) {
      console.error('Bad scale value');
      return;
    }
    if (!translate || !('x' in translate) || !('y' in translate) || _underscore2.default.isNaN(translate.x) || _underscore2.default.isNaN(translate.y)) {
      console.error('Bad translate value');
      return;
    }

    // Save to zoom behavior, which will call _goTo_callback
    var newZoom = _d3Zoom.zoomIdentity.translate(translate.x, translate.y).scale(scale);
    this.container.call(this._zoomBehavior.transform, newZoom);
  };

  /**
   * Execute the zoom called by the d3 zoom behavior.
   * @param {Number} scale - The scale, between 0 and 1
   * @param {Object} translate - The location, of the form { x: 2.0, y: 3.0 }
   */


  ZoomContainer.prototype._goToCallback = function _goToCallback(scale, translate) {
    var _this2 = this;

    // if the scale changes, run the zoom_change callback
    if (this.windowScale !== scale) {
      this.windowScale = scale;
      this.callbackManager.run('zoom_change');
    }
    this.windowTranslate = translate;

    if (this._use3dTransform) {
      // 3d transform
      // cancel all timeouts
      if (!_underscore2.default.isNull(this._zoomTimeout)) {
        clearTimeout(this._zoomTimeout);
      }

      // set the 3d transform
      this._goTo3d(scale, translate, this._svgScale, this._svgTranslate);

      // if another goTo does not happen within the delay time, then
      // redraw the svg
      this._zoomTimeout = _underscore2.default.delay(function () {
        // redraw the svg
        _this2._requestedFrame = false;
        _this2._goToSvg(scale, translate);
      }, 100); // between 100 and 600 seems to be usable
    } else {
      // no 3d transform
      this._goToSvg(scale, translate);
    }

    this.callbackManager.run('go_to');
  };

  ZoomContainer.prototype._goTo3dFrame = function _goTo3dFrame() {
    var _this3 = this;

    if (!this._requestedFrame) {
      this._requestedFrame = true;
      window.requestAnimationFrame(function () {
        _this3._requestedFrame = false;
        var transform = _this3._3dTransform;
        if (transform) {
          _this3.css3TransformContainer.style('transform', transform);
          _this3.css3TransformContainer.style('-webkit-transform', transform);
          _this3.css3TransformContainer.style('transform-origin', '0 0');
          _this3.css3TransformContainer.style('-webkit-transform-origin', '0 0');
        } else {
          console.warn('No _3dTransform defined');
        }
      });
    }
  };

  /**
   * Zoom & pan the CSS 3D transform container
   */


  ZoomContainer.prototype._goTo3d = function _goTo3d(scale, translate, svgScale, svgTranslate) {
    var nScale = scale / svgScale;
    var nTranslate = _utils2.default.c_minus_c(translate, _utils2.default.c_times_scalar(svgTranslate, nScale));
    var transform = 'translate(' + nTranslate.x + 'px,' + nTranslate.y + 'px) ' + 'scale(' + nScale + ')';
    this._3dTransform = transform;
    this._goTo3dFrame();
  };

  ZoomContainer.prototype._clear3d = function _clear3d() {
    if (this._3dTransform) {
      this._3dTransform = null;
      this.css3TransformContainer.style('transform', null);
      this.css3TransformContainer.style('-webkit-transform', null);
      this.css3TransformContainer.style('transform-origin', null);
      this.css3TransformContainer.style('-webkit-transform-origin', null);
    }
  };

  ZoomContainer.prototype._goToSvgFrame = function _goToSvgFrame() {
    var _this4 = this;

    var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    if (!this._requestedFrame || callback) {
      this._requestedFrame = true;
      window.requestAnimationFrame(function () {
        _this4._requestedFrame = false;

        // reset the 3d transform
        _this4._clear3d();

        var scale = _this4._svgScale;
        var translate = _this4._svgTranslate;
        _this4.zoomedSel.attr('transform', 'translate(' + translate.x + ',' + translate.y + ') ' + 'scale(' + scale + ')');
        if (callback) callback();
      });
    }
  };

  /**
   * Zoom & pan the svg element. Also runs the svg_start and svg_finish callbacks.
   * @param {Number} scale - The scale, between 0 and 1.
   * @param {Object} translate - The location, of the form {x: 2.0, y: 3.0}.
   * @param {Function} callback - (optional) A callback to run after scaling.
   */


  ZoomContainer.prototype._goToSvg = function _goToSvg(scale, translate) {
    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    // redraw the svg
    // save svg location
    this._svgScale = scale;
    this._svgTranslate = translate;
    this._goToSvgFrame(callback);
  };

  /**
   * Zoom by a specified multiplier.
   * @param {Number} amount - A multiplier for the zoom. Greater than 1 zooms in
   * and less than 1 zooms out.
   */


  ZoomContainer.prototype.zoomBy = function zoomBy(amount) {
    var size = this.get_size();
    var shift = {
      x: size.width / 2 - ((size.width / 2 - this.windowTranslate.x) * amount + this.windowTranslate.x),
      y: size.height / 2 - ((size.height / 2 - this.windowTranslate.y) * amount + this.windowTranslate.y)
    };
    this.goTo(this.windowScale * amount, _utils2.default.c_plus_c(this.windowTranslate, shift));
  };

  /**
   * Zoom in by the default amount with the default options.
   */


  ZoomContainer.prototype.zoom_in = function zoom_in() {
    // eslint-disable-line camelcase
    this.zoomBy(1.5);
  };

  /**
   * Zoom out by the default amount with the default options.
   */


  ZoomContainer.prototype.zoom_out = function zoom_out() {
    // eslint-disable-line camelcase
    this.zoomBy(0.667);
  };

  /**
   * Return the size of the zoom container as coordinates. Throws an error if
   * width or height is not defined.
   * @returns {Object} The size coordinates, e.g. { x: 2, y: 3 }.
   */


  ZoomContainer.prototype.get_size = function get_size() {
    // eslint-disable-line camelcase
    var _selection$node$getBo = this.selection.node().getBoundingClientRect(),
        width = _selection$node$getBo.width,
        height = _selection$node$getBo.height;

    return { width: width, height: height };
  };

  /**
   * Shift window if new reaction will draw off the screen.
   */


  ZoomContainer.prototype.translateOffScreen = function translateOffScreen(coords) {
    // TODO BUG not accounting for scale correctly

    var margin = 120; // pixels
    var size = this.get_size();
    var current = {
      x: {
        min: -this.windowTranslate.x / this.windowScale + margin / this.windowScale,
        max: -this.windowTranslate.x / this.windowScale + (size.width - margin) / this.windowScale
      },
      y: {
        min: -this.windowTranslate.y / this.windowScale + margin / this.windowScale,
        max: -this.windowTranslate.y / this.windowScale + (size.height - margin) / this.windowScale
      }
    };

    if (coords.x < current.x.min) {
      this.windowTranslate.x = this.windowTranslate.x - (coords.x - current.x.min) * this.windowScale;
      this.goTo(this.windowScale, this.windowTranslate);
    } else if (coords.x > current.x.max) {
      this.windowTranslate.x = this.windowTranslate.x - (coords.x - current.x.max) * this.windowScale;
      this.goTo(this.windowScale, this.windowTranslate);
    }
    if (coords.y < current.y.min) {
      this.windowTranslate.y = this.windowTranslate.y - (coords.y - current.y.min) * this.windowScale;
      this.goTo(this.windowScale, this.windowTranslate);
    } else if (coords.y > current.y.max) {
      this.windowTranslate.y = this.windowTranslate.y - (coords.y - current.y.max) * this.windowScale;
      this.goTo(this.windowScale, this.windowTranslate);
    }
  };

  return ZoomContainer;
}();

exports.default = ZoomContainer;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _utils = __webpack_require__(4);

var utils = _interopRequireWildcard(_utils);

var _Draw = __webpack_require__(63);

var _Draw2 = _interopRequireDefault(_Draw);

var _Behavior = __webpack_require__(48);

var _Behavior2 = _interopRequireDefault(_Behavior);

var _Scale = __webpack_require__(64);

var _Scale2 = _interopRequireDefault(_Scale);

var _build = __webpack_require__(49);

var build = _interopRequireWildcard(_build);

var _UndoStack = __webpack_require__(51);

var _UndoStack2 = _interopRequireDefault(_UndoStack);

var _CallbackManager = __webpack_require__(21);

var _CallbackManager2 = _interopRequireDefault(_CallbackManager);

var _KeyManager = __webpack_require__(52);

var _KeyManager2 = _interopRequireDefault(_KeyManager);

var _Canvas = __webpack_require__(65);

var _Canvas2 = _interopRequireDefault(_Canvas);

var _dataStyles = __webpack_require__(20);

var dataStyles = _interopRequireWildcard(_dataStyles);

var _SearchIndex = __webpack_require__(54);

var _SearchIndex2 = _interopRequireDefault(_SearchIndex);

var _gsap = __webpack_require__(115);

var _baconjs = __webpack_require__(37);

var _baconjs2 = _interopRequireDefault(_baconjs);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

var _d3Selection = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _on_array(fn) {
  return function (array) {
    return fn.apply(null, array);
  };
}

/**
 * Map - Defines the metabolic map data, and manages drawing and building.
 * @param svg: The parent SVG container for the map.
 * @param css:
 * @param selection: A d3 selection for a node to place the map inside.
 * @param selection:
 * @param zoomContainer:
 * @param settings:
 * @param cobra_model:
 * @param canvas_size_and_loc:
 * @param enable_search:
 * @param map_name: (Optional, Default: 'new map')
 * @param map_id: (Optional, Default: A string of random characters.)
 * @param map_description: (Optional, Default: '')
 *
 * Callbacks
 * ---------
 *
 * map.callback_manager.run('set_status', null, status)
 * map.callback_manager.run('toggle_beziers', null, beziers_enabled)
 * map.callback_manager.run('select_metabolite_with_id', null, selected_node, coords)
 * map.callback_manager.run('select_selectable', null, node_count, selected_node, coords)
 * map.callback_manager.run('deselect_nodes')
 * map.callback_manager.run('select_text_label')
 * map.callback_manager.run('before_svg_export')
 * map.callback_manager.run('after_svg_export')
 * map.callback_manager.run('before_png_export')
 * map.callback_manager.run('after_png_export')
 * map.callback_manager.run('before_convert_map')
 * map.callback_manager.run('after_convert_map')
 * this.callback_manager.run('calc_data_stats__reaction', null, changed)
 * this.callback_manager.run('calc_data_stats__metabolite', null, changed)
 *
 */

var Map = function () {
  function Map(svg, css, selection, zoomContainer, settings, cobra_model, canvas_size_and_loc, enable_search, map_name, map_id, map_description) {
    _classCallCheck(this, Map);

    if (canvas_size_and_loc === null) {
      var size = zoomContainer.get_size();
      canvas_size_and_loc = {
        x: -size.width,
        y: -size.height,
        width: size.width * 3,
        height: size.height * 3
      };
    }

    if (_underscore2.default.isUndefined(map_name) || map_name === null || map_name === '') {
      map_name = 'new_map';
    } else {
      map_name = String(map_name);
    }

    if (_underscore2.default.isUndefined(map_id) || map_id === null || map_id === '') {
      map_id = utils.generate_map_id();
    } else {
      map_id = String(map_id);
    }

    if (_underscore2.default.isUndefined(map_description) || map_description === null) {
      map_description = '';
    } else {
      map_description = String(map_description);
    }

    // set up the callbacks
    this.callback_manager = new _CallbackManager2.default();

    // set up the defs
    this.svg = svg;
    this.defs = utils.setup_defs(svg, css);

    // make the canvas
    this.canvas = new _Canvas2.default(selection, canvas_size_and_loc);

    this.setup_containers(selection);
    this.sel = selection;
    this.zoomContainer = zoomContainer;

    this.settings = settings;

    // set the model AFTER loading the datasets
    this.cobra_model = cobra_model;

    this.largest_ids = {
      reactions: -1,
      nodes: -1,
      segments: -1,
      text_labels: -1

      // make the undo/redo stack
    };this.undo_stack = new _UndoStack2.default();

    // make a behavior object
    this.behavior = new _Behavior2.default(this, this.undo_stack);

    // draw manager
    this.draw = new _Draw2.default(this.behavior, this.settings, this);

    // make a key manager
    this.key_manager = new _KeyManager2.default();
    this.key_manager.settings = settings;
    this.key_manager.ctrlEqualsCmd = true;

    // make the search index
    this.enable_search = enable_search;
    this.search_index = new _SearchIndex2.default();

    // map properties
    this.map_name = map_name;
    this.map_id = map_id;
    this.map_description = map_description;

    // deal with the window
    var window_translate = { x: 0, y: 0 };
    var window_scale = 1;

    // hide beziers
    this.beziers_enabled = false;

    // data
    this.has_data_on_reactions = false;
    this.has_data_on_nodes = false;
    this.imported_reaction_data = null;
    this.imported_metabolite_data = null;
    this.imported_gene_data = null;

    this.nodes = {};
    this.reactions = {};
    this.beziers = {};
    this.text_labels = {};

    // Update data with null to populate data-specific attributes. Also calculates
    // data stats for the first time.
    this.apply_reaction_data_to_map(null);
    this.apply_metabolite_data_to_map(null);
    this.apply_gene_data_to_map(null);

    // make the scales
    this.scale = new _Scale2.default();
    // initialize stats
    this.scale.connectToSettings(this.settings, this, this.get_data_statistics.bind(this));

    // rotation mode off
    this.rotation_on = false;
  }

  /**
   * Load a json map and add necessary fields for rendering.
   */


  Map.from_data = function from_data(map_data, svg, css, selection, zoomContainer, settings, cobra_model, enable_search) {
    var canvas = map_data[1].canvas;
    var map_name = map_data[0].map_name;
    var map_id = map_data[0].map_id;
    var map_description = map_data[0].map_description.replace(/(\nLast Modified.*)+$/g, '') + '\nLast Modified ' + Date(Date.now()).toString();
    var map = new Map(svg, css, selection, zoomContainer, settings, cobra_model, canvas, enable_search, map_name, map_id, map_description);

    map.reactions = map_data[1].reactions;
    map.nodes = map_data[1].nodes;
    map.text_labels = map_data[1].text_labels;

    for (var n_id in map.nodes) {
      var node = map.nodes[n_id];

      // clear all the connected segments
      node.connected_segments = [];

      //  populate the nodes search index.
      if (enable_search) {
        if (node.node_type !== 'metabolite') continue;
        map.search_index.insert('n' + n_id, { name: node.bigg_id,
          data: { type: 'metabolite',
            node_id: n_id } });
        map.search_index.insert('n_name' + n_id, { name: node.name,
          data: { type: 'metabolite',
            node_id: n_id } });
      }
    }

    // Propagate coefficients and reversibility, build the connected
    // segments, add bezier points, and populate the reaction search index.
    for (var r_id in map.reactions) {
      var reaction = map.reactions[r_id];

      // reaction search index
      if (enable_search) {
        map.search_index.insert('r' + r_id, { 'name': reaction.bigg_id,
          'data': { type: 'reaction',
            reaction_id: r_id } });
        map.search_index.insert('r_name' + r_id, { 'name': reaction.name,
          'data': { type: 'reaction',
            reaction_id: r_id } });
        for (var g_id in reaction.genes) {
          var gene = reaction.genes[g_id];
          map.search_index.insert('r' + r_id + '_g' + g_id, { 'name': gene.bigg_id,
            'data': { type: 'reaction',
              reaction_id: r_id } });
          map.search_index.insert('r' + r_id + '_g_name' + g_id, { 'name': gene.name,
            'data': { type: 'reaction',
              reaction_id: r_id } });
        }
      }

      // keep track of any bad segments
      var segments_to_delete = [];

      var _loop = function _loop() {
        segment = reaction.segments[s_id];

        // propagate reversibility

        segment.reversibility = reaction.reversibility;

        // if there is an error with to_ or from_ nodes, remove this segment
        if (!(segment.from_node_id in map.nodes) || !(segment.to_node_id in map.nodes)) {
          console.warn('Bad node references in segment ' + s_id + '. Deleting segment.');
          segments_to_delete.push(s_id);
          return 'continue';
        }

        var from_node = map.nodes[segment.from_node_id];
        var to_node = map.nodes[segment.to_node_id];

        // propagate coefficients
        reaction.metabolites.forEach(function (met) {
          if (met.bigg_id === from_node.bigg_id) {
            segment.from_node_coefficient = met.coefficient;
          } else if (met.bigg_id === to_node.bigg_id) {
            segment.to_node_coefficient = met.coefficient;
          }
        })

        // build connected segments
        ;[from_node, to_node].forEach(function (node) {
          node.connected_segments.push({ segment_id: s_id,
            reaction_id: r_id });
        });

        // If the metabolite has no bezier points, then add them.
        start = map.nodes[segment.from_node_id];
        end = map.nodes[segment.to_node_id];

        if (start['node_type'] == 'metabolite' || end['node_type'] == 'metabolite') {
          midpoint = utils.c_plus_c(start, utils.c_times_scalar(utils.c_minus_c(end, start), 0.5));

          if (segment.b1 === null) segment.b1 = midpoint;
          if (segment.b2 === null) segment.b2 = midpoint;
        }
      };

      for (var s_id in reaction.segments) {
        var segment;
        var start, end;
        var midpoint;

        var _ret = _loop();

        if (_ret === 'continue') continue;
      }
      // delete the bad segments
      segments_to_delete.forEach(function (s_id) {
        delete reaction.segments[s_id];
      });
    }

    // add text_labels to the search index
    if (enable_search) {
      for (var label_id in map.text_labels) {
        var label = map.text_labels[label_id];
        map.search_index.insert('l' + label_id, { 'name': label.text,
          'data': { type: 'text_label',
            text_label_id: label_id } });
      }
    }

    // populate the beziers
    map.beziers = build.newBeziersForReactions(map.reactions);

    // get largest ids for adding new reactions, nodes, text labels, and
    // segments
    map.largest_ids.reactions = get_largest_id(map.reactions);
    map.largest_ids.nodes = get_largest_id(map.nodes);
    map.largest_ids.text_labels = get_largest_id(map.text_labels);

    var largest_segment_id = 0;
    for (var id in map.reactions) {
      largest_segment_id = get_largest_id(map.reactions[id].segments, largest_segment_id);
    }
    map.largest_ids.segments = largest_segment_id;

    // update data with null to populate data-specific attributes
    map.apply_reaction_data_to_map(null);
    map.apply_metabolite_data_to_map(null);
    map.apply_gene_data_to_map(null);

    return map;

    /**
     * Return the largest integer key in obj, or current_largest, whichever is
     * bigger.
     */
    function get_largest_id(obj, current_largest) {
      if (_underscore2.default.isUndefined(current_largest)) current_largest = 0;
      if (_underscore2.default.isUndefined(obj)) return current_largest;
      return Math.max.apply(null, Object.keys(obj).map(function (x) {
        return parseInt(x);
      }).concat([current_largest]));
    }
  };

  // ---------------------------------------------------------------------
  // more setup
  // ---------------------------------------------------------------------

  Map.prototype.setup_containers = function setup_containers(sel) {
    sel.append('g').attr('id', 'reactions');
    sel.append('g').attr('id', 'nodes');
    sel.append('g').attr('id', 'beziers');
    sel.append('g').attr('id', 'text-labels');
  };

  Map.prototype.reset_containers = function reset_containers() {
    this.sel.select('#reactions').selectAll('.reaction').remove();
    this.sel.select('#nodes').selectAll('.node').remove();
    this.sel.select('#beziers').selectAll('.bezier').remove();
    this.sel.select('#text-labels').selectAll('.text-label').remove();
  };

  // -------------------------------------------------------------------------
  // Appearance
  // -------------------------------------------------------------------------

  /** Set the status of the map, with an optional expiration
      time. Rendering the status is taken care of by the Builder.
       Arguments
      ---------
       status: The status string.
       time: An optional time, in ms, after which the status is set to ''.
   */

  Map.prototype.set_status = function set_status(status, time) {
    this.callback_manager.run('set_status', null, status);
    // clear any other timers on the status bar
    clearTimeout(this._status_timer);
    this._status_timer = null;

    if (time !== undefined) {
      this._status_timer = setTimeout(function () {
        this.callback_manager.run('set_status', null, '');
      }.bind(this), time);
    }
  };

  /**
   * Clear the map data
   */


  Map.prototype.clearMapData = function clearMapData() {
    this.reactions = {};
    this.beziers = {};
    this.nodes = {};
    this.text_labels = {};
    this.map_name = 'new_map';
    this.map_id = utils.generate_map_id();
    this.map_description = '';
  };

  Map.prototype.has_cobra_model = function has_cobra_model() {
    return this.cobra_model !== null;
  };

  /**
   * Draw the all reactions, nodes, & text labels.
   */


  Map.prototype.draw_everything = function draw_everything() {
    this.draw_all_reactions(true, true); // also draw beziers
    this.draw_all_nodes(true);
    this.draw_all_text_labels();
  };

  /** Draw all reactions, and clear deleted reactions.
       Arguments
      ---------
       draw_beziers: (Boolean, default True) Whether to also draw the bezier
      control points.
       clear_deleted: (Optional, Default: true) Boolean, if true, then also
      clear deleted nodes.
   */


  Map.prototype.draw_all_reactions = function draw_all_reactions(draw_beziers, clear_deleted) {
    if (_underscore2.default.isUndefined(draw_beziers)) draw_beziers = true;
    if (_underscore2.default.isUndefined(clear_deleted)) clear_deleted = true;

    // Draw all reactions.
    var reaction_ids = [];
    for (var reaction_id in this.reactions) {
      reaction_ids.push(reaction_id);
    }
    // If draw_beziers is true, just draw them all, rather than deciding
    // which ones to draw.
    this.draw_these_reactions(reaction_ids, false);
    if (draw_beziers && this.beziers_enabled) this.draw_all_beziers();

    // Clear all deleted reactions.
    if (clear_deleted) this.clear_deleted_reactions(draw_beziers);
  };

  /**
   * Draw specific reactions. Does nothing with exit selection. Use
   * clear_deleted_reactions to remove reactions from the DOM.
   * reactions_ids: An array of reaction_ids to update.
   * draw_beziers: (Boolean, default True) Whether to also draw the bezier control
   * points.
   */


  Map.prototype.draw_these_reactions = function draw_these_reactions(reaction_ids, draw_beziers) {
    if (_underscore2.default.isUndefined(draw_beziers)) draw_beziers = true;

    // find reactions for reaction_ids
    var reaction_subset = utils.object_slice_for_ids_ref(this.reactions, reaction_ids);

    var needAnimation = true;
    if (needAnimation) {
      var createParticle = function createParticle(fuse, point) {
        // Create a new circle element
        var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        // Prepend the element to the SVG
        fuse.parentNode.append(circle);
        // Set the coordinates of that circle
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        // Define a random radius for each circle
        circle.setAttribute('r', Math.random() * 4 + 0.2);
        // Define a random color
        circle.setAttribute('fill', _gsap.gsap.utils.random(['#00FF00']));

        // Animate the circle
        _gsap.gsap.to(circle, {
          // Random cx based on its current position
          cx: '+=random(-10,10)',
          // Random cy based on its current position
          cy: '+=random(-10,10)',
          // Fade out
          opacity: 0,
          // Random duration for each circle
          duration: 'random(4, 6)',
          // Prevent gsap from rounding the cx & cy values
          autoRound: false,
          // Once the animation is complete
          onComplete: function onComplete() {
            // Remove the SVG element from its parent
            fuse.parentNode.removeChild(circle);
          }
        });
      };

      var svg = document.querySelector('svg').querySelector("g#reactions");
      var fuses = svg.querySelectorAll('path.segment');


      fuses.forEach(function (fuse) {
        // Create an object that gsap can animate
        var val = { distance: 0 };
        // Create a tween
        _gsap.gsap.to(val, {
          // Animate from distance 0 to the total distance
          distance: fuse.getTotalLength(),
          // Loop the animation
          repeat: -1,
          // Wait 1sec before repeating
          repeatDelay: 0,
          // Make the animation lasts 5 seconds
          duration: 5,
          // Function call on each frame of the animation
          onUpdate: function onUpdate() {
            // Query a point at the new distance value
            var point = fuse.getPointAtLength(val.distance);
            if (fuse.parentNode.attributes['id'].value === 's268') {
              // console.log(fuse.parentNode.querySelectorAll('circle').length, 'circle.length');
            }
            createParticle(fuse, point);
          }
        });

        /* Animate the fuse to reduce it */
        // fuse.setAttribute('stroke-dasharray', fuse.getTotalLength());
        // fuse.setAttribute('stroke-dashoffset', fuse.getTotalLength() * 2);
        // gsap.to(fuse, {
        //   strokeDashoffset: fuse.getTotalLength(),
        //   duration: 5,
        //   repeat: 1,
        //   // Wait 1sec before repeating
        //   repeatDelay: 1
        // });
      });
    }

    // function to update reactions
    var update_fn = function (sel) {
      return this.draw.update_reaction(sel, this.scale, this.cobra_model, this.nodes, this.defs, this.has_data_on_reactions);
    }.bind(this);

    // draw the reactions
    utils.draw_an_object(this.sel, '#reactions', '.reaction', reaction_subset, 'reaction_id', this.draw.create_reaction.bind(this.draw), update_fn);

    if (draw_beziers) {
      // particular beziers to draw
      var bezier_ids = build.bezierIdsForReactionIds(reaction_subset);
      this.draw_these_beziers(bezier_ids);
    }
  };

  /**
   * Remove any reactions that are not in *this.reactions*.
   * draw_beziers: (Boolean, default True) Whether to also clear deleted bezier
   * control points.
   */


  Map.prototype.clear_deleted_reactions = function clear_deleted_reactions(draw_beziers) {
    if (_underscore2.default.isUndefined(draw_beziers)) draw_beziers = true;

    // Remove deleted reactions and segments
    utils.draw_an_object(this.sel, '#reactions', '.reaction', this.reactions, 'reaction_id', null, function (update_selection) {
      // Draw segments
      utils.draw_a_nested_object(update_selection, '.segment-group', 'segments', 'segment_id', null, null, function (sel) {
        sel.remove();
      });
    }, function (sel) {
      sel.remove();
    });

    if (draw_beziers === true) {
      this.clear_deleted_beziers();
    }
  };

  /**
   * Draw all nodes, and clear deleted nodes.
   * @param clear_deleted: (Optional, Default: true) Boolean, if true, then also
   * @param clear deleted nodes.
   */


  Map.prototype.draw_all_nodes = function draw_all_nodes(clear_deleted) {
    if (clear_deleted === undefined) clear_deleted = true;

    var node_ids = [];
    for (var node_id in this.nodes) {
      node_ids.push(node_id);
    }
    this.draw_these_nodes(node_ids);

    // clear the deleted nodes
    if (clear_deleted) this.clear_deleted_nodes();
  };

  /** Draw specific nodes.
       Does nothing with exit selection. Use clear_deleted_nodes to remove
      nodes from the DOM.
       Arguments
      ---------
       nodes_ids: An array of node_ids to update.
   */


  Map.prototype.draw_these_nodes = function draw_these_nodes(node_ids) {
    // find reactions for reaction_ids
    var node_subset = utils.object_slice_for_ids_ref(this.nodes, node_ids);

    // functions to create and update nodes
    var create_fn = function (sel) {
      return this.draw.create_node(sel, this.nodes, this.reactions);
    }.bind(this);
    var update_fn = function (sel) {
      return this.draw.update_node(sel, this.scale, this.has_data_on_nodes, this.behavior.selectableMousedown, this.behavior.selectableClick, this.behavior.nodeMouseover, this.behavior.nodeMouseout, this.behavior.selectableDrag, this.behavior.nodeLabelDrag);
    }.bind(this);

    // draw the nodes
    utils.draw_an_object(this.sel, '#nodes', '.node', node_subset, 'node_id', create_fn, update_fn);
  };

  /**
   * Remove any nodes that are not in *this.nodes*.
   */


  Map.prototype.clear_deleted_nodes = function clear_deleted_nodes() {
    // Run remove for exit selection
    utils.draw_an_object(this.sel, '#nodes', '.node', this.nodes, 'node_id', null, null, function (sel) {
      sel.remove();
    });
  };

  /**
   * Draw all text_labels.
   */


  Map.prototype.draw_all_text_labels = function draw_all_text_labels() {
    this.draw_these_text_labels(Object.keys(this.text_labels));

    // Clear all deleted text_labels
    this.clear_deleted_text_labels();
  };

  /**
   * Draw specific text_labels. Does nothing with exit selection. Use
   * clear_deleted_text_labels to remove text_labels from the DOM.
   * @param {Array} text_labels_ids - An array of text_label_ids to update.
   */


  Map.prototype.draw_these_text_labels = function draw_these_text_labels(text_label_ids) {
    // Find reactions for reaction_ids
    var text_label_subset = utils.object_slice_for_ids_ref(this.text_labels, text_label_ids);

    // Draw the text_labels
    utils.draw_an_object(this.sel, '#text-labels', '.text-label', text_label_subset, 'text_label_id', this.draw.create_text_label.bind(this.draw), this.draw.update_text_label.bind(this.draw));
  };

  /**
   * Remove any text_labels that are not in *this.text_labels*.
   */


  Map.prototype.clear_deleted_text_labels = function clear_deleted_text_labels() {
    utils.draw_an_object(this.sel, '#text-labels', '.text-label', this.text_labels, 'text_label_id', null, null, function (sel) {
      sel.remove();
    });
  };

  /**
   * Draw all beziers, and clear deleted reactions.
   */


  Map.prototype.draw_all_beziers = function draw_all_beziers() {
    var bezier_ids = [];
    for (var bezier_id in this.beziers) {
      bezier_ids.push(bezier_id);
    }
    this.draw_these_beziers(bezier_ids);

    // clear delete beziers
    this.clear_deleted_beziers();
  };

  Map.prototype.draw_these_beziers = function draw_these_beziers(bezier_ids) {
    /** Draw specific beziers.
         Does nothing with exit selection. Use clear_deleted_beziers to remove
        beziers from the DOM.
         Arguments
        ---------
         beziers_ids: An array of bezier_ids to update.
     */
    // find reactions for reaction_ids
    var bezier_subset = utils.object_slice_for_ids_ref(this.beziers, bezier_ids);

    // function to update beziers
    var update_fn = function (sel) {
      return this.draw.update_bezier(sel, this.beziers_enabled, this.behavior.bezierDrag, this.behavior.bezierMouseover, this.behavior.bezierMouseout, this.nodes, this.reactions);
    }.bind(this);

    // draw the beziers
    utils.draw_an_object(this.sel, '#beziers', '.bezier', bezier_subset, 'bezier_id', this.draw.create_bezier.bind(this.draw), update_fn);
  };

  Map.prototype.clear_deleted_beziers = function clear_deleted_beziers() {
    /** Remove any beziers that are not in *this.beziers*.
      */
    // remove deleted
    utils.draw_an_object(this.sel, '#beziers', '.bezier', this.beziers, 'bezier_id', null, null, function (sel) {
      sel.remove();
    });
  };

  Map.prototype.show_beziers = function show_beziers() {
    this.toggle_beziers(true);
  };

  Map.prototype.hide_beziers = function hide_beziers() {
    this.toggle_beziers(false);
  };

  Map.prototype.toggle_beziers = function toggle_beziers(on_off) {
    if (_underscore2.default.isUndefined(on_off)) this.beziers_enabled = !this.beziers_enabled;else this.beziers_enabled = on_off;
    this.draw_all_beziers();
    this.callback_manager.run('toggle_beziers', null, this.beziers_enabled);
  };

  /**
   * Returns True if the scale has changed.
   * @param {Array} keys - (Optional) The keys in reactions to apply data to.
   */


  Map.prototype.apply_reaction_data_to_map = function apply_reaction_data_to_map(data, keys) {
    var styles = this.settings.get('reaction_styles');
    var compareStyle = this.settings.get('reaction_compare_style');
    var hasData = dataStyles.apply_reaction_data_to_reactions(this.reactions, data, styles, compareStyle, keys);
    this.has_data_on_reactions = hasData;
    this.imported_reaction_data = hasData ? data : null;

    return this.calc_data_stats('reaction');
  };

  /**
   * Returns True if the scale has changed.
   * @param {Array} keys - (Optional) The keys in nodes to apply data to.
   */


  Map.prototype.apply_metabolite_data_to_map = function apply_metabolite_data_to_map(data, keys) {
    var styles = this.settings.get('metabolite_styles');
    var compare_style = this.settings.get('metabolite_compare_style');

    var has_data = dataStyles.apply_metabolite_data_to_nodes(this.nodes, data, styles, compare_style, keys);
    this.has_data_on_nodes = has_data;
    this.imported_metabolite_data = has_data ? data : null;

    return this.calc_data_stats('metabolite');
  };

  /**
   * Returns True if the scale has changed.
   * gene_data_obj: The gene data object, with the following style:
   * { reaction_id: { rule: 'rule_string', genes: { gene_id: value } } }
   * @param {Array} keys - (Optional) The keys in reactions to apply data to.
   */


  Map.prototype.apply_gene_data_to_map = function apply_gene_data_to_map(gene_data_obj, keys) {
    var styles = this.settings.get('reaction_styles'),
        compare_style = this.settings.get('reaction_compare_style'),
        identifiers_on_map = this.settings.get('identifiers_on_map'),
        and_method_in_gene_reaction_rule = this.settings.get('and_method_in_gene_reaction_rule');

    var has_data = dataStyles.apply_gene_data_to_reactions(this.reactions, gene_data_obj, styles, identifiers_on_map, compare_style, and_method_in_gene_reaction_rule, keys);
    this.has_data_on_reactions = has_data;
    this.imported_gene_data = has_data ? gene_data_obj : null;

    return this.calc_data_stats('reaction');
  };

  // ------------------------------------------------
  // Data domains
  // ------------------------------------------------

  Map.prototype.get_data_statistics = function get_data_statistics() {
    return this.data_statistics;
  };

  /**
   * Returns True if the stats have changed.
   * @param {String} type - Either 'metabolite' or 'reaction'
   */


  Map.prototype.calc_data_stats = function calc_data_stats(type) {
    if (['reaction', 'metabolite'].indexOf(type) === -1) {
      throw new Error('Bad type ' + type);
    }

    // make the data structure
    if (!('data_statistics' in this)) {
      this.data_statistics = {};
      this.data_statistics[type] = null;
    } else if (!(type in this.data_statistics)) {
      this.data_statistics[type] = null;
    }

    // default min and max
    var vals = [];
    if (type === 'metabolite') {
      for (var node_id in this.nodes) {
        var node = this.nodes[node_id];
        // check number
        if (_underscore2.default.isUndefined(node.data)) {
          console.error('metabolite missing ');
        } else if (node.data !== null) {
          vals.push(node.data);
        }
      }
    } else if (type == 'reaction') {
      for (var reaction_id in this.reactions) {
        var reaction = this.reactions[reaction_id];
        // check number
        if (_underscore2.default.isUndefined(reaction.data)) {
          console.error('reaction data missing ');
        } else if (reaction.data !== null) {
          vals.push(reaction.data);
        }
      }
    }

    // If no vals, then set to null
    if (vals.length === 0) {
      var wasNull = this.data_statistics[type] === null;
      this.data_statistics[type] = null;
      if (type === 'reaction') {
        this.callback_manager.run('calc_data_stats__reaction', null, !wasNull);
      } else {
        this.callback_manager.run('calc_data_stats__metabolite', null, !wasNull);
      }
      return !wasNull; // true means did change which means was not null
    }

    // If there are vals and it was previously null, then create an object
    if (this.data_statistics[type] === null) {
      this.data_statistics[type] = {};
    }

    var same = true;

    // calculate these statistics
    var quartiles = utils.quartiles(vals);
    var funcs = [['min', _on_array(Math.min)], ['max', _on_array(Math.max)], ['mean', utils.mean], ['Q1', function () {
      return quartiles[0];
    }], ['median', function () {
      return quartiles[1];
    }], ['Q3', function () {
      return quartiles[2];
    }]];
    funcs.forEach(function (ar) {
      var new_val;
      var name = ar[0];
      if (vals.length === 0) {
        new_val = null;
      } else {
        var fn = ar[1];
        new_val = fn(vals);
      }
      if (new_val != this.data_statistics[type][name]) {
        same = false;
      }
      this.data_statistics[type][name] = new_val;
    }.bind(this));

    // Deal with max === min
    if (this.data_statistics[type]['min'] === this.data_statistics[type]['max'] && this.data_statistics[type]['min'] !== null) {
      var min = this.data_statistics[type]['min'];
      var max = this.data_statistics[type]['max'];
      this.data_statistics[type]['min'] = min - 1 - Math.abs(min) * 0.1;
      this.data_statistics[type]['max'] = max + 1 + Math.abs(max) * 0.1;
    }

    if (type === 'reaction') {
      this.callback_manager.run('calc_data_stats__reaction', null, !same);
    } else {
      this.callback_manager.run('calc_data_stats__metabolite', null, !same);
    }
    return !same;
  };

  // ---------------------------------------------------------------------
  // Node interaction
  // ---------------------------------------------------------------------

  Map.prototype.get_coords_for_node = function get_coords_for_node(node_id) {
    var node = this.nodes[node_id],
        coords = { x: node.x, y: node.y };
    return coords;
  };

  Map.prototype.get_selected_node_ids = function get_selected_node_ids() {
    var selected_node_ids = [];
    this.sel.select('#nodes').selectAll('.selected').each(function (d) {
      selected_node_ids.push(d.node_id);
    });
    return selected_node_ids;
  };

  Map.prototype.getSelectedNodes = function getSelectedNodes() {
    var selected_nodes = {};
    this.sel.select('#nodes').selectAll('.selected').each(function (d) {
      selected_nodes[d.node_id] = this.nodes[d.node_id];
    }.bind(this));
    return selected_nodes;
  };

  Map.prototype.get_selected_text_label_ids = function get_selected_text_label_ids() {
    var selected_text_label_ids = [];
    this.sel.select('#text-labels').selectAll('.selected').each(function (d) {
      selected_text_label_ids.push(d.text_label_id);
    });
    return selected_text_label_ids;
  };

  Map.prototype.get_selected_text_labels = function get_selected_text_labels() {
    var selected_text_labels = {};
    this.sel.select('#text-labels').selectAll('.selected').each(function (d) {
      selected_text_labels[d.text_label_id] = this.text_labels[d.text_label_id];
    }.bind(this));
    return selected_text_labels;
  };

  Map.prototype.select_all = function select_all() {
    /** Select all nodes and text labels.
      */
    this.sel.selectAll('#nodes,#text-labels').selectAll('.node,.text-label').classed('selected', true);
  };

  Map.prototype.select_none = function select_none() {
    /** Deselect all nodes and text labels.
      */
    this.sel.selectAll('.selected').classed('selected', false);
  };

  Map.prototype.invert_selection = function invert_selection() {
    /** Invert selection of nodes and text labels.
      */
    var selection = this.sel.selectAll('#nodes,#text-labels').selectAll('.node,.text-label');
    selection.classed('selected', function () {
      return !(0, _d3Selection.select)(this).classed('selected');
    });
  };

  Map.prototype.select_metabolite_with_id = function select_metabolite_with_id(node_id) {
    /** Select a metabolite with the given id, and turn off the reaction
        target.
     */
    // deselect all text labels
    this.deselect_text_labels();

    var node_selection = this.sel.select('#nodes').selectAll('.node'),
        coords,
        selected_node;
    node_selection.classed('selected', function (d) {
      var selected = String(d.node_id) == String(node_id);
      if (selected) {
        selected_node = d;
        coords = { x: d.x, y: d.y };
      }
      return selected;
    });
    this.sel.selectAll('.start-reaction-target').style('visibility', 'hidden');
    this.callback_manager.run('select_metabolite_with_id', null, selected_node, coords);
  };

  Map.prototype.select_selectable = function select_selectable(node, d, shift_key_on) {
    /** Select a metabolite or text label, and manage the shift key. */
    shift_key_on = _underscore2.default.isUndefined(shift_key_on) ? false : shift_key_on;
    var classable_selection = this.sel.selectAll('#nodes,#text-labels').selectAll('.node,.text-label'),
        classable_node;
    if ((0, _d3Selection.select)(node).attr('class').indexOf('text-label') == -1) {
      // node
      classable_node = node.parentNode;
    } else {
      // text-label
      classable_node = node;
    }
    // toggle selection
    if (shift_key_on) {
      // toggle this node
      (0, _d3Selection.select)(classable_node).classed('selected', !(0, _d3Selection.select)(classable_node).classed('selected'));
    } else {
      // unselect all other nodes, and select this one
      classable_selection.classed('selected', false);
      (0, _d3Selection.select)(classable_node).classed('selected', true);
    }
    // run the select_metabolite callback
    var selected_nodes = this.sel.select('#nodes').selectAll('.selected'),
        node_count = 0,
        coords,
        selected_node;
    selected_nodes.each(function (d) {
      selected_node = d;
      coords = { x: d.x, y: d.y };
      node_count++;
    });
    this.callback_manager.run('select_selectable', null, node_count, selected_node, coords);
  };

  /**
   * Unselect all but one selected node, and return the node. If no nodes are
   * selected, return null.
   */


  Map.prototype.select_single_node = function select_single_node() {
    var out = null;
    var node_selection = this.sel.select('#nodes').selectAll('.selected');
    node_selection.classed('selected', function (d, i) {
      if (i === 0) {
        out = d;
        return true;
      } else {
        return false;
      }
    });
    return out;
  };

  Map.prototype.deselect_nodes = function deselect_nodes() {
    var node_selection = this.sel.select('#nodes').selectAll('.node');
    node_selection.classed('selected', false);
    this.callback_manager.run('deselect_nodes');
  };

  Map.prototype.select_text_label = function select_text_label(sel, d) {
    // deselect all nodes
    this.deselect_nodes();
    // Find the new selection. Ignore shift key and only allow single selection
    // for now.
    var text_label_selection = this.sel.select('#text-labels').selectAll('.text-label');
    text_label_selection.classed('selected', function (p) {
      return d === p;
    });
    var selected_text_labels = this.sel.select('#text-labels').selectAll('.selected'),
        coords;
    selected_text_labels.each(function (d) {
      coords = { x: d.x, y: d.y };
    });
    this.callback_manager.run('select_text_label');
  };

  Map.prototype.deselect_text_labels = function deselect_text_labels() {
    var text_label_selection = this.sel.select('#text-labels').selectAll('.text-label');
    text_label_selection.classed('selected', false);
  };

  /**
   * Align selected nodes and/or reactions vertically. Undoable.
   */


  Map.prototype.align_vertical = function align_vertical() {
    return this._align(false);
  };

  /**
   * Align selected nodes and/or reactions horizontally. Undoable
   */


  Map.prototype.align_horizontal = function align_horizontal() {
    return this._align(true);
  };

  /**
   * Generic function for aligning nodes.
   * @param {Boolean} isHorizontal - If true, align horizontal; else vertical.
   */


  Map.prototype._align = function _align(isHorizontal) {
    var _this = this;

    var selected = this.getSelectedNodes();
    // Get markers and primary nodes
    var markersAndPrimary = _underscore2.default.pick(selected, function (node) {
      return node.node_type !== 'metabolite' || node.node_is_primary;
    });

    // 1. generally operates on markers and primary nodes, bringing along
    // unconnected secondary nodes and beziers
    // 2. if only selected secondary nodes, then align those
    var alignByPrimary = Object.keys(markersAndPrimary).length > 0;
    var toAlign = alignByPrimary ? markersAndPrimary : selected;
    var keysToAlign = Object.keys(toAlign);

    // Get new x location
    var mean = keysToAlign.reduce(function (accum, val) {
      return accum + (isHorizontal ? toAlign[val].y : toAlign[val].x);
    }, 0) / keysToAlign.length;

    // Align. Remember displacements for undo/redo.
    var displacements = _underscore2.default.pairs(toAlign).map(function (_ref) {
      var nodeId = _ref[0],
          node = _ref[1];
      return {
        nodeId: nodeId,
        displacement: isHorizontal ? { x: 0, y: mean - node.y } : { x: mean - node.x, y: 0 }
      };
    });
    var bezierDisplacements = [];
    var movedSecondaryNodes = {};

    // Align unconnected secondary metabolites
    if (alignByPrimary) {
      _underscore2.default.mapObject(toAlign, function (node, nodeId) {
        node.connected_segments.map(function (segmentLink) {
          // get each connected node
          var segmentId = segmentLink.segment_id;
          var reactionId = segmentLink.reaction_id;
          var segment = _this.reactions[reactionId].segments[segmentId];
          var isToNode = segment.to_node_id === node.node_id;
          var otherNodeId = isToNode ? segment.from_node_id : segment.to_node_id;
          var otherNode = _this.nodes[otherNodeId];
          var bez = isToNode ? 'b2' : 'b1';

          // align this side bezier if the other node is selected (and that node
          // will handle its bezier)
          if (otherNode.node_id in selected && segment[bez]) {
            var bezierId = build.bezierIdForSegmentId(segmentId, bez);
            bezierDisplacements.push({
              reactionId: reactionId,
              segmentId: segmentId,
              bez: bez,
              bezierId: bezierId,
              displacement: isHorizontal ? { x: 0, y: node.y - segment[bez].y } : { x: node.x - segment[bez].x, y: 0 }
            });

            // If the node is secondary and unconnected, then move it along with
            // the current node.
            if (otherNode.node_type === 'metabolite' && !otherNode.node_is_primary && !(otherNodeId in movedSecondaryNodes)) {
              // If all the connected segments are connected to selected nodes, then move it
              var connected = otherNode.connected_segments.filter(function (segmentLink) {
                var segment = _this.reactions[reactionId].segments[segmentId];
                var isToNode = segment.to_node_id === otherNode.node_id;
                return isToNode ? segment.from_node_id in selected : segment.to_node_id in selected;
              });
              if (otherNode.connected_segments.length <= connected.length) {
                // then move it with the same displacement as the parent
                displacements.push({
                  nodeId: otherNodeId,
                  displacement: isHorizontal ? { x: 0, y: mean - node.y } : { x: mean - node.x, y: 0 }
                });
                // remember not to move this again
                movedSecondaryNodes[otherNodeId] = true;
              }
            }
          }
        });
      });
    }

    // reusable movement function for aligning and undo/redo
    var _moveNodes = function _moveNodes(disps, bezDisps) {
      var reactionIds = [];
      disps.map(function (d) {
        // TODO abstract this approach in a function because the alternative
        // (saving the node itself) causes bugs)
        var node = _this.nodes[d.nodeId];
        var updated = build.moveNodeAndDependents(node, d.nodeId, _this.reactions, _this.beziers, d.displacement);
        reactionIds = utils.uniqueConcat([reactionIds, updated.reaction_ids]);
      });
      // move beziers
      bezDisps.map(function (d) {
        var segment = _this.reactions[d.reactionId].segments[d.segmentId];
        segment[d.bez] = utils.c_plus_c(segment[d.bez], d.displacement);
        _this.beziers[d.bezierId].x = segment[d.bez].x;
        _this.beziers[d.bezierId].y = segment[d.bez].y;
      });

      _this.draw_these_nodes(disps.map(function (d) {
        return d.nodeId;
      }));
      _this.draw_these_reactions(reactionIds, true); // and beziers
    };

    // undo /redo
    this.undo_stack.push(
    // undo
    function () {
      var reverse = function reverse(disps) {
        return disps.map(function (d) {
          return _extends({}, d, {
            displacement: { x: -d.displacement.x, y: -d.displacement.y }
          });
        });
      };
      _moveNodes(reverse(displacements), reverse(bezierDisplacements));
    },
    // redo
    function () {
      _moveNodes(displacements, bezierDisplacements);
    }).do(); // do the first time

    // finish
    this.set_status(alignByPrimary ? 'Aligned reactions' : 'Aligned nodes', 3000);
  };

  // ---------------------------------------------------------------------
  // Delete
  // ---------------------------------------------------------------------

  /**
   * Delete the selected nodes and associated segments and reactions, and selected
   * labels. Undoable.
   */


  Map.prototype.delete_selected = function delete_selected() {
    var selected_nodes = this.getSelectedNodes(),
        selected_text_labels = this.get_selected_text_labels();
    if (Object.keys(selected_nodes).length >= 1 || Object.keys(selected_text_labels).length >= 1) this.delete_selectable(selected_nodes, selected_text_labels, true);
  };

  /**
   * Delete the nodes and associated segments and reactions. Undoable.
   * selected_nodes: An object that is a subset of map.nodes.
   * selected_text_labels: An object that is a subset of map.text_labels.
   * should_draw: A boolean argument to determine whether to draw the changes to
   * the map.
   */


  Map.prototype.delete_selectable = function delete_selectable(selected_nodes, selected_text_labels, should_draw) {
    var out = this.segments_and_reactions_for_nodes(selected_nodes);
    var segment_objs_w_segments = out.segment_objs_w_segments; // TODO repeated values here
    var reactions = out.reactions;

    // copy nodes to undelete
    var saved_nodes = utils.clone(selected_nodes);
    var saved_segment_objs_w_segments = utils.clone(segment_objs_w_segments);
    var saved_reactions = utils.clone(reactions);
    var saved_text_labels = utils.clone(selected_text_labels);
    var delete_and_draw = function (nodes, reactions, segment_objs, selected_text_labels) {
      // delete nodes, segments, and reactions with no segments
      this.delete_node_data(Object.keys(selected_nodes));
      this.delete_segment_data(segment_objs); // also deletes beziers
      this.delete_reaction_data(Object.keys(reactions));
      this.delete_text_label_data(Object.keys(selected_text_labels));

      // apply the reaction and node data
      var changed_r_scale = false;
      var changed_m_scale = false;
      if (this.has_data_on_reactions) {
        changed_r_scale = this.calc_data_stats('reaction');
      }
      if (this.has_data_on_nodes) {
        changed_m_scale = this.calc_data_stats('metabolite');
      }

      // redraw
      if (should_draw) {
        if (changed_r_scale) this.draw_all_reactions(true, true);else this.clear_deleted_reactions(); // also clears segments and beziers
        if (changed_m_scale) this.draw_all_nodes(true);else this.clear_deleted_nodes();
        this.clear_deleted_text_labels();
      }
    }.bind(this);

    // delete
    delete_and_draw(selected_nodes, reactions, segment_objs_w_segments, selected_text_labels);

    // add to undo/redo stack
    this.undo_stack.push(function () {
      // undo
      // redraw the saved nodes, reactions, and segments

      this.extend_nodes(saved_nodes);
      this.extend_reactions(saved_reactions);
      var reaction_ids_to_draw = Object.keys(saved_reactions);
      for (var segment_id in saved_segment_objs_w_segments) {
        var segment_obj = saved_segment_objs_w_segments[segment_id];

        var segment = segment_obj.segment;
        this.reactions[segment_obj.reaction_id].segments[segment_obj.segment_id] = segment;

        // updated connected nodes
        var to_from = [segment.from_node_id, segment.to_node_id];
        to_from.forEach(function (node_id) {
          // not necessary for the deleted nodes
          if (node_id in saved_nodes) return;
          var node = this.nodes[node_id];
          node.connected_segments.push({ reaction_id: segment_obj.reaction_id,
            segment_id: segment_obj.segment_id });
        }.bind(this));

        // extend the beziers
        var seg_id = segment_obj.segment_id,
            r_id = segment_obj.reaction_id,
            seg_o = {};
        seg_o[seg_id] = segment_obj.segment;
        utils.extend(this.beziers, build.newBeziersForSegments(seg_o, r_id));

        if (reaction_ids_to_draw.indexOf(segment_obj.reaction_id) === -1) {
          reaction_ids_to_draw.push(segment_obj.reaction_id);
        }
      }

      // Apply the reaction and node data. If the scale changes, redraw
      // everything.
      if (this.has_data_on_reactions) {
        var scale_changed = this.calc_data_stats('reaction');
        if (scale_changed) this.draw_all_reactions(true, false);else this.draw_these_reactions(reaction_ids_to_draw);
      } else {
        if (should_draw) this.draw_these_reactions(reaction_ids_to_draw);
      }
      if (this.has_data_on_nodes) {
        var _scale_changed = this.calc_data_stats('metabolite');
        if (should_draw) {
          if (_scale_changed) this.draw_all_nodes(false);else this.draw_these_nodes(Object.keys(saved_nodes));
        }
      } else {
        if (should_draw) this.draw_these_nodes(Object.keys(saved_nodes));
      }

      // redraw the saved text_labels
      utils.extend(this.text_labels, saved_text_labels);
      if (should_draw) this.draw_these_text_labels(Object.keys(saved_text_labels));
      // copy text_labels to re-delete
      selected_text_labels = utils.clone(saved_text_labels);

      // copy nodes to re-delete
      selected_nodes = utils.clone(saved_nodes);
      segment_objs_w_segments = utils.clone(saved_segment_objs_w_segments);
      reactions = utils.clone(saved_reactions);
    }.bind(this), function () {
      // redo
      // clone the nodes and reactions, to redo this action later
      delete_and_draw(selected_nodes, reactions, segment_objs_w_segments, selected_text_labels);
    }.bind(this));
  };

  /**
   * Delete nodes, and remove from search index.
   */


  Map.prototype.delete_node_data = function delete_node_data(nodeIds) {
    var _this2 = this;

    nodeIds.forEach(function (nodeId) {
      if (_this2.enable_search && _this2.nodes[nodeId].node_type === 'metabolite') {
        var found = _this2.search_index.remove('n' + nodeId) && _this2.search_index.remove('n_name' + nodeId);
        if (!found) {
          console.warn('Could not find deleted metabolite in search index');
        }
      }
      delete _this2.nodes[nodeId];
    });
  };

  /**
   * Delete segments, update connected_segments in nodes, and delete bezier
   * points.
   * @param {Object} segment_objs - Object with values like
   *                                { reaction_id: '123', segment_id: '456' }
   */


  Map.prototype.delete_segment_data = function delete_segment_data(segment_objs) {
    for (var segment_id in segment_objs) {
      var segment_obj = segment_objs[segment_id];
      var reaction = this.reactions[segment_obj.reaction_id];

      // segment already deleted
      if (!(segment_obj.segment_id in reaction.segments)) return;

      var segment = reaction.segments[segment_obj.segment_id]
      // updated connected nodes
      ;[segment.from_node_id, segment.to_node_id].forEach(function (node_id) {
        if (!(node_id in this.nodes)) return;
        var node = this.nodes[node_id];
        node.connected_segments = node.connected_segments.filter(function (so) {
          return so.segment_id != segment_obj.segment_id;
        });
      }.bind(this))

      // remove beziers
      ;['b1', 'b2'].forEach(function (bez) {
        var bez_id = build.bezierIdForSegmentId(segment_obj.segment_id, bez);
        delete this.beziers[bez_id];
      }.bind(this));

      delete reaction.segments[segment_obj.segment_id];
    }
  };

  /**
   * Delete reactions, segments, and beziers, and remove reaction from search
   * index.
   */


  Map.prototype.delete_reaction_data = function delete_reaction_data(reaction_ids) {
    reaction_ids.forEach(function (reaction_id) {
      // remove beziers
      var reaction = this.reactions[reaction_id];
      for (var segment_id in reaction.segments) {
        ;['b1', 'b2'].forEach(function (bez) {
          var bez_id = build.bezierIdForSegmentId(segment_id, bez);
          delete this.beziers[bez_id];
        }.bind(this));
      }
      // delete reaction
      delete this.reactions[reaction_id];
      // remove from search index
      var found = this.search_index.remove('r' + reaction_id) && this.search_index.remove('r_name' + reaction_id);
      if (!found) console.warn('Could not find deleted reaction ' + reaction_id + ' in search index');
      for (var g_id in reaction.genes) {
        var found = this.search_index.remove('r' + reaction_id + '_g' + g_id) && this.search_index.remove('r' + reaction_id + '_g_name' + g_id);
        if (!found) console.warn('Could not find deleted gene ' + g_id + ' in search index');
      }
    }.bind(this));
  };

  /**
   * Delete text labels for an array of IDs
   */


  Map.prototype.delete_text_label_data = function delete_text_label_data(text_label_ids) {
    text_label_ids.forEach(function (text_label_id) {
      // delete label
      delete this.text_labels[text_label_id];
      // remove from search index
      var found = this.search_index.remove('l' + text_label_id);
      if (!found) {
        console.warn('Could not find deleted text label in search index');
      }
    }.bind(this));
  };

  // ---------------------------------------------------------------------
  // Building
  // ---------------------------------------------------------------------

  Map.prototype._extend_and_draw_metabolite = function _extend_and_draw_metabolite(new_nodes, selected_node_id) {
    this.extend_nodes(new_nodes);
    var keys = [selected_node_id];
    if (this.has_data_on_nodes) {
      if (this.imported_metabolite_data === null) {
        throw new Error('imported_metabolite_data should not be null');
      }
      var scale_changed = this.apply_metabolite_data_to_map(this.imported_metabolite_data, keys);
      if (scale_changed) {
        this.draw_all_nodes(false);
      } else {
        this.draw_these_nodes(keys);
      }
    } else {
      this.draw_these_nodes(keys);
    }
  };

  /**
   * Draw a reaction on a blank canvas.
   * @param {String} starting_reaction - bigg_id for a reaction to draw.
   * @param {Coords} coords - coordinates to start drawing
   */


  Map.prototype.new_reaction_from_scratch = function new_reaction_from_scratch(starting_reaction, coords, direction) {
    var _this3 = this;

    // If there is no cobra model, error
    if (!this.cobra_model) {
      console.error('No CobraModel. Cannot build new reaction');
      return;
    }

    // Set reaction coordinates and angle. Be sure to clone the reaction.
    var cobra_reaction = utils.clone(this.cobra_model.reactions[starting_reaction]);

    // check for empty reactions
    if (_underscore2.default.size(cobra_reaction.metabolites) === 0) {
      throw Error('No metabolites in reaction ' + cobra_reaction.bigg_id);
    }

    // create the first node
    var reactant_ids = _underscore2.default.map(cobra_reaction.metabolites, function (coeff, met_id) {
      return [coeff, met_id];
    }).filter(function (x) {
      return x[0] < 0;
    }) // coeff < 0
    .map(function (x) {
      return x[1];
    }); // metabolite id
    // get the first reactant or else the first product
    var metaboliteId = reactant_ids.length > 0 ? reactant_ids[0] : Object.keys(cobra_reaction.metabolites)[0];
    var metabolite = this.cobra_model.metabolites[metaboliteId];
    var selected_node_id = String(++this.largest_ids.nodes);
    var label_d = build.getMetLabelLoc(utils.to_radians(direction), 0, 1, true, metaboliteId, true);
    var selected_node = {
      connected_segments: [],
      x: coords.x,
      y: coords.y,
      node_is_primary: true,
      label_x: coords.x + label_d.x,
      label_y: coords.y + label_d.y,
      name: metabolite.name,
      bigg_id: metaboliteId,
      node_type: 'metabolite'
    };
    var new_nodes = {};
    new_nodes[selected_node_id] = selected_node;

    // draw
    this._extend_and_draw_metabolite(new_nodes, selected_node_id);

    // clone the nodes and reactions, to redo this action later
    var saved_nodes = utils.clone(new_nodes);

    // draw the reaction
    var out = this.new_reaction_for_metabolite(starting_reaction, selected_node_id, direction, false);
    var reaction_redo = out.redo;
    var reaction_undo = out.undo;

    // add to undo/redo stack
    this.undo_stack.push(function () {
      // Undo. First undo the reaction.
      reaction_undo();
      // Get the nodes to delete
      _this3.delete_node_data(Object.keys(new_nodes));
      // Save the nodes and reactions again, for redo
      new_nodes = utils.clone(saved_nodes);
      // Draw
      _this3.clear_deleted_nodes();
      // Deselect
      _this3.deselect_nodes();
    }, function () {
      // Redo. Clone the nodes and reactions, to redo this action later.
      _this3._extend_and_draw_metabolite(new_nodes, selected_node_id);
      // Now redo the reaction
      reaction_redo();
    });

    return;
  };

  /**
   * Add new nodes to data and search index.
   */


  Map.prototype.extend_nodes = function extend_nodes(new_nodes) {
    if (this.enable_search) {
      for (var node_id in new_nodes) {
        var node = new_nodes[node_id];
        if (node.node_type != 'metabolite') continue;
        this.search_index.insert('n' + node_id, { 'name': node.bigg_id,
          'data': { type: 'metabolite',
            node_id: node_id } });
        this.search_index.insert('n_name' + node_id, { 'name': node.name,
          'data': { type: 'metabolite',
            node_id: node_id } });
      }
    }
    utils.extend(this.nodes, new_nodes);
  };

  /**
   * Add new reactions to data and search index.
   */


  Map.prototype.extend_reactions = function extend_reactions(new_reactions) {
    if (this.enable_search) {
      for (var r_id in new_reactions) {
        var reaction = new_reactions[r_id];
        this.search_index.insert('r' + r_id, { 'name': reaction.bigg_id,
          'data': { type: 'reaction',
            reaction_id: r_id } });
        this.search_index.insert('r_name' + r_id, { 'name': reaction.name,
          'data': { type: 'reaction',
            reaction_id: r_id } });
        for (var g_id in reaction.genes) {
          var gene = reaction.genes[g_id];
          this.search_index.insert('r' + r_id + '_g' + g_id, { 'name': gene.bigg_id,
            'data': { type: 'reaction',
              reaction_id: r_id } });
          this.search_index.insert('r' + r_id + '_g_name' + g_id, { 'name': gene.name,
            'data': { type: 'reaction',
              reaction_id: r_id } });
        }
      }
    }
    utils.extend(this.reactions, new_reactions);
  };

  Map.prototype._extend_and_draw_reaction = function _extend_and_draw_reaction(new_nodes, new_reactions, new_beziers, selected_node_id) {
    this.extend_reactions(new_reactions);
    utils.extend(this.beziers, new_beziers);
    // Remove the selected node so it can be updated
    this.delete_node_data([selected_node_id]); // TODO this is a hack. fix
    this.extend_nodes(new_nodes);

    // Apply the reaction and node data to the scales. If the scale changes,
    // redraw everything.
    var keys = Object.keys(new_reactions);
    if (this.has_data_on_reactions) {
      var scale_changed = false;
      if (this.imported_reaction_data) {
        scale_changed = this.apply_reaction_data_to_map(this.imported_reaction_data, keys);
      } else if (this.imported_gene_data) {
        scale_changed = this.apply_gene_data_to_map(this.imported_gene_data, keys);
      } else {
        throw new Error('imported_gene_data or imported_reaction_data should ' + 'not be null');
      }
      if (scale_changed) {
        this.draw_all_reactions(true, false);
      } else {
        this.draw_these_reactions(keys);
      }
    } else {
      this.draw_these_reactions(keys);
    }

    var node_keys = Object.keys(new_nodes);
    if (this.has_data_on_nodes) {
      if (this.imported_metabolite_data === null) {
        throw new Error('imported_metabolite_data should not be null');
      }
      var scale_changed = this.apply_metabolite_data_to_map(this.imported_metabolite_data, node_keys);
      if (scale_changed) {
        this.draw_all_nodes(false);
      } else {
        this.draw_these_nodes(node_keys);
      }
    } else {
      this.draw_these_nodes(node_keys);
    }

    // select new primary metabolite
    for (var node_id in new_nodes) {
      var node = new_nodes[node_id];
      if (node.node_is_primary && node_id != selected_node_id) {
        this.select_metabolite_with_id(node_id);
        var new_coords = { x: node.x, y: node.y };
        if (this.zoomContainer) {
          this.zoomContainer.translateOffScreen(new_coords);
        }
      }
    }
  };

  /**
   * Build a new reaction starting with selected_met. Undoable.
   * @param {String} reaction_bigg_id - The BiGG ID of the reaction to draw.
   * @param {String} selected_node_id - The ID of the node to begin drawing with.
   * @param {Number} direction - The direction to draw in.
   * @param {Boolean} [apply_undo_redo=true] - If true, then add to the undo
   * stack. Otherwise, just return the undo and redo functions.
   * @return An object of undo and redo functions:
   *   { undo: undo_function, redo: redo_function }
   */


  Map.prototype.new_reaction_for_metabolite = function new_reaction_for_metabolite(reaction_bigg_id, selected_node_id, direction, apply_undo_redo) {
    var _this4 = this;

    // default args
    if (apply_undo_redo === undefined) apply_undo_redo = true;

    // get the metabolite node
    var selected_node = this.nodes[selected_node_id];

    // Set reaction coordinates and angle. Be sure to copy the reaction
    // recursively.
    var cobra_reaction = this.cobra_model.reactions[reaction_bigg_id];

    // build the new reaction
    var out = build.newReaction(reaction_bigg_id, cobra_reaction, this.cobra_model.metabolites, selected_node_id, utils.clone(selected_node), this.largest_ids, this.settings.get('cofactors'), direction);
    var new_nodes = out.new_nodes;
    var new_reactions = out.new_reactions;
    var new_beziers = out.new_beziers;

    // Draw
    this._extend_and_draw_reaction(new_nodes, new_reactions, new_beziers, selected_node_id);

    // Clone the nodes and reactions, to redo this action later
    var saved_nodes = utils.clone(new_nodes);
    var saved_reactions = utils.clone(new_reactions);
    var saved_beziers = utils.clone(new_beziers);

    // Add to undo/redo stack
    var undo_fn = function undo_fn() {
      // Undo. Get the nodes to delete.
      delete new_nodes[selected_node_id];
      _this4.delete_node_data(Object.keys(new_nodes));
      _this4.delete_reaction_data(Object.keys(new_reactions)); // also deletes beziers
      _this4.select_metabolite_with_id(selected_node_id);
      // Save the nodes and reactions again, for redo
      new_nodes = utils.clone(saved_nodes);
      new_reactions = utils.clone(saved_reactions);
      new_beziers = utils.clone(saved_beziers);
      // Draw
      if (_this4.has_data_on_reactions) {
        var scale_changed = _this4.calc_data_stats('reaction');
        if (scale_changed) {
          _this4.draw_all_reactions(true, true);
        } else {
          // Also clears segments and beziers
          _this4.clear_deleted_reactions(true);
        }
      } else {
        // Also clears segments and beziers
        _this4.clear_deleted_reactions(true);
      }
      if (_this4.has_data_on_nodes) {
        var scaleChanged = _this4.calc_data_stats('metabolite');
        if (scaleChanged) {
          _this4.draw_all_nodes(true);
        } else {
          _this4.clear_deleted_nodes();
        }
      } else {
        _this4.clear_deleted_nodes();
      }
    };
    var redo_fn = function redo_fn() {
      // redo
      // clone the nodes and reactions, to redo this action later
      _this4._extend_and_draw_reaction(new_nodes, new_reactions, new_beziers, selected_node_id);
    };

    if (apply_undo_redo) {
      this.undo_stack.push(undo_fn, redo_fn);
    }

    return { undo: undo_fn, redo: redo_fn };
  };

  Map.prototype.cycle_primary_node = function cycle_primary_node() {
    var selected_nodes = this.getSelectedNodes();
    if (_underscore2.default.isEmpty(selected_nodes)) {
      return;
    }
    // Get the first node
    var node_id = Object.keys(selected_nodes)[0];
    var node = selected_nodes[node_id];
    var reactions = this.reactions;
    var nodes = this.nodes;
    // make the other reactants or products secondary
    // 1. Get the connected anchor nodes for the node
    var connected_anchor_ids = [],
        reactions_to_draw;
    nodes[node_id].connected_segments.forEach(function (segment_info) {
      reactions_to_draw = [segment_info.reaction_id];
      var segment;
      try {
        segment = reactions[segment_info.reaction_id].segments[segment_info.segment_id];
        if (segment === undefined) throw new Error('undefined segment');
      } catch (e) {
        console.warn('Could not find connected segment ' + segment_info.segment_id);
        return;
      }
      connected_anchor_ids.push(segment.from_node_id == node_id ? segment.to_node_id : segment.from_node_id);
    });
    // can only be connected to one anchor
    if (connected_anchor_ids.length != 1) {
      console.error('Only connected nodes with a single reaction can be selected');
      return;
    }
    var connected_anchor_id = connected_anchor_ids[0];
    // 2. find nodes connected to the anchor that are metabolites
    var related_node_ids = [node_id];
    var segments = [];
    nodes[connected_anchor_id].connected_segments.forEach(function (segment_info) {
      // deterministic order
      var segment;
      try {
        segment = reactions[segment_info.reaction_id].segments[segment_info.segment_id];
        if (segment === undefined) throw new Error('undefined segment');
      } catch (e) {
        console.warn('Could not find connected segment ' + segment_info.segment_id);
        return;
      }
      var conn_met_id = segment.from_node_id == connected_anchor_id ? segment.to_node_id : segment.from_node_id,
          conn_node = nodes[conn_met_id];
      if (conn_node.node_type == 'metabolite' && conn_met_id != node_id) {
        related_node_ids.push(String(conn_met_id));
      }
    });
    // 3. make sure they only have 1 reaction connection, and check if
    // they match the other selected nodes
    for (var i = 0; i < related_node_ids.length; i++) {
      if (nodes[related_node_ids[i]].connected_segments.length > 1) {
        console.error('Only connected nodes with a single reaction can be selected');
        return;
      }
    }
    for (var a_selected_node_id in selected_nodes) {
      if (a_selected_node_id != node_id && related_node_ids.indexOf(a_selected_node_id) == -1) {
        console.warn('Selected nodes are not on the same reaction');
        return;
      }
    }
    // 4. change the primary node, and change coords, label coords, and beziers
    var nodes_to_draw = [],
        last_i = related_node_ids.length - 1,
        last_node = nodes[related_node_ids[last_i]],
        last_is_primary = last_node.node_is_primary,
        last_coords = { x: last_node.x, y: last_node.y,
      label_x: last_node.label_x, label_y: last_node.label_y };
    if (last_node.connected_segments.length > 1) console.warn('Too many connected segments for node ' + last_node.node_id);
    var last_segment_info = last_node.connected_segments[0],
        // guaranteed above to have only one
    last_segment;
    try {
      last_segment = reactions[last_segment_info.reaction_id].segments[last_segment_info.segment_id];
      if (last_segment === undefined) throw new Error('undefined segment');
    } catch (e) {
      console.error('Could not find connected segment ' + last_segment_info.segment_id);
      return;
    }
    var last_bezier = { b1: last_segment.b1, b2: last_segment.b2 },
        primary_node_id;
    related_node_ids.forEach(function (related_node_id) {
      var node = nodes[related_node_id],
          this_is_primary = node.node_is_primary,
          these_coords = { x: node.x, y: node.y,
        label_x: node.label_x, label_y: node.label_y },
          this_segment_info = node.connected_segments[0],
          this_segment = reactions[this_segment_info.reaction_id].segments[this_segment_info.segment_id],
          this_bezier = { b1: this_segment.b1, b2: this_segment.b2 };
      node.node_is_primary = last_is_primary;
      node.x = last_coords.x;node.y = last_coords.y;
      node.label_x = last_coords.label_x;node.label_y = last_coords.label_y;
      this_segment.b1 = last_bezier.b1;this_segment.b2 = last_bezier.b2;
      last_is_primary = this_is_primary;
      last_coords = these_coords;
      last_bezier = this_bezier;
      if (node.node_is_primary) primary_node_id = related_node_id;
      nodes_to_draw.push(related_node_id);
    });
    // 5. cycle the connected_segments array so the next time, it cycles differently
    var old_connected_segments = nodes[connected_anchor_id].connected_segments,
        last_i = old_connected_segments.length - 1,
        new_connected_segments = [old_connected_segments[last_i]];
    old_connected_segments.forEach(function (segment, i) {
      if (last_i == i) return;
      new_connected_segments.push(segment);
    });
    nodes[connected_anchor_id].connected_segments = new_connected_segments;
    // 6. draw the nodes
    this.draw_these_nodes(nodes_to_draw);
    this.draw_these_reactions(reactions_to_draw);
    // 7. select the primary node
    this.select_metabolite_with_id(primary_node_id);
    return;
  };

  /**
   * Toggle the primary/secondary status of each selected node. Undoable.
   */


  Map.prototype.toggle_selected_node_primary = function toggle_selected_node_primary() {
    var selected_node_ids = this.get_selected_node_ids();
    var go = function (ids) {
      var nodes_to_draw = {};
      var hide_secondary_metabolites = this.settings.get('hide_secondary_metabolites');
      ids.forEach(function (id) {
        if (!(id in this.nodes)) {
          console.warn('Could not find node: ' + id);
          return;
        }
        var node = this.nodes[id];
        if (node.node_type == 'metabolite') {
          node.node_is_primary = !node.node_is_primary;
          nodes_to_draw[id] = node;
        }
      }.bind(this));
      // draw the nodes
      this.draw_these_nodes(Object.keys(nodes_to_draw));
      // draw associated reactions
      if (hide_secondary_metabolites) {
        var out = this.segments_and_reactions_for_nodes(nodes_to_draw),
            reaction_ids_to_draw_o = {};
        for (var id in out.segment_objs_w_segments) {
          var r_id = out.segment_objs_w_segments[id].reaction_id;
          reaction_ids_to_draw_o[r_id] = true;
        }
        this.draw_these_reactions(Object.keys(reaction_ids_to_draw_o));
      }
    }.bind(this);

    // go
    go(selected_node_ids);

    // add to the undo stack
    this.undo_stack.push(function () {
      go(selected_node_ids);
    }, function () {
      go(selected_node_ids);
    });
  };

  Map.prototype.segments_and_reactions_for_nodes = function segments_and_reactions_for_nodes(nodes) {
    /** Get segments and reactions that should be deleted with node deletions
      */
    var segment_objs_w_segments = {},
        these_reactions = {},
        segment_ids_for_reactions = {},
        reactions = this.reactions;
    // for each node
    for (var node_id in nodes) {
      var node = nodes[node_id];
      // find associated segments and reactions
      node.connected_segments.forEach(function (segment_obj) {
        var segment;
        try {
          segment = reactions[segment_obj.reaction_id].segments[segment_obj.segment_id];
          if (segment === undefined) throw new Error('undefined segment');
        } catch (e) {
          console.warn('Could not find connected segments for node');
          return;
        }
        var segment_obj_w_segment = utils.clone(segment_obj);
        segment_obj_w_segment['segment'] = utils.clone(segment);
        segment_objs_w_segments[segment_obj.segment_id] = segment_obj_w_segment;
        if (!(segment_obj.reaction_id in segment_ids_for_reactions)) segment_ids_for_reactions[segment_obj.reaction_id] = [];
        segment_ids_for_reactions[segment_obj.reaction_id].push(segment_obj.segment_id);
      });
    }
    // find the reactions that should be deleted because they have no segments left
    for (var reaction_id in segment_ids_for_reactions) {
      var reaction = reactions[reaction_id],
          these_ids = segment_ids_for_reactions[reaction_id],
          has = true;
      for (var segment_id in reaction.segments) {
        if (these_ids.indexOf(segment_id) == -1) has = false;
      }
      if (has) these_reactions[reaction_id] = reaction;
    }
    return { segment_objs_w_segments: segment_objs_w_segments, reactions: these_reactions };
  };

  Map.prototype.add_label_to_search_index = function add_label_to_search_index(id, text) {
    this.search_index.insert('l' + id, {
      name: text,
      data: { type: 'text_label', text_label_id: id }
    });
  };

  Map.prototype.new_text_label = function new_text_label(coords, text) {
    // Make an label
    var out = build.newTextLabel(this.largest_ids, text, coords);
    this.text_labels[out.id] = out.label;
    this.draw_these_text_labels([out.id]);
    // Add to the search index
    if (text !== '') {
      this.add_label_to_search_index(out.id, text);
    }
    return out.id;
  };

  /**
   * Edit a text label. Undoable.
   * @param {} text_label_id -
   * @param {String} new_value -
   * @param {Boolean} should_draw -
   * @param {Boolean} [is_new=false] - If true, then the text label is all new, so
   * delete it on undo and create it again on redo.
   */


  Map.prototype.edit_text_label = function edit_text_label(text_label_id, new_value, should_draw, is_new) {
    if (_underscore2.default.isUndefined(is_new)) is_new = false;

    if (new_value === '') {
      throw new Error('Should not be called for empty string');
    }

    var edit_and_draw = function (new_val, should_draw) {
      // set the new value
      var label = this.text_labels[text_label_id];
      label.text = new_val;
      if (should_draw) {
        this.draw_these_text_labels([text_label_id]);
      }
      // Update in the search index
      var record_id = 'l' + text_label_id;
      var found = this.search_index.remove(record_id);
      if (!is_new && !found) {
        console.warn('Could not find modified text label in search index');
      }
      this.search_index.insert(record_id, {
        name: new_val,
        data: { type: 'text_label', text_label_id: text_label_id }
      });
    }.bind(this);

    // Save old value
    var saved_label = utils.clone(this.text_labels[text_label_id]);

    // Edit the label
    edit_and_draw(new_value, should_draw);

    // Add to undo stack
    this.undo_stack.push(function () {
      if (is_new) {
        this.delete_text_label_data([text_label_id]);
        this.clear_deleted_text_labels();
      } else {
        edit_and_draw(saved_label.text, true);
      }
    }.bind(this), function () {
      if (is_new) {
        this.text_labels[text_label_id] = utils.clone(saved_label);
        this.text_labels[text_label_id].text = new_value;
        this.draw_these_text_labels([text_label_id]);
        this.add_label_to_search_index(text_label_id, new_value);
      } else {
        edit_and_draw(new_value, true);
      }
    }.bind(this));
  };

  // -------------------------------------------------------------------------
  // Zoom
  // -------------------------------------------------------------------------

  /**
   * Zoom to fit all the nodes. Returns error if one is raised.
   * @param {} margin - optional argument to set the margins as a fraction of
   * height.
   */


  Map.prototype.zoom_extent_nodes = function zoom_extent_nodes(margin) {
    this._zoom_extent(margin, 'nodes');
  };

  /**
   * Zoom to fit the canvas. Returns error if one is raised.
   * @param {} margin - optional argument to set the margins as a fraction of
   * height.
   */


  Map.prototype.zoom_extent_canvas = function zoom_extent_canvas(margin) {
    this._zoom_extent(margin, 'canvas');
  };

  /**
   * Zoom to fit the canvas or all the nodes. Returns error if one is raised.
   * @param {} margin - optional argument to set the margins.
   * @param {} mode - Values are 'nodes', 'canvas'.
   */


  Map.prototype._zoom_extent = function _zoom_extent(margin, mode) {
    // Optional args
    if (_underscore2.default.isUndefined(margin)) margin = mode === 'nodes' ? 0.2 : 0;
    if (_underscore2.default.isUndefined(mode)) mode = 'canvas';

    var new_zoom;
    var new_pos;
    var size = this.get_size();
    // scale margin to window size
    margin = margin * size.height;

    if (mode === 'nodes') {
      // get the extent of the nodes
      var min = { x: null, y: null // TODO make infinity?
      };var max = { x: null, y: null };
      for (var node_id in this.nodes) {
        var node = this.nodes[node_id];
        if (min.x === null) min.x = node.x;
        if (min.y === null) min.y = node.y;
        if (max.x === null) max.x = node.x;
        if (max.y === null) max.y = node.y;

        min.x = Math.min(min.x, node.x);
        min.y = Math.min(min.y, node.y);
        max.x = Math.max(max.x, node.x);
        max.y = Math.max(max.y, node.y);
      }
      // set the zoom
      new_zoom = Math.min((size.width - margin * 2) / (max.x - min.x), (size.height - margin * 2) / (max.y - min.y));
      new_pos = { x: -(min.x * new_zoom) + margin + (size.width - margin * 2 - (max.x - min.x) * new_zoom) / 2,
        y: -(min.y * new_zoom) + margin + (size.height - margin * 2 - (max.y - min.y) * new_zoom) / 2 };
    } else if (mode == 'canvas') {
      // center the canvas
      new_zoom = Math.min((size.width - margin * 2) / this.canvas.width, (size.height - margin * 2) / this.canvas.height);
      new_pos = { x: -(this.canvas.x * new_zoom) + margin + (size.width - margin * 2 - this.canvas.width * new_zoom) / 2,
        y: -(this.canvas.y * new_zoom) + margin + (size.height - margin * 2 - this.canvas.height * new_zoom) / 2 };
    } else {
      return console.error('Did not recognize mode');
    }
    this.zoomContainer.goTo(new_zoom, new_pos);
    return null;
  };

  Map.prototype.get_size = function get_size() {
    return this.zoomContainer.get_size();
  };

  Map.prototype.zoom_to_reaction = function zoom_to_reaction(reaction_id) {
    var reaction = this.reactions[reaction_id],
        new_zoom = 0.5,
        size = this.get_size(),
        new_pos = { x: -reaction.label_x * new_zoom + size.width / 2,
      y: -reaction.label_y * new_zoom + size.height / 2 };
    this.zoomContainer.goTo(new_zoom, new_pos);
  };

  Map.prototype.zoom_to_node = function zoom_to_node(node_id) {
    var node = this.nodes[node_id];
    var new_zoom = 0.5;
    var size = this.get_size();
    var new_pos = {
      x: -node.label_x * new_zoom + size.width / 2,
      y: -node.label_y * new_zoom + size.height / 2
    };
    this.zoomContainer.goTo(new_zoom, new_pos);
  };

  Map.prototype.zoom_to_text_label = function zoom_to_text_label(text_label_id) {
    var text_label = this.text_labels[text_label_id];
    var new_zoom = 0.5;
    var size = this.get_size();
    var new_pos = {
      x: -text_label.x * new_zoom + size.width / 2,
      y: -text_label.y * new_zoom + size.height / 2
    };
    this.zoomContainer.goTo(new_zoom, new_pos);
  };

  Map.prototype.highlight_reaction = function highlight_reaction(reaction_id) {
    this.highlight(this.sel.selectAll('#r' + reaction_id).selectAll('text'));
  };

  Map.prototype.highlight_node = function highlight_node(node_id) {
    this.highlight(this.sel.selectAll('#n' + node_id).selectAll('text'));
  };

  Map.prototype.highlight_text_label = function highlight_text_label(text_label_id) {
    this.highlight(this.sel.selectAll('#l' + text_label_id).selectAll('text'));
  };

  Map.prototype.highlight = function highlight(sel) {
    this.sel.selectAll('.highlight').classed('highlight', false);
    if (sel !== null) {
      sel.classed('highlight', true);
    }
  };

  // -------------------------------------------------------------------------
  // IO
  // -------------------------------------------------------------------------

  Map.prototype.save = function save() {
    utils.download_json(this.map_for_export(), this.map_name);
  };

  Map.prototype.map_for_export = function map_for_export() {
    var out = [{ map_name: this.map_name,
      map_id: this.map_id,
      map_description: this.map_description,
      homepage: "https://escher.github.io",
      schema: "https://escher.github.io/escher/jsonschema/1-0-0#"
    }, { reactions: utils.clone(this.reactions),
      nodes: utils.clone(this.nodes),
      text_labels: utils.clone(this.text_labels),
      canvas: this.canvas.sizeAndLocation() }];

    // remove extra data
    for (var r_id in out[1].reactions) {
      var reaction = out[1].reactions[r_id];
      var new_reaction = {};
      var attrs = ['name', 'bigg_id', 'reversibility', 'label_x', 'label_y', 'gene_reaction_rule', 'genes', 'metabolites'];
      attrs.forEach(function (attr) {
        new_reaction[attr] = reaction[attr];
      });
      new_reaction['segments'] = {};
      for (var s_id in reaction.segments) {
        var segment = reaction.segments[s_id];
        var new_segment = {};
        var attrs = ['from_node_id', 'to_node_id', 'b1', 'b2'];
        attrs.forEach(function (attr) {
          new_segment[attr] = segment[attr];
        });
        new_reaction['segments'][s_id] = new_segment;
      }
      out[1].reactions[r_id] = new_reaction;
    }
    for (var n_id in out[1].nodes) {
      var node = out[1].nodes[n_id];
      var new_node = {};
      var attrs;
      if (node.node_type === 'metabolite') {
        attrs = ['node_type', 'x', 'y', 'bigg_id', 'name', 'label_x', 'label_y', 'node_is_primary'];
      } else {
        attrs = ['node_type', 'x', 'y'];
      }
      attrs.forEach(function (attr) {
        new_node[attr] = node[attr];
      });
      out[1].nodes[n_id] = new_node;
    }
    for (var t_id in out[1].text_labels) {
      var text_label = out[1].text_labels[t_id];
      var new_text_label = {};
      var attrs = ['x', 'y', 'text'];
      attrs.forEach(function (attr) {
        new_text_label[attr] = text_label[attr];
      });
      out[1].text_labels[t_id] = new_text_label;
    }
    // canvas
    var canvas_el = out[1].canvas;
    var new_canvas_el = {};
    var attrs = ['x', 'y', 'width', 'height'];
    attrs.forEach(function (attr) {
      new_canvas_el[attr] = canvas_el[attr];
    });
    out[1].canvas = new_canvas_el;

    return out;
  };

  /**
   * Rescale the canvas and save as svg/png.
   */


  Map.prototype.saveMap = function saveMap(callbackBefore, callbackAfter, mapType) {
    var _this5 = this;

    // Run the before callback
    this.callback_manager.run(callbackBefore);

    // Turn off zoom and translate so that illustrator likes the map
    var windowScale = this.zoomContainer.windowScale;
    var windowTranslate = this.zoomContainer.windowTranslate;
    var canvasSizeAndLoc = this.canvas.sizeAndLocation();
    var mouseNodeSizeAndTrans = {
      w: this.canvas.mouseNode.attr('width'),
      h: this.canvas.mouseNode.attr('height'),
      transform: this.canvas.mouseNode.attr('transform')
    };

    this.zoomContainer._goToSvg(1.0, { x: -canvasSizeAndLoc.x, y: -canvasSizeAndLoc.y }, function () {
      _this5.svg.attr('width', canvasSizeAndLoc.width);
      _this5.svg.attr('height', canvasSizeAndLoc.height);
      _this5.canvas.mouseNode.attr('width', '0px');
      _this5.canvas.mouseNode.attr('height', '0px');
      _this5.canvas.mouseNode.attr('transform', null);

      // hide the segment control points
      var hidden_sel = _this5.sel.selectAll('.multimarker-circle,.midmarker-circle,#canvas,.bezier,#rotation-center,.direction-arrow,.start-reaction-target').style('visibility', 'hidden');

      // do the export
      if (mapType === 'svg') {
        utils.downloadSvg('saved_map', _this5.svg, true);
      } else if (mapType === 'png') {
        utils.downloadPng('saved_map', _this5.svg);
      }

      // revert everything
      _this5.zoomContainer._goToSvg(windowScale, windowTranslate, function () {
        _this5.svg.attr('width', null);
        _this5.svg.attr('height', null);
        _this5.canvas.mouseNode.attr('width', mouseNodeSizeAndTrans.w);
        _this5.canvas.mouseNode.attr('height', mouseNodeSizeAndTrans.h);
        _this5.canvas.mouseNode.attr('transform', mouseNodeSizeAndTrans.transform);
        // unhide the segment control points
        hidden_sel.style('visibility', null);

        // run the after callback
        _this5.callback_manager.run(callbackAfter);
      });
    });
  };

  Map.prototype.save_svg = function save_svg() {
    this.saveMap('before_svg_export', 'after_svg_export', 'svg');
  };

  Map.prototype.save_png = function save_png() {
    this.saveMap('before_png_export', 'after_png_export', 'png');
  };

  /**
   * Assign the descriptive names and gene_reaction_rules from the model to the
   * map. If no map is loaded, then throw an Error. If some reactions are not in
   * the model, then warn in the status.
   */


  Map.prototype.convert_map = function convert_map() {
    var _this6 = this;

    // Run the before callback
    this.callback_manager.run('before_convert_map');

    // Check the model
    if (!this.has_cobra_model()) {
      throw Error('No COBRA model loaded.');
    }
    var model = this.cobra_model;

    // IDs for reactions and metabolites not found in the model
    var reactions_not_found = {};
    var reaction_attrs = ['name', 'gene_reaction_rule', 'genes'];
    var met_nodes_not_found = {};
    var metabolite_attrs = ['name'];
    var found = false;
    // convert reactions
    for (var reaction_id in this.reactions) {
      var reaction = this.reactions[reaction_id];
      found = false;
      // find in cobra model

      var _loop2 = function _loop2() {
        var modelReaction = model.reactions[model_reaction_id];
        if (modelReaction.bigg_id == reaction.bigg_id) {
          reaction_attrs.forEach(function (attr) {
            reaction[attr] = modelReaction[attr];
          });
          // check matching metabolites & warn if not matching. if matching, check
          // & reverse
          var matches = true;
          var looksReversed = null;

          var _loop3 = function _loop3(metId) {
            var modelCoeff = modelReaction.metabolites[metId];
            var mapMet = _underscore2.default.find(reaction.metabolites, function (x) {
              return x.bigg_id === metId;
            });
            if (mapMet === undefined) {
              matches = false;
              return 'break';
            }
            var mapCoeff = mapMet.coefficient;
            // keep track of whether any of these are reversed
            if (looksReversed === null) {
              looksReversed = modelCoeff > 0 !== mapCoeff > 0;
            }
            // make sure there are no mismatches in reversibility direction
            if (looksReversed === true && modelCoeff > 0 === mapCoeff > 0 || looksReversed === false && modelCoeff > 0 !== mapCoeff > 0) {
              matches = false;
              return 'break';
            }
          };

          for (var metId in modelReaction.metabolites) {
            var _ret3 = _loop3(metId);

            if (_ret3 === 'break') break;
          }
          if (looksReversed && matches) {
            // looks reversed with not mismatches, then reverse the direction
            reaction.metabolites.forEach(function (met) {
              met.coefficient = -met.coefficient;
            });
            // propagate changes into segments

            var _loop4 = function _loop4() {
              var segment = reaction.segments[segmentId];

              // propagate reversibility
              segment.reversibility = reaction.reversibility;

              var from_node = _this6.nodes[segment.from_node_id];
              var to_node = _this6.nodes[segment.to_node_id];

              // propagate coefficients
              reaction.metabolites.forEach(function (met) {
                if (met.bigg_id === from_node.bigg_id) {
                  segment.from_node_coefficient = met.coefficient;
                } else if (met.bigg_id === to_node.bigg_id) {
                  segment.to_node_coefficient = met.coefficient;
                }
              });
            };

            for (segmentId in reaction.segments) {
              _loop4();
            }
          }
          if (!matches) {
            console.warn('Metabolites for ' + modelReaction.bigg_id + ' are different in model and map. Could\n not check and fix direction.');
            return 'break';
          }
          found = true;
        }
      };

      for (var model_reaction_id in model.reactions) {
        var segmentId;

        var _ret2 = _loop2();

        if (_ret2 === 'break') break;
      }
      if (!found) reactions_not_found[reaction_id] = true;
    }
    // convert metabolites
    for (var node_id in this.nodes) {
      var node = this.nodes[node_id];
      // only look at metabolites
      if (node.node_type != 'metabolite') continue;
      found = false;
      // find in cobra model
      for (var model_metabolite_id in model.metabolites) {
        var model_metabolite = model.metabolites[model_metabolite_id];
        if (model_metabolite.bigg_id == node.bigg_id) {
          metabolite_attrs.forEach(function (attr) {
            node[attr] = model_metabolite[attr];
          });
          found = true;
        }
      }
      if (!found) met_nodes_not_found[node_id] = true;
    }

    // status
    var n_reactions_not_found = Object.keys(reactions_not_found).length;
    var n_met_nodes_not_found = Object.keys(met_nodes_not_found).length;
    var status_delay = 10000;
    if (n_reactions_not_found === 0 && n_met_nodes_not_found === 0) {
      this.set_status('Successfully converted attributes.', status_delay);
    } else if (n_met_nodes_not_found === 0) {
      this.set_status('Converted attributes, but count not find ' + n_reactions_not_found + ' reactions in the model.', status_delay);
      this.settings.set('highlight_missing', true);
    } else if (n_reactions_not_found === 0) {
      this.set_status('Converted attributes, but count not find ' + n_met_nodes_not_found + ' metabolites in the model.', status_delay);
      this.settings.set('highlight_missing', true);
    } else {
      this.set_status('Converted attributes, but count not find ' + n_reactions_not_found + ' reactions and ' + n_met_nodes_not_found + ' metabolites in the model.', status_delay);
      this.settings.set('highlight_missing', true);
    }

    // redraw
    this.draw_everything();

    // run the after callback
    this.callback_manager.run('after_convert_map');
  };

  return Map;
}();

exports.default = Map;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(4);

var _utils2 = _interopRequireDefault(_utils);

var _build = __webpack_require__(49);

var build = _interopRequireWildcard(_build);

var _d3Drag = __webpack_require__(22);

var _d3Selection = __webpack_require__(2);

var d3Selection = _interopRequireWildcard(_d3Selection);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var d3Select = d3Selection.select;
var d3Mouse = d3Selection.mouse;
var d3Touch = d3Selection.touch;

/**
 * Behavior. Defines the set of click and drag behaviors for the map, and keeps
 * track of which behaviors are activated.
 * @param map {Map} -
 * @param undoStack {UndoStack} -
 */

var Behavior = function () {
  function Behavior(map, undoStack) {
    _classCallCheck(this, Behavior);

    this.map = map;
    this.undoStack = undoStack;

    // make an empty function that can be called as a behavior and does nothing
    this.emptyBehavior = function () {};

    // rotation mode operates separately from the rest
    this.rotationModeEnabled = false;
    this.rotationDrag = (0, _d3Drag.drag)();

    // behaviors to be applied
    this.selectableMousedown = null;
    this.textLabelMousedown = null;
    this.textLabelClick = null;
    this.selectableDrag = this.emptyBehavior;

    this.nodeLabelMouseover = null;
    this.nodeLabelTouch = null;
    this.nodeLabelMouseout = null;
    this.reactionLabelMouseover = null;
    this.reactionLabelTouch = null;
    this.reactionLabelMouseout = null;
    this.geneLabelMouseover = null;
    this.geneLabelTouch = null;
    this.geneLabelMouseout = null;

    this.nodeObjectMouseover = null;
    this.nodeObjectMouseout = null;
    this.reactionObjectMouseover = null;
    this.reactionObjectMouseout = null;

    this.bezierDrag = this.emptyBehavior;
    this.bezierMouseover = null;
    this.bezierMouseout = null;
    this.reactionLabelDrag = this.emptyBehavior;
    this.nodeLabelDrag = this.emptyBehavior;
    this.dragging = false;
  }

  Behavior.prototype.averageLocation = function averageLocation(nodes) {
    var xs = [];
    var ys = [];
    for (var nodeId in nodes) {
      var node = nodes[nodeId];
      if (node.x !== undefined) xs.push(node.x);
      if (node.y !== undefined) ys.push(node.y);
    }
    return {
      x: _utils2.default.mean(xs),
      y: _utils2.default.mean(ys)
    };
  };

  Behavior.prototype.showCenter = function showCenter() {
    var _this = this;

    var sel = this.map.sel.selectAll('#rotation-center').data([0]);
    var enterSel = sel.enter().append('g').attr('id', 'rotation-center');

    enterSel.append('path').attr('d', 'M-32 0 L32 0').attr('class', 'rotation-center-line');
    enterSel.append('path').attr('d', 'M0 -32 L0 32').attr('class', 'rotation-center-line');

    var updateSel = enterSel.merge(sel);

    updateSel.attr('transform', 'translate(' + this.center.x + ',' + this.center.y + ')').attr('visibility', 'visible').on('mouseover', function () {
      var current = parseFloat(updateSel.selectAll('path').style('stroke-width'));
      updateSel.selectAll('path').style('stroke-width', current * 2 + 'px');
    }).on('mouseout', function () {
      updateSel.selectAll('path').style('stroke-width', null);
    }).call((0, _d3Drag.drag)().on('drag', function () {
      var cur = _utils2.default.d3_transform_catch(updateSel.attr('transform'));
      var newLoc = [d3Selection.event.dx + cur.translate[0], d3Selection.event.dy + cur.translate[1]];
      updateSel.attr('transform', 'translate(' + newLoc + ')');
      _this.center = { x: newLoc[0], y: newLoc[1] };
    }));
  };

  Behavior.prototype.hideCenter = function hideCenter() {
    this.map.sel.select('#rotation-center').attr('visibility', 'hidden');
  };

  /**
   * Listen for rotation, and rotate selected nodes.
   */


  Behavior.prototype.toggleRotationMode = function toggleRotationMode(onOff) {
    var _this2 = this;

    if (onOff === undefined) {
      this.rotationModeEnabled = !this.rotationModeEnabled;
    } else {
      this.rotationModeEnabled = onOff;
    }

    var selectionNode = this.map.sel.selectAll('.node-circle');
    var selectionBackground = this.map.sel.selectAll('#canvas');

    if (this.rotationModeEnabled) {
      var selectedNodes = this.map.getSelectedNodes();
      if (Object.keys(selectedNodes).length === 0) {
        console.warn('No selected nodes');
        return;
      }

      // show center
      this.center = this.averageLocation(selectedNodes);
      this.showCenter();

      // this.setStatus('Drag to rotate.')
      var map = this.map;
      var selectedNodeIds = Object.keys(selectedNodes);
      var reactions = this.map.reactions;
      var nodes = this.map.nodes;
      var beziers = this.map.beziers;

      var startFn = function startFn(d) {
        // silence other listeners
        d3Selection.event.sourceEvent.stopPropagation();
      };
      var dragFn = function dragFn(d, angle, totalAngle, center) {
        var updated = build.rotateNodes(selectedNodes, reactions, beziers, angle, center);
        map.draw_these_nodes(updated.node_ids);
        map.draw_these_reactions(updated.reaction_ids);
      };
      var endFn = function endFn(d) {};
      var undoFn = function undoFn(d, totalAngle, center) {
        // undo
        var theseNodes = {};
        selectedNodeIds.forEach(function (id) {
          theseNodes[id] = nodes[id];
        });
        var updated = build.rotateNodes(theseNodes, reactions, beziers, -totalAngle, center);
        map.draw_these_nodes(updated.node_ids);
        map.draw_these_reactions(updated.reaction_ids);
      };
      var redoFn = function redoFn(d, totalAngle, center) {
        // redo
        var theseNodes = {};
        selectedNodeIds.forEach(function (id) {
          theseNodes[id] = nodes[id];
        });
        var updated = build.rotatenodes(theseNodes, reactions, beziers, totalAngle, center);
        map.draw_these_nodes(updated.node_ids);
        map.draw_these_reactions(updated.reaction_ids);
      };
      var centerFn = function centerFn() {
        return _this2.center;
      };
      this.rotationDrag = this.getGenericAngularDrag(startFn, dragFn, endFn, undoFn, redoFn, centerFn, this.map.sel);
      selectionBackground.call(this.rotationDrag);
      this.selectableDrag = this.rotationDrag;
    } else {
      // turn off all listeners
      this.hideCenter();
      selectionNode.on('mousedown.center', null);
      selectionBackground.on('mousedown.center', null);
      selectionBackground.on('mousedown.drag', null);
      selectionBackground.on('touchstart.drag', null);
      this.rotationDrag = null;
      this.selectableDrag = null;
    }
  };

  /**
   * With no argument, toggle the node click on or off. Pass in a boolean argument
   * to set the on/off state.
   */


  Behavior.prototype.toggleSelectableClick = function toggleSelectableClick(onOff) {
    if (onOff === undefined) {
      onOff = this.selectableMousedown === null;
    }
    if (onOff) {
      var map = this.map;
      this.selectableMousedown = function (d) {
        // stop propogation for the buildinput to work right
        d3Selection.event.stopPropagation();
        // this.parentNode.__data__.wasSelected = d3Select(this.parentNode).classed('selected')
        // d3Select(this.parentNode).classed('selected', true)
      };
      this.selectableClick = function (d) {
        // stop propogation for the buildinput to work right
        d3Selection.event.stopPropagation();
        // click suppressed. This DOES have en effect.
        if (d3Selection.event.defaultPrevented) return;
        // turn off the temporary selection so select_selectable
        // works. This is a bit of a hack.
        // if (!this.parentNode.__data__.wasSelected)
        //     d3Select(this.parentNode).classed('selected', false)
        map.select_selectable(this, d, d3Selection.event.shiftKey);
        // this.parentNode.__data__.wasSelected = false
      };
      this.nodeMouseover = function (d) {
        d3Select(this).style('stroke-width', null);
        var current = parseFloat(d3Select(this).style('stroke-width'));
        if (!d3Select(this.parentNode).classed('selected')) {
          d3Select(this).style('stroke-width', current * 3 + 'px');
        }
      };
      this.nodeMouseout = function (d) {
        d3Select(this).style('stroke-width', null);
      };
    } else {
      this.selectableMousedown = null;
      this.selectableClick = null;
      this.nodeMouseover = null;
      this.nodeMouseout = null;
      this.map.sel.select('#nodes').selectAll('.node-circle').style('stroke-width', null);
    }
  };

  /**
   * With no argument, toggle the text edit on mousedown on/off. Pass in a boolean
   * argument to set the on/off state. The backup state is equal to
   * selectableMousedown.
   */


  Behavior.prototype.toggleTextLabelEdit = function toggleTextLabelEdit(onOff) {
    if (onOff === undefined) {
      onOff = this.textEditMousedown == null;
    }
    if (onOff) {
      var map = this.map;
      this.textLabelMousedown = function () {
        if (d3Selection.event.defaultPrevented) {
          return; // mousedown suppressed
        }
        // run the callback
        var coordsA = _utils2.default.d3_transform_catch(d3Select(this).attr('transform')).translate;
        var coords = { x: coordsA[0], y: coordsA[1] };
        map.callback_manager.run('edit_text_label', null, d3Select(this), coords);
        d3Selection.event.stopPropagation();
      };
      this.textLabelClick = null;
      this.map.sel.select('#text-labels').selectAll('.label').style('cursor', 'text');
      // add the new-label listener
      this.map.sel.on('mousedown.new_text_label', function (node) {
        // silence other listeners
        d3Selection.event.preventDefault();
        var coords = {
          x: d3Mouse(node)[0],
          y: d3Mouse(node)[1]
        };
        this.map.callback_manager.run('new_text_label', null, coords);
      }.bind(this, this.map.sel.node()));
    } else {
      this.textLabelMousedown = this.selectableMousedown;
      this.textLabelClick = this.selectableClick;
      this.map.sel.select('#text-labels').selectAll('.label').style('cursor', null);
      // remove the new-label listener
      this.map.sel.on('mousedown.new_text_label', null);
      this.map.callback_manager.run('hide_text_label_editor');
    }
  };

  /**
   * With no argument, toggle the node drag & bezier drag on or off. Pass in a
   * boolean argument to set the on/off state.
   */


  Behavior.prototype.toggleSelectableDrag = function toggleSelectableDrag(onOff) {
    if (onOff === undefined) {
      onOff = this.selectableDrag === this.emptyBehavior;
    }
    if (onOff) {
      this.selectableDrag = this.getSelectableDrag(this.map, this.undoStack);
      this.bezierDrag = this.getBezierDrag(this.map, this.undoStack);
    } else {
      this.selectableDrag = this.emptyBehavior;
      this.bezierDrag = this.emptyBehavior;
    }
  };

  /**
   * With no argument, toggle the label drag on or off. Pass in a boolean argument
   * to set the on/off state.
   * @param {Boolean} onOff - The new on/off state.
   */


  Behavior.prototype.toggleLabelDrag = function toggleLabelDrag(onOff) {
    if (onOff === undefined) {
      onOff = this.labelDrag === this.emptyBehavior;
    }
    if (onOff) {
      this.reactionLabelDrag = this.getReactionLabelDrag(this.map);
      this.nodeLabelDrag = this.getNodeLabelDrag(this.map);
    } else {
      this.reactionLabelDrag = this.emptyBehavior;
      this.nodeLabelDrag = this.emptyBehavior;
    }
  };

  /**
   * With no argument, toggle the tooltips on mouseover labels.
   * @param {Boolean} onOff - The new on/off state.
   */


  Behavior.prototype.toggleLabelMouseover = function toggleLabelMouseover(onOff) {
    var _this3 = this;

    if (onOff === undefined) {
      onOff = this.nodeLabelMouseover === null;
    }

    if (onOff) {
      // Show/hide tooltip.
      // @param {String} type - 'reactionLabel' or 'nodeLabel'
      // @param {Object} d - D3 data for DOM element
      var getMouseover = function getMouseover(type) {
        return function (d) {
          if (!_this3.dragging) {
            _this3.map.callback_manager.run('show_tooltip', null, type, d);
          }
        };
      };
      var mouseout = function mouseout() {
        _this3.map.callback_manager.run('delay_hide_tooltip');
      };
      this.nodeLabelMouseover = getMouseover('node_label');
      this.nodeLabelTouch = getMouseover('node_label');
      this.nodeLabelMouseout = mouseout;
      this.reactionLabelMouseover = getMouseover('reaction_label');
      this.reactionLabelTouch = getMouseover('reaction_label');
      this.reactionLabelMouseout = mouseout;
      this.geneLabelMouseover = getMouseover('gene_label');
      this.geneLabelTouch = getMouseover('gene_label');
      this.geneLabelMouseout = mouseout;
    } else {
      this.nodeLabelMouseover = null;
      this.nodeLabelTouch = null;
      this.nodeLabelMouseout = null;
      this.reactionLabelMouseover = null;
      this.reactionLabelTouch = null;
      this.reactionLabelMouseout = null;
      this.geneLabelMouseover = null;
      this.geneLabelTouch = null;
      this.geneLabelMouseout = null;
    }
  };

  /**
   * With no argument, toggle the tooltips on mouseover of nodes or arrows.
   * @param {Boolean} onOff - The new on/off state.
   */


  Behavior.prototype.toggleObjectMouseover = function toggleObjectMouseover(onOff) {
    var _this4 = this;

    if (onOff === undefined) {
      onOff = this.nodeObjectMouseover === null;
    }

    if (onOff) {
      // Show/hide tooltip.
      // @param {String} type - 'reaction_object' or 'node_object'
      // @param {Object} d - D3 data for DOM element
      var getMouseover = function getMouseover(type) {
        var behavior = _this4;
        return function (d) {
          if (!behavior.dragging) {
            if (type === 'reaction_object') {
              var mouseEvent = d3Mouse(this);
              // Add the current mouse position to the segment's datum
              var newD = Object.assign({}, d, { xPos: mouseEvent[0], yPos: mouseEvent[1] });
              behavior.map.callback_manager.run('show_tooltip', null, type, newD);
            } else {
              behavior.map.callback_manager.run('show_tooltip', null, type, d);
            }
          }
        };
      };
      var mouseout = function mouseout() {
        _this4.map.callback_manager.run('delay_hide_tooltip');
      };
      this.nodeObjectMouseover = getMouseover('node_object');
      this.nodeObjectMouseout = mouseout;
      this.reactionObjectMouseover = getMouseover('reaction_object');
      this.reactionObjectMouseout = mouseout;
    } else {
      this.nodeObjectMouseover = null;
      this.nodeObjectMouseout = null;
      this.reactionObjectMouseover = null;
      this.reactionObjectMouseout = null;
    }
  };

  /**
   * With no argument, toggle the tooltips upon touching of nodes or arrows.
   * @param {Boolean} onOff - The new on/off state. If this argument is not provided, then toggle the state.
   */


  Behavior.prototype.toggleObjectTouch = function toggleObjectTouch(onOff) {
    var _this5 = this;

    if (onOff === undefined) {
      onOff = this.labelTouch === null;
    }

    if (onOff) {
      this.objectTouch = function (type, d) {
        if (!_this5.dragging) {
          _this5.map.callback_manager.run('show_tooltip', null, type, d);
        }
      };
    } else {
      this.objectTouch = null;
    }
  };

  /**
   * With no argument, toggle the bezier drag on or off. Pass in a boolean
   * argument to set the on/off state.
   */


  Behavior.prototype.toggleBezierDrag = function toggleBezierDrag(onOff) {
    if (onOff === undefined) {
      onOff = this.bezierDrag === this.emptyBehavior;
    }
    if (onOff) {
      this.bezierDrag = this.getBezierDrag(this.map);
      this.bezierMouseover = function (d) {
        d3Select(this).style('stroke-width', '3px');
      };
      this.bezierMouseout = function (d) {
        d3Select(this).style('stroke-width', '1px');
      };
    } else {
      this.bezierDrag = this.emptyBehavior;
      this.bezierMouseover = null;
      this.bezierMouseout = null;
    }
  };

  Behavior.prototype.turnOffDrag = function turnOffDrag(sel) {
    sel.on('mousedown.drag', null);
    sel.on('touchstart.drag', null);
  };

  Behavior.prototype.combineNodesAndDraw = function combineNodesAndDraw(fixedNodeId, draggedNodeId) {
    var map = this.map;
    var draggedNode = map.nodes[draggedNodeId];
    var fixedNode = map.nodes[fixedNodeId];
    var updatedSegmentObjs = [];
    draggedNode.connected_segments.forEach(function (segmentObj) {
      // change the segments to reflect
      var segment = null;
      try {
        segment = map.reactions[segmentObj.reaction_id].segments[segmentObj.segment_id];
        if (segment === undefined) throw new Error('undefined segment');
      } catch (e) {
        console.warn('Could not find connected segment ' + segmentObj.segment_id);
        return;
      }
      if (segment.from_node_id === draggedNodeId) segment.from_node_id = fixedNodeId;else if (segment.to_node_id === draggedNodeId) segment.to_node_id = fixedNodeId;else {
        console.error('Segment does not connect to dragged node');
        return;
      }
      // moved segmentObj to fixedNode
      fixedNode.connected_segments.push(segmentObj);
      updatedSegmentObjs.push(_utils2.default.clone(segmentObj));
    });
    // delete the old node
    map.delete_node_data([draggedNodeId]);
    // turn off the class
    map.sel.selectAll('.node-to-combine').classed('node-to-combine', false);
    // draw
    map.draw_everything();
    // return for undo
    return updatedSegmentObjs;
  };

  /**
   * Drag the selected nodes and text labels.
   * @param {} map -
   * @param {} undo_stack -
   */


  Behavior.prototype.getSelectableDrag = function getSelectableDrag(map, undoStack) {
    var _this6 = this;

    // define some variables
    var behavior = (0, _d3Drag.drag)();
    var theTimeout = null;
    var totalDisplacement = null;
    // for nodes
    var nodeIdsToDrag = null;
    var reactionIds = null;
    // for text labels
    var textLabelIdsToDrag = null;
    var moveLabel = function moveLabel(textLabelId, displacement) {
      var textLabel = map.text_labels[textLabelId];
      textLabel.x = textLabel.x + displacement.x;
      textLabel.y = textLabel.y + displacement.y;
    };
    var setDragging = function setDragging(onOff) {
      _this6.dragging = onOff;
    };

    behavior.on('start', function (d) {
      setDragging(true);

      // silence other listeners (e.g. nodes BELOW this one)
      d3Selection.event.sourceEvent.stopPropagation();
      // remember the total displacement for later
      totalDisplacement = { x: 0, y: 0

        // If a text label is selected, the rest is not necessary
      };if (d3Select(this).attr('class').indexOf('label') === -1) {
        // Note that drag start is called even for a click event
        var data = this.parentNode.__data__;
        var biggId = data.bigg_id;
        var nodeGroup = this.parentNode;
        // Move element to back (for the next step to work). Wait 200ms
        // before making the move, becuase otherwise the element will be
        // deleted before the click event gets called, and selection
        // will stop working.
        theTimeout = setTimeout(function () {
          nodeGroup.parentNode.insertBefore(nodeGroup, nodeGroup.parentNode.firstChild);
        }, 200);
        // prepare to combine metabolites
        map.sel.selectAll('.metabolite-circle').on('mouseover.combine', function (d) {
          if (d.bigg_id === biggId && d.node_id !== data.node_id) {
            d3Select(this).classed('node-to-combine', true);
          }
        }).on('mouseout.combine', function (d) {
          if (d.bigg_id === biggId) {
            map.sel.selectAll('.node-to-combine').classed('node-to-combine', false);
          }
        });
      }
    });

    behavior.on('drag', function (d) {
      // if this node is not already selected, then select this one and
      // deselect all other nodes. Otherwise, leave the selection alone.
      if (!d3Select(this.parentNode).classed('selected')) {
        map.select_selectable(this, d);
      }

      // get the grabbed id
      var grabbed = {};
      if (d3Select(this).attr('class').indexOf('label') === -1) {
        // if it is a node
        grabbed['type'] = 'node';
        grabbed['id'] = this.parentNode.__data__.node_id;
      } else {
        // if it is a text label
        grabbed['type'] = 'label';
        grabbed['id'] = this.__data__.text_label_id;
      }

      var selectedNodeIds = map.get_selected_node_ids();
      var selectedTextLabelIds = map.get_selected_text_label_ids();
      nodeIdsToDrag = [];
      textLabelIdsToDrag = [];
      // choose the nodes and text labels to drag
      if (grabbed['type'] === 'node' && selectedNodeIds.indexOf(grabbed['id']) === -1) {
        nodeIdsToDrag.push(grabbed['id']);
      } else if (grabbed['type'] === 'label' && selectedTextLabelIds.indexOf(grabbed['id']) === -1) {
        textLabelIdsToDrag.push(grabbed['id']);
      } else {
        nodeIdsToDrag = selectedNodeIds;
        textLabelIdsToDrag = selectedTextLabelIds;
      }
      reactionIds = [];
      var displacement = {
        x: d3Selection.event.dx,
        y: d3Selection.event.dy
      };
      totalDisplacement = _utils2.default.c_plus_c(totalDisplacement, displacement);
      nodeIdsToDrag.forEach(function (nodeId) {
        // update data
        var node = map.nodes[nodeId];
        var updated = build.moveNodeAndDependents(node, nodeId, map.reactions, map.beziers, displacement);
        reactionIds = _utils2.default.uniqueConcat([reactionIds, updated.reaction_ids]);
        // remember the displacements
        // if (!(nodeId in totalDisplacement))  totalDisplacement[nodeId] = { x: 0, y: 0 }
        // totalDisplacement[nodeId] = utils.c_plus_c(totalDisplacement[nodeId], displacement)
      });
      textLabelIdsToDrag.forEach(function (textLabelId) {
        moveLabel(textLabelId, displacement);
        // remember the displacements
        // if (!(nodeId in totalDisplacement))  totalDisplacement[nodeId] = { x: 0, y: 0 }
        // totalDisplacement[nodeId] = utils.c_plus_c(totalDisplacement[nodeId], displacement)
      });
      // draw
      map.draw_these_nodes(nodeIdsToDrag);
      map.draw_these_reactions(reactionIds);
      map.draw_these_text_labels(textLabelIdsToDrag);
    });

    var combineNodesAndDraw = this.combineNodesAndDraw.bind(this);
    behavior.on('end', function () {
      setDragging(false);

      if (nodeIdsToDrag === null) {
        // Drag end can be called when drag has not been called. In this, case, do
        // nothing.
        totalDisplacement = null;
        nodeIdsToDrag = null;
        textLabelIdsToDrag = null;
        reactionIds = null;
        theTimeout = null;
        return;
      }

      // look for mets to combine
      var nodeToCombineArray = [];
      map.sel.selectAll('.node-to-combine').each(function (d) {
        nodeToCombineArray.push(d.node_id);
      });

      if (nodeToCombineArray.length === 1) {
        // If a node is ready for it, combine nodes
        var fixedNodeId = nodeToCombineArray[0];
        var draggedNodeId = this.parentNode.__data__.node_id;
        var savedDraggedNode = _utils2.default.clone(map.nodes[draggedNodeId]);
        var segmentObjsMovedToCombine = combineNodesAndDraw(fixedNodeId, draggedNodeId);
        var savedDisplacement = _utils2.default.clone(totalDisplacement);
        undoStack.push(function () {
          // undo
          // put the old node back
          map.nodes[draggedNodeId] = savedDraggedNode;
          var fixedNode = map.nodes[fixedNodeId];
          var updatedReactions = [];
          segmentObjsMovedToCombine.forEach(function (segmentObj) {
            var segment = map.reactions[segmentObj.reaction_id].segments[segmentObj.segment_id];
            if (segment.from_node_id === fixedNodeId) {
              segment.from_node_id = draggedNodeId;
            } else if (segment.to_node_id === fixedNodeId) {
              segment.to_node_id = draggedNodeId;
            } else {
              console.error('Segment does not connect to fixed node');
            }
            // removed this segmentObj from the fixed node
            fixedNode.connected_segments = fixedNode.connected_segments.filter(function (x) {
              return !(x.reaction_id === segmentObj.reaction_id && x.segment_id === segmentObj.segment_id);
            });
            if (updatedReactions.indexOf(segmentObj.reaction_id) === -1) {
              updatedReactions.push(segmentObj.reaction_id);
            }
          });
          // move the node back
          build.moveNodeAndDependents(savedDraggedNode, draggedNodeId, map.reactions, map.beziers, _utils2.default.c_times_scalar(savedDisplacement, -1));
          map.draw_these_nodes([draggedNodeId]);
          map.draw_these_reactions(updatedReactions);
        }, function () {
          // redo
          // move node before combining for reliable undo/redo looping
          build.moveNodeAndDependents(savedDraggedNode, draggedNodeId, map.reactions, map.beziers, _utils2.default.c_times_scalar(savedDisplacement, 1));
          combineNodesAndDraw(fixedNodeId, draggedNodeId);
        });
      } else {
        // otherwise, drag node

        // add to undo/redo stack
        // remember the displacement, dragged nodes, and reactions
        var _savedDisplacement = _utils2.default.clone(totalDisplacement);
        // BUG TODO this variable disappears!
        // Happens sometimes when you drag a node, then delete it, then undo twice
        var savedNodeIds = _utils2.default.clone(nodeIdsToDrag);
        var savedTextLabelIds = _utils2.default.clone(textLabelIdsToDrag);
        var savedReactionIds = _utils2.default.clone(reactionIds);
        undoStack.push(function () {
          // undo
          savedNodeIds.forEach(function (nodeId) {
            var node = map.nodes[nodeId];
            build.moveNodeAndDependents(node, nodeId, map.reactions, map.beziers, _utils2.default.c_times_scalar(_savedDisplacement, -1));
          });
          savedTextLabelIds.forEach(function (textLabelId) {
            moveLabel(textLabelId, _utils2.default.c_times_scalar(_savedDisplacement, -1));
          });
          map.draw_these_nodes(savedNodeIds);
          map.draw_these_reactions(savedReactionIds);
          map.draw_these_text_labels(savedTextLabelIds);
        }, function () {
          // redo
          savedNodeIds.forEach(function (nodeId) {
            var node = map.nodes[nodeId];
            build.moveNodeAndDependents(node, nodeId, map.reactions, map.beziers, _savedDisplacement);
          });
          savedTextLabelIds.forEach(function (textLabelId) {
            moveLabel(textLabelId, _savedDisplacement);
          });
          map.draw_these_nodes(savedNodeIds);
          map.draw_these_reactions(savedReactionIds);
          map.draw_these_text_labels(savedTextLabelIds);
        });
      }

      // stop combining metabolites
      map.sel.selectAll('.metabolite-circle').on('mouseover.combine', null).on('mouseout.combine', null);

      // clear the timeout
      clearTimeout(theTimeout);

      // clear the shared variables
      totalDisplacement = null;
      nodeIdsToDrag = null;
      textLabelIdsToDrag = null;
      reactionIds = null;
      theTimeout = null;
    });

    return behavior;
  };

  Behavior.prototype.getBezierDrag = function getBezierDrag(map) {
    var moveBezier = function moveBezier(reactionId, segmentId, bez, bezierId, displacement) {
      var segment = map.reactions[reactionId].segments[segmentId];
      segment[bez] = _utils2.default.c_plus_c(segment[bez], displacement);
      map.beziers[bezierId].x = segment[bez].x;
      map.beziers[bezierId].y = segment[bez].y;
    };
    var startFn = function startFn(d) {
      d.dragging = true;
    };
    var dragFn = function dragFn(d, displacement, totalDisplacement) {
      // draw
      moveBezier(d.reaction_id, d.segment_id, d.bezier, d.bezier_id, displacement);
      map.draw_these_reactions([d.reaction_id], false);
      map.draw_these_beziers([d.bezier_id]);
    };
    var endFn = function endFn(d) {
      d.dragging = false;
    };
    var undoFn = function undoFn(d, displacement) {
      moveBezier(d.reaction_id, d.segment_id, d.bezier, d.bezier_id, _utils2.default.c_times_scalar(displacement, -1));
      map.draw_these_reactions([d.reaction_id], false);
      map.draw_these_beziers([d.bezier_id]);
    };
    var redoFn = function redoFn(d, displacement) {
      moveBezier(d.reaction_id, d.segment_id, d.bezier, d.bezier_id, displacement);
      map.draw_these_reactions([d.reaction_id], false);
      map.draw_these_beziers([d.bezier_id]);
    };
    return this.getGenericDrag(startFn, dragFn, endFn, undoFn, redoFn, this.map.sel);
  };

  Behavior.prototype.getReactionLabelDrag = function getReactionLabelDrag(map) {
    var moveLabel = function moveLabel(reactionId, displacement) {
      var reaction = map.reactions[reactionId];
      reaction.label_x = reaction.label_x + displacement.x;
      reaction.label_y = reaction.label_y + displacement.y;
    };
    var startFn = function startFn(d) {
      // hide tooltips when drag starts
      map.callback_manager.run('hide_tooltip');
    };
    var dragFn = function dragFn(d, displacement, totalDisplacement) {
      // draw
      moveLabel(d.reaction_id, displacement);
      map.draw_these_reactions([d.reaction_id]);
    };
    var endFn = function endFn() {};
    var undoFn = function undoFn(d, displacement) {
      moveLabel(d.reaction_id, _utils2.default.c_times_scalar(displacement, -1));
      map.draw_these_reactions([d.reaction_id]);
    };
    var redoFn = function redoFn(d, displacement) {
      moveLabel(d.reaction_id, displacement);
      map.draw_these_reactions([d.reaction_id]);
    };
    return this.getGenericDrag(startFn, dragFn, endFn, undoFn, redoFn, this.map.sel);
  };

  Behavior.prototype.getNodeLabelDrag = function getNodeLabelDrag(map) {
    var moveLabel = function moveLabel(nodeId, displacement) {
      var node = map.nodes[nodeId];
      node.label_x = node.label_x + displacement.x;
      node.label_y = node.label_y + displacement.y;
    };
    var startFn = function startFn(d) {
      // hide tooltips when drag starts
      map.callback_manager.run('hide_tooltip');
    };
    var dragFn = function dragFn(d, displacement, totalDisplacement) {
      // draw
      moveLabel(d.node_id, displacement);
      map.draw_these_nodes([d.node_id]);
    };
    var endFn = function endFn() {};
    var undoFn = function undoFn(d, displacement) {
      moveLabel(d.node_id, _utils2.default.c_times_scalar(displacement, -1));
      map.draw_these_nodes([d.node_id]);
    };
    var redoFn = function redoFn(d, displacement) {
      moveLabel(d.node_id, displacement);
      map.draw_these_nodes([d.node_id]);
    };
    return this.getGenericDrag(startFn, dragFn, endFn, undoFn, redoFn, this.map.sel);
  };

  /**
   * Make a generic drag behavior, with undo/redo.
   *
   * startFn: function (d) Called at drag start.
   *
   * dragFn: function (d, displacement, totalDisplacement) Called during drag.
   *
   * endFn
   *
   * undoFn
   *
   * redoFn
   *
   * relativeToSelection: a d3 selection that the locations are calculated
   * against.
   *
   */


  Behavior.prototype.getGenericDrag = function getGenericDrag(startFn, dragFn, endFn, undoFn, redoFn, relativeToSelection) {
    var _this7 = this;

    // define some variables
    var behavior = (0, _d3Drag.drag)();
    var undoStack = this.undoStack;
    var rel = relativeToSelection.node();
    var totalDisplacement = void 0;

    behavior.on('start', function (d) {
      _this7.dragging = true;

      // silence other listeners
      d3Selection.event.sourceEvent.stopPropagation();
      totalDisplacement = { x: 0, y: 0 };
      startFn(d);
    });

    behavior.on('drag', function (d) {
      // update data
      var displacement = {
        x: d3Selection.event.dx,
        y: d3Selection.event.dy
      };
      var location = {
        x: d3Mouse(rel)[0],
        y: d3Mouse(rel)[1]

        // remember the displacement
      };totalDisplacement = _utils2.default.c_plus_c(totalDisplacement, displacement);
      dragFn(d, displacement, totalDisplacement, location);
    });

    behavior.on('end', function (d) {
      _this7.dragging = false;

      // add to undo/redo stack
      // remember the displacement, dragged nodes, and reactions
      var savedD = _utils2.default.clone(d);
      var savedDisplacement = _utils2.default.clone(totalDisplacement); // BUG TODO this variable disappears!
      var savedLocation = {
        x: d3Mouse(rel)[0],
        y: d3Mouse(rel)[1]
      };

      undoStack.push(function () {
        // undo
        undoFn(savedD, savedDisplacement, savedLocation);
      }, function () {
        // redo
        redoFn(savedD, savedDisplacement, savedLocation);
      });
      endFn(d);
    });

    return behavior;
  };

  /** Make a generic drag behavior, with undo/redo. Supplies angles in place of
   * displacements.
   *
   * startFn: function (d) Called at drag start.
   *
   * dragFn: function (d, displacement, totalDisplacement) Called during drag.
   *
   * endFn:
   *
   * undoFn:
   *
   * redoFn:
   *
   * getCenter:
   *
   * relativeToSelection: a d3 selection that the locations are calculated
   * against.
   *
   */


  Behavior.prototype.getGenericAngularDrag = function getGenericAngularDrag(startFn, dragFn, endFn, undoFn, redoFn, getCenter, relativeToSelection) {
    var _this8 = this;

    // define some variables
    var behavior = (0, _d3Drag.drag)();
    var undoStack = this.undoStack;
    var rel = relativeToSelection.node();
    var totalAngle = void 0;

    behavior.on('start', function (d) {
      _this8.dragging = true;

      // silence other listeners
      d3Selection.event.sourceEvent.stopPropagation();
      totalAngle = 0;
      startFn(d);
    });

    behavior.on('drag', function (d) {
      // update data
      var displacement = {
        x: d3Selection.event.dx,
        y: d3Selection.event.dy
      };
      var location = {
        x: d3Mouse(rel)[0],
        y: d3Mouse(rel)[1]
      };
      var center = getCenter();
      var angle = _utils2.default.angle_for_event(displacement, location, center);
      // remember the displacement
      totalAngle = totalAngle + angle;
      dragFn(d, angle, totalAngle, center);
    });

    behavior.on('end', function (d) {
      _this8.dragging = false;

      // add to undo/redo stack
      // remember the displacement, dragged nodes, and reactions
      var savedD = _utils2.default.clone(d);
      var savedAngle = totalAngle;
      var savedCenter = _utils2.default.clone(getCenter());

      undoStack.push(function () {
        return undoFn(savedD, savedAngle, savedCenter);
      }, function () {
        return redoFn(savedD, savedAngle, savedCenter);
      });

      endFn(d);
    });

    return behavior;
  };

  return Behavior;
}();

exports.default = Behavior;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getMetLabelLoc = getMetLabelLoc;
exports.newReaction = newReaction;
exports.rotateNodes = rotateNodes;
exports.moveNodeAndDependents = moveNodeAndDependents;
exports.newTextLabel = newTextLabel;
exports.bezierIdForSegmentId = bezierIdForSegmentId;
exports.bezierIdsForReactionIds = bezierIdsForReactionIds;
exports.newBeziersForSegments = newBeziersForSegments;
exports.newBeziersForReactions = newBeziersForReactions;

var _utils = __webpack_require__(4);

var utils = _interopRequireWildcard(_utils);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Functions for building new reactions.
 */

function getLabelLoc(angle) {
  if (Math.abs(angle) > Math.PI) {
    throw new Error('Angle must be between -PI and PI');
  }
  if (Math.abs(angle) < Math.PI / 7 || Math.abs(angle - Math.PI) < Math.PI / 7) {
    // Close to 0 or PI
    return { x: -50, y: -40 };
  } else if (angle > 0) {
    // Bottom quadrants
    return {
      x: 15 * (1 - Math.abs(angle - Math.PI / 2) / (Math.PI / 2)),
      y: 10 + (angle - Math.PI / 2) * 50
    };
  } else {
    // Top quadrants
    return {
      x: 15 * (1 - Math.abs(angle + Math.PI / 2) / (Math.PI / 2)),
      y: 10 - (Math.abs(angle) - Math.PI / 2) * 50
    };
  }
}

/**
 * Get the location for a new metabolite label.
 * @param angleRaw - angle in radians
 * @param index
 * @param count
 * @param isPrimary
 * @param biggId
 * @param primaryIndex
 */
function getMetLabelLoc(angleRaw, index, count, isPrimary, biggId, primaryIndex) {
  var angle = utils.angleNorm(angleRaw);
  var width = biggId.length * 18;
  var leftRight = index - (index > primaryIndex) - count / 2 >= -1;
  if (Math.abs(angle) < Math.PI / 7) {
    // Close to 0
    if (isPrimary || leftRight) {
      // Primary or bottom
      return { x: -width * 0.3, y: 40 };
    } else {
      // Top
      return { x: -width * 0.3, y: -20 };
    }
  } else if (Math.abs(angle - Math.PI) < Math.PI / 7) {
    // Close to PI
    if (isPrimary || !leftRight) {
      // Primary or bottom
      return { x: -width * 0.3, y: 40 };
    } else {
      // Top
      return { x: -width * 0.3, y: -20 };
    }
  } else {
    if (isPrimary) {
      // Primary
      return {
        x: 25 - 38 * Math.abs(Math.abs(angle) - Math.PI / 2),
        y: (Math.abs(angle) - Math.PI / 2) * ((angle > 0) * 2 - 1) * 50
      };
    } else if (angle < 0 && leftRight || angle > 0 && !leftRight) {
      // Right
      return { x: 15, y: 0 };
    } else {
      // Left
      return { x: -width * 0.5, y: 30 };
    }
  }
}

/**
 * New reaction.
 * @param {Number} direction - clockwise from 'right', in degrees.
 */
function newReaction(biggId, cobraReaction, cobraMetabolites, selectedNodeId, selectedNode, largestIds, cofactors, direction) {
  // Convert to radians, and force to domain - PI/2 to PI/2
  var angle = utils.to_radians_norm(direction);

  // Generate a new integer id
  var newReactionId = String(++largestIds.reactions);

  // Calculate coordinates of reaction
  var selectedNodeCoords = { x: selectedNode.x, y: selectedNode.y

    // Rotate main axis around angle with distance
  };var reactionLength = 350;
  var mainAxis = [selectedNodeCoords, utils.c_plus_c(selectedNodeCoords, { x: reactionLength, y: 0 })];
  var center = {
    x: (mainAxis[0].x + mainAxis[1].x) / 2,
    y: (mainAxis[0].y + mainAxis[1].y) / 2

    // Relative label location
  };var labelD = getLabelLoc(angle);

  // Relative anchor node distance
  var anchorDistance = 20;

  // New reaction structure
  var newReaction = {
    name: cobraReaction.name,
    bigg_id: cobraReaction.bigg_id,
    reversibility: cobraReaction.reversibility,
    gene_reaction_rule: cobraReaction.gene_reaction_rule,
    genes: utils.clone(cobraReaction.genes),
    metabolites: utils.clone(cobraReaction.metabolites)
  };
  utils.extend(newReaction, {
    label_x: center.x + labelD.x,
    label_y: center.y + labelD.y,
    segments: {}
  });

  // Set primary metabolites and count reactants/products

  // Look for the selected metabolite, and record the indices
  var reactantRanks = [];
  var productRanks = [];
  var reactantCount = 0;
  var productCount = 0;
  var reactionIsReversed = false;
  for (var metBiggId in newReaction.metabolites) {
    // Make the metabolites into objects
    var metabolite = cobraMetabolites[metBiggId];
    var coefficient = newReaction.metabolites[metBiggId];
    var formula = metabolite.formula;
    var newMetabolite = {
      coefficient: coefficient,
      bigg_id: metBiggId,
      name: metabolite.name
    };
    if (coefficient < 0) {
      newMetabolite.index = reactantCount;
      // score the metabolites. Infinity == selected, >= 1 == carbon containing
      var carbons = /C([0-9]+)/.exec(formula);
      if (selectedNode.bigg_id === newMetabolite.bigg_id) {
        reactantRanks.push([newMetabolite.index, Infinity]);
      } else if (carbons && cofactors.indexOf(utils.decompartmentalize(newMetabolite.bigg_id)[0]) === -1) {
        reactantRanks.push([newMetabolite.index, parseInt(carbons[1])]);
      }
      reactantCount++;
    } else {
      newMetabolite.index = productCount;
      var _carbons = /C([0-9]+)/.exec(formula);
      if (selectedNode.bigg_id === newMetabolite.bigg_id) {
        productRanks.push([newMetabolite.index, Infinity]);
        reactionIsReversed = true;
      } else if (_carbons && cofactors.indexOf(utils.decompartmentalize(newMetabolite.bigg_id)[0]) === -1) {
        productRanks.push([newMetabolite.index, parseInt(_carbons[1])]);
      }
      productCount++;
    }
    newReaction.metabolites[metBiggId] = newMetabolite;
  }

  // get the rank with the highest score
  var maxRank = function maxRank(old, current) {
    return current[1] > old[1] ? current : old;
  };
  var primaryReactantIndex = reactantRanks.reduce(maxRank, [0, 0])[0];
  var primaryProductIndex = productRanks.reduce(maxRank, [0, 0])[0];

  // set primary metabolites, and keep track of the total counts
  for (var _metBiggId in newReaction.metabolites) {
    var _metabolite = newReaction.metabolites[_metBiggId];
    if (_metabolite.coefficient < 0) {
      _metabolite.is_primary = _metabolite.index === primaryReactantIndex;
      _metabolite.count = reactantCount;
    } else {
      _metabolite.is_primary = _metabolite.index === primaryProductIndex;
      _metabolite.count = productCount;
    }
  }

  // generate anchor nodes
  var newAnchors = {};
  var anchors = [{
    node_type: 'anchor_reactants',
    dis: { x: anchorDistance * (reactionIsReversed ? 1 : -1), y: 0 }
  }, { node_type: 'center', dis: { x: 0, y: 0 } }, {
    node_type: 'anchor_products',
    dis: { x: anchorDistance * (reactionIsReversed ? -1 : 1), y: 0 }
  }];
  var anchorIds = {};
  anchors.map(function (n) {
    var newId = String(++largestIds.nodes);
    var generalNodeType = n.node_type === 'center' ? 'midmarker' : 'multimarker';
    newAnchors[newId] = {
      node_type: generalNodeType,
      x: center.x + n.dis.x,
      y: center.y + n.dis.y,
      connected_segments: [],
      name: null,
      bigg_id: null,
      label_x: null,
      label_y: null,
      node_is_primary: null,
      data: null
    };
    anchorIds[n.node_type] = newId;
  });

  // add the segments, outside to inside
  var newAnchorGroups = [[anchorIds['anchor_reactants'], anchorIds['center'], 'reactants'], [anchorIds['anchor_products'], anchorIds['center'], 'products']];
  newAnchorGroups.map(function (l) {
    var fromId = l[0];
    var toId = l[1];
    var newSegmentId = String(++largestIds.segments);
    var unconnectedSeg = reactantCount === 0 && l[2] === 'reactants' && newReaction.reversibility || productCount === 0 && l[2] === 'products';
    newReaction.segments[newSegmentId] = {
      b1: null,
      b2: null,
      from_node_id: fromId,
      to_node_id: toId,
      from_node_coefficient: null,
      to_node_coefficient: null,
      reversibility: newReaction.reversibility,
      data: newReaction.data,
      reverse_flux: newReaction.reverse_flux,
      unconnected_segment_with_arrow: unconnectedSeg
    };
    newAnchors[fromId].connected_segments.push({
      segment_id: newSegmentId,
      reaction_id: newReactionId
    });
    newAnchors[toId].connected_segments.push({
      segment_id: newSegmentId,
      reaction_id: newReactionId
    });
  });

  // Add the metabolites, keeping track of total reactants and products.
  var newNodes = newAnchors;
  for (var _metBiggId2 in newReaction.metabolites) {
    var _metabolite2 = newReaction.metabolites[_metBiggId2];
    var primaryIndex = void 0;
    var fromNodeId = void 0;
    if (_metabolite2.coefficient < 0) {
      primaryIndex = primaryReactantIndex;
      fromNodeId = anchorIds['anchor_reactants'];
    } else {
      primaryIndex = primaryProductIndex;
      fromNodeId = anchorIds['anchor_products'];
    }

    // calculate coordinates of metabolite components
    var metLoc = calculateNewMetaboliteCoordinates(_metabolite2, primaryIndex, mainAxis, center, reactionLength, reactionIsReversed);

    // if this is the existing metabolite
    if (selectedNode.bigg_id === _metabolite2.bigg_id) {
      var newSegmentId = String(++largestIds.segments);
      newReaction.segments[newSegmentId] = {
        b1: metLoc.b1,
        b2: metLoc.b2,
        from_node_id: fromNodeId,
        to_node_id: selectedNodeId,
        from_node_coefficient: null,
        to_node_coefficient: _metabolite2.coefficient,
        reversibility: newReaction.reversibility
        // Update the existing node
      };selectedNode.connected_segments.push({
        segment_id: newSegmentId,
        reaction_id: newReactionId
      });
      newNodes[fromNodeId].connected_segments.push({
        segment_id: newSegmentId,
        reaction_id: newReactionId
      });
    } else {
      // save new metabolite
      var _newSegmentId = String(++largestIds.segments);
      var newNodeId = String(++largestIds.nodes);
      newReaction.segments[_newSegmentId] = {
        b1: metLoc.b1,
        b2: metLoc.b2,
        from_node_id: fromNodeId,
        to_node_id: newNodeId,
        from_node_coefficient: null,
        to_node_coefficient: _metabolite2.coefficient,
        reversibility: newReaction.reversibility
        // save new node
      };var metLabelD = getMetLabelLoc(angle, _metabolite2.index, _metabolite2.count, _metabolite2.is_primary, _metabolite2.bigg_id, primaryIndex);
      newNodes[newNodeId] = {
        connected_segments: [{
          segment_id: _newSegmentId,
          reaction_id: newReactionId
        }],
        x: metLoc.circle.x,
        y: metLoc.circle.y,
        node_is_primary: _metabolite2.is_primary,
        label_x: metLoc.circle.x + metLabelD.x,
        label_y: metLoc.circle.y + metLabelD.y,
        name: _metabolite2.name,
        bigg_id: _metabolite2.bigg_id,
        node_type: 'metabolite'
      };
      newNodes[fromNodeId].connected_segments.push({
        segment_id: _newSegmentId,
        reaction_id: newReactionId
      });
    }
  }

  // now take out the extra reaction details
  var metabolitesArray = [];
  for (var _biggId in newReaction.metabolites) {
    metabolitesArray.push({
      bigg_id: _biggId,
      coefficient: newReaction.metabolites[_biggId].coefficient
    });
  }
  newReaction.metabolites = metabolitesArray;

  // newReactions object
  var newReactions = {};
  newReactions[newReactionId] = newReaction;

  // new_beziers object
  var newBeziers = newBeziersForReactions(newReactions);

  // add the selected node for rotation, and return it as a new (updated) node
  newNodes[selectedNodeId] = selectedNode;
  rotateNodes(newNodes, newReactions, newBeziers, angle, selectedNodeCoords);

  return {
    new_reactions: newReactions,
    new_beziers: newBeziers,
    new_nodes: newNodes
  };
}

/**
 * Rotate the nodes around center.
 * @param selected_nodes - Nodes to rotate.
 * @param reactions - Only updates beziers for these reactions.
 * @param beziers - Also update the bezier points.
 * @param angle - Angle to rotate in radians.
 * @param center - Point to rotate around.
 */
function rotateNodes(selectedNodes, reactions, beziers, angle, center) {
  var rotateAround = function rotateAround(coord) {
    if (coord === null) {
      return null;
    }
    return utils.rotate_coords(coord, angle, center);
  };

  // recalculate: node
  var updatedNodeIds = [];
  var updatedReactionIds = [];

  var _loop = function _loop(nodeId) {
    var node = selectedNodes[nodeId];
    // rotation distance
    var displacement = rotateAround({ x: node.x, y: node.y });
    // move the node
    var updated = moveNodeAndLabels(node, reactions, displacement);
    // move the bezier points
    node.connected_segments.map(function (segmentObj) {
      var reaction = reactions[segmentObj.reaction_id];
      // If the reaction was not passed in the reactions argument, then ignore
      if (reaction === undefined) return;

      // rotate the beziers
      var segmentId = segmentObj.segment_id;
      var segment = reaction.segments[segmentId];
      if (segment.to_node_id === nodeId && segment.b2) {
        var _displacement = rotateAround(segment.b2);
        var bezId = bezierIdForSegmentId(segmentId, 'b2');
        segment.b2 = utils.c_plus_c(segment.b2, _displacement);
        beziers[bezId].x = segment.b2.x;
        beziers[bezId].y = segment.b2.y;
      } else if (segment.from_node_id === nodeId && segment.b1) {
        var _displacement2 = rotateAround(segment.b1);
        var _bezId = bezierIdForSegmentId(segmentId, 'b1');
        segment.b1 = utils.c_plus_c(segment.b1, _displacement2);
        beziers[_bezId].x = segment.b1.x;
        beziers[_bezId].y = segment.b1.y;
      }
    });

    updatedReactionIds = utils.uniqueConcat([updatedReactionIds, updated.reaction_ids]);
    updatedNodeIds.push(nodeId);
  };

  for (var nodeId in selectedNodes) {
    _loop(nodeId);
  }

  return {
    node_ids: updatedNodeIds,
    reaction_ids: updatedReactionIds
  };
}

/**
 * Move the node and its labels and beziers.
 */
function moveNodeAndDependents(node, nodeId, reactions, beziers, displacement) {
  var updated = moveNodeAndLabels(node, reactions, displacement);

  // move beziers
  node.connected_segments.map(function (segmentObj) {
    var reaction = reactions[segmentObj.reaction_id];
    // If the reaction was not passed in the reactions argument, then ignore
    if (_underscore2.default.isUndefined(reaction)) return;

    // Update beziers
    var segmentId = segmentObj.segment_id;
    var segment = reaction.segments[segmentId];
    var cs = [['b1', 'from_node_id'], ['b2', 'to_node_id']];
    cs.forEach(function (c) {
      var bez = c[0];
      var node = c[1];
      if (segment[node] === nodeId && segment[bez]) {
        segment[bez] = utils.c_plus_c(segment[bez], displacement);
        var tbez = beziers[bezierIdForSegmentId(segmentId, bez)];
        tbez.x = segment[bez].x;
        tbez.y = segment[bez].y;
      }
    });

    // add to list of updated reaction ids if it isn't already there
    if (updated.reaction_ids.indexOf(segmentObj.reaction_id) < 0) {
      updated.reaction_ids.push(segmentObj.reaction_id);
    }
  });
  return updated;
}

function moveNodeAndLabels(node, reactions, displacement) {
  node.x = node.x + displacement.x;
  node.y = node.y + displacement.y;

  // recalculate: node label
  node.label_x = node.label_x + displacement.x;
  node.label_y = node.label_y + displacement.y;

  // recalculate: reaction label
  var updatedReactionIds = [];
  node.connected_segments.map(function (segmentObj) {
    var reaction = reactions[segmentObj.reaction_id];
    // add to list of updated reaction ids if it isn't already there
    if (updatedReactionIds.indexOf(segmentObj.reaction_id) < 0) {
      updatedReactionIds.push(segmentObj.reaction_id);

      // update reaction label (but only once per reaction
      if (node.node_type === 'midmarker') {
        reaction.label_x = reaction.label_x + displacement.x;
        reaction.label_y = reaction.label_y + displacement.y;
      }
    }
  });
  return { reaction_ids: updatedReactionIds };
}

/**
 * Calculate the distance of mets from main reaction axis.
 * @param {Number} w - Scaling factor
 * @param {Number} draw_at_index - Index of metabolite
 * @param {Number} num_slots - Number of metabolites
 */
function metIndexDisp(w, drawAtIndex, numSlots) {
  var half = Math.floor(numSlots / 2);
  return w * (drawAtIndex - half + (drawAtIndex >= half));
}

function metSecondaryDisp(secondaryW, secondaryDis, drawAtIndex, numSlots) {
  var half = Math.floor(numSlots / 2);
  return secondaryDis + Math.abs(drawAtIndex - half + (drawAtIndex >= half)) * secondaryW;
}

/**
 * Calculate metabolite coordinates for a new reaction metabolite.
 */
function calculateNewMetaboliteCoordinates(met, primaryIndex, mainAxis, center, dis, isReversed) {
  // new local coordinate system
  var displacement = mainAxis[0];
  mainAxis = [utils.c_minus_c(mainAxis[0], displacement), utils.c_minus_c(mainAxis[1], displacement)];
  center = utils.c_minus_c(center, displacement);

  // Curve parameters
  var w = 80; // distance between reactants and between products
  var b1Strength = 0.4;
  var b2Strength = 0.25;
  var w2 = w * 0.3; // bezier target poin
  var secondaryDis = 50; // y distance of first secondary mets
  var secondaryW = 20; // y distance of each other secondary met

  // Secondary mets
  var numSlots = met.count - 1;

  // Size and spacing for primary and secondary metabolites
  var ds = void 0;
  var drawAtIndex = void 0;
  if (met.is_primary) {
    // primary
    ds = 20;
  } else {
    // secondary
    ds = 10;
    // don't use center slot
    if (met.index > primaryIndex) drawAtIndex = met.index - 1;else drawAtIndex = met.index;
  }

  var de = dis - ds; // distance between ends of line axis
  var reactionAxis = [{ x: ds, y: 0 }, { x: de, y: 0 }];

  // Define line parameters and axis.
  // Begin with unrotated coordinate system. +y = Down, +x = Right.
  var end = void 0;
  var circle = void 0;
  var b1 = void 0;
  var b2 = void 0;

  // Reactants
  if (met.coefficient < 0 !== isReversed && met.is_primary) {
    // Ali == BADASS
    end = {
      x: reactionAxis[0].x,
      y: reactionAxis[0].y
    };
    b1 = {
      x: center.x * (1 - b1Strength) + reactionAxis[0].x * b1Strength,
      y: center.y * (1 - b1Strength) + reactionAxis[0].y * b1Strength
    };
    b2 = {
      x: center.x * b2Strength + end.x * (1 - b2Strength),
      y: center.y * b2Strength + end.y * (1 - b2Strength)
    };
    circle = {
      x: mainAxis[0].x,
      y: mainAxis[0].y
    };
  } else if (met.coefficient < 0 !== isReversed) {
    end = {
      x: reactionAxis[0].x + metSecondaryDisp(secondaryW, secondaryDis, drawAtIndex, numSlots),
      y: reactionAxis[0].y + metIndexDisp(w2, drawAtIndex, numSlots)
    };
    b1 = {
      x: center.x * (1 - b1Strength) + reactionAxis[0].x * b1Strength,
      y: center.y * (1 - b1Strength) + reactionAxis[0].y * b1Strength
    };
    b2 = {
      x: center.x * b2Strength + end.x * (1 - b2Strength),
      y: center.y * b2Strength + end.y * (1 - b2Strength)
    };
    circle = {
      x: mainAxis[0].x + metSecondaryDisp(secondaryW, secondaryDis, drawAtIndex, numSlots),
      y: mainAxis[0].y + metIndexDisp(w, drawAtIndex, numSlots)
    };
  } else if (met.coefficient > 0 !== isReversed && met.is_primary) {
    // products
    end = {
      x: reactionAxis[1].x,
      y: reactionAxis[1].y
    };
    b1 = {
      x: center.x * (1 - b1Strength) + reactionAxis[1].x * b1Strength,
      y: center.y * (1 - b1Strength) + reactionAxis[1].y * b1Strength
    };
    b2 = {
      x: center.x * b2Strength + end.x * (1 - b2Strength),
      y: center.y * b2Strength + end.y * (1 - b2Strength)
    };
    circle = {
      x: mainAxis[1].x,
      y: mainAxis[1].y
    };
  } else if (met.coefficient > 0 !== isReversed) {
    end = {
      x: reactionAxis[1].x - metSecondaryDisp(secondaryW, secondaryDis, drawAtIndex, numSlots),
      y: reactionAxis[1].y + metIndexDisp(w2, drawAtIndex, numSlots)
    };
    b1 = {
      x: center.x * (1 - b1Strength) + reactionAxis[1].x * b1Strength,
      y: center.y * (1 - b1Strength) + reactionAxis[1].y * b1Strength
    };
    b2 = {
      x: center.x * b2Strength + end.x * (1 - b2Strength),
      y: center.y * b2Strength + end.y * (1 - b2Strength)
    };
    circle = {
      x: mainAxis[1].x - metSecondaryDisp(secondaryW, secondaryDis, drawAtIndex, numSlots),
      y: mainAxis[1].y + metIndexDisp(w, drawAtIndex, numSlots)
    };
  }

  return {
    b1: utils.c_plus_c(displacement, b1),
    b2: utils.c_plus_c(displacement, b2),
    circle: utils.c_plus_c(displacement, circle)
  };
}

function newTextLabel(largestIds, text, coords) {
  var newId = String(++largestIds.text_labels);
  var newLabel = { text: text, x: coords.x, y: coords.y };
  return { id: newId, label: newLabel };
}

function bezierIdForSegmentId(segmentId, bez) {
  return segmentId + '_' + bez;
}

/**
 * Return an array of beziers ids for the array of reaction ids.
 * @param {Object} reactions - A reactions object, e.g. a subset of
 * *escher.Map.reactions*.
 */
function bezierIdsForReactionIds(reactions) {
  var bezierIds = [];
  for (var reactionId in reactions) {
    var reaction = reactions[reactionId];

    var _loop2 = function _loop2(segmentId) {
      var segment = reaction.segments[segmentId];

      var bezs = ['b1', 'b2'];
      bezs.forEach(function (bez) {
        var segBez = segment[bez];
        if (segBez !== null) {
          bezierIds.push(bezierIdForSegmentId(segmentId, bez));
        }
      });
    };

    for (var segmentId in reaction.segments) {
      _loop2(segmentId);
    }
  }
  return bezierIds;
}

/**
 * Return an object containing beziers for the segments object.
 * segments: A segments object, e.g. *escher.Map.segments*.
 * reaction_id: The reaction id for the segments.
 */
function newBeziersForSegments(segments, reactionId) {
  var beziers = {};

  var _loop3 = function _loop3(segmentId) {
    var segment = segments[segmentId];['b1', 'b2'].forEach(function (bez) {
      var segBez = segment[bez];
      if (segBez !== null) {
        var bezierId = bezierIdForSegmentId(segmentId, bez);
        beziers[bezierId] = {
          bezier: bez,
          x: segBez.x,
          y: segBez.y,
          reaction_id: reactionId,
          segment_id: segmentId
        };
      }
    });
  };

  for (var segmentId in segments) {
    _loop3(segmentId);
  }
  return beziers;
}

/**
 * Return an object containing beziers for the reactions object.
 * @param {Object} reactions - A reactions object, e.g. *escher.Map.reactions*.
 */
function newBeziersForReactions(reactions) {
  var beziers = {};
  for (var reactionId in reactions) {
    var reaction = reactions[reactionId];
    var these = newBeziersForSegments(reaction.segments, reactionId);
    utils.extend(beziers, these);
  }
  return beziers;
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var scalePresets = {
  GaBuGeRd: [{ type: 'min', color: '#c8c8c8', size: 12 }, { type: 'value', value: 0.01, color: '#9696ff', size: 16 }, { type: 'value', value: 20, color: '#209123', size: 20 }, { type: 'max', color: '#ff0000', size: 25 }],
  GaBuRd: [{ type: 'min', color: '#c8c8c8', size: 12 }, { type: 'median', color: '#9696ff', size: 20 }, { type: 'max', color: '#ff0000', size: 25 }],
  RdYlBu: [{ type: 'min', color: '#d7191c', size: 12 }, { type: 'median', color: '#ffffbf', size: 20 }, { type: 'max', color: '#2c7bb6', size: 25 }],
  GeGaRd: [{ type: 'min', color: '#209123', size: 25 }, { type: 'value', value: 0, color: '#c8c8c8', size: 12 }, { type: 'max', color: '#ff0000', size: 25 }],
  WhYlRd: [{ type: 'min', color: '#fffaf0', size: 20 }, { type: 'median', color: '#f1c470', size: 30 }, { type: 'max', color: '#800000', size: 40 }]
};

exports.default = scalePresets;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function incr(a, l) {
  return a + 1 > l - 1 ? 0 : a + 1;
}

function decr(a, l) {
  return a - 1 < 0 ? l - 1 : a - 1;
}

/** UndoStack. A constructor that can be used to store undo info. */

var UndoStack = function () {
  function UndoStack() {
    _classCallCheck(this, UndoStack);

    var stackSize = 40;
    this.stack = Array(stackSize);
    this.current = -1;
    this.oldest = -1;
    this.newest = -1;
    this.endOfStack = true;
    this.topOfStack = true;
  }

  UndoStack.prototype.push = function push(undo, redo) {
    this.current = incr(this.current, this.stack.length);
    // change the oldest
    if (this.endOfStack) {
      this.oldest = this.current;
    } else if (this.oldest === this.current) {
      this.oldest = incr(this.oldest, this.stack.length);
    }
    this.stack[this.current] = { undo: undo, redo: redo };
    this.newest = this.current;

    // top of the stack
    this.topOfStack = true;
    this.endOfStack = false;

    return { do: function _do() {
        return redo();
      } };
  };

  UndoStack.prototype.undo = function undo() {
    // check that we haven't reached the end
    if (this.endOfStack) return console.warn('End of stack.');
    // run the lastest stack function
    this.stack[this.current].undo();
    if (this.current === this.oldest) {
      // if the next index is less than the oldest, then the stack is dead
      this.endOfStack = true;
    } else {
      // reference the next fn
      this.current = decr(this.current, this.stack.length);
    }

    // not at the top of the stack
    this.topOfStack = false;
  };

  UndoStack.prototype.redo = function redo() {
    // check that we haven't reached the end
    if (this.topOfStack) return console.warn('Top of stack.');

    if (!this.endOfStack) {
      this.current = incr(this.current, this.stack.length);
    }
    this.stack[this.current].redo();

    // if at top of stack
    if (this.current === this.newest) {
      this.topOfStack = true;
    }

    // not at the end of the stack
    this.endOfStack = false;
  };

  return UndoStack;
}();

exports.default = UndoStack;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _mousetrap = __webpack_require__(53);

var _mousetrap2 = _interopRequireDefault(_mousetrap);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * If ctrlEqualsCmd is true and key has ctrl+ in it, return an array with ctrl+
 * and meta+ variations.
 */
function addCmd(key, ctrlEqualsCmd) {
  if (!ctrlEqualsCmd) return key;
  var keyAr = _underscore2.default.isArray(key) ? key : [key];
  var newAr = keyAr.reduce(function (c, k) {
    var n = k.replace('ctrl+', 'meta+');
    if (n !== k) c.push(n);
    return c;
  }, keyAr.slice());
  return newAr.length === keyAr.length ? key : newAr;
}

/**
 * KeyManager - Manage key listeners and events.
 * @param assignedKeys (default: {}): An object defining keys to bind.
 * @param inputList (default: []): A list of inputs that will override keyboard shortcuts when in focus.
 * @param selection (default: global): A node to bind the events to.
 * @param ctrlEqualsCmd (default: false): If true, then control and command have the same effect.
 */

var KeyManager = function () {
  function KeyManager() {
    var assignedKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var inputList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var selection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var ctrlEqualsCmd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var settings = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, KeyManager);

    // default Arguments
    this.assignedKeys = assignedKeys;
    this.inputList = inputList;
    this.mousetrap = selection ? new _mousetrap2.default(selection) : new _mousetrap2.default();
    this.ctrlEqualsCmd = ctrlEqualsCmd;

    // Fix mousetrap behavior; by default, it ignore shortcuts when inputs are
    // in focus.
    // TODO NOT WORKING https://craig.is/killing/mice
    // consider swithching to https://github.com/PolicyStat/combokeys
    this.mousetrap.stopCallback = function () {
      return false;
    };

    this.escapeQueue = [];
    this.removeEscapeListener = null;

    // to check settings when running a key
    this.settings = settings;

    this.enabled = true;
    this.update();
  }

  /**
   * Updated key bindings if attributes have changed.
   */


  KeyManager.prototype.update = function update() {
    var _this = this;

    this.mousetrap.reset();
    if (!this.enabled) return;

    // loop through keys

    var _loop = function _loop(keyId) {
      var assignedKey = _this.assignedKeys[keyId];

      // OK if this is missing
      if (!assignedKey.key) return 'continue';

      var keyToBind = addCmd(assignedKey.key, _this.ctrlEqualsCmd);
      // remember the inputList
      assignedKey.inputList = _this.inputList;
      _this.mousetrap.bind(keyToBind, function (e) {
        // check requires
        if (assignedKey.requires && !_this.settings.get(assignedKey.requires)) {
          return;
        }

        // check inputs
        var inputBlocking = false;
        if (assignedKey.ignoreWithInput) {
          for (var i = 0, l = assignedKey.inputList.length; i < l; i++) {
            var thisInputVal = assignedKey.inputList[i];
            var thisInput = _underscore2.default.isFunction(thisInputVal) ? thisInputVal() : thisInputVal;
            if (thisInput !== null && thisInput.is_visible()) {
              inputBlocking = true;
              break;
            }
          }
        }

        if (!inputBlocking) {
          if (assignedKey.fn) assignedKey.fn.call(assignedKey.target);else console.warn('No function for key: ' + assignedKey.key);
          e.preventDefault();
        }
      }, 'keydown');
    };

    for (var keyId in this.assignedKeys) {
      var _ret = _loop(keyId);

      if (_ret === 'continue') continue;
    }
  };

  /**
   * Turn the key manager on or off.
   */


  KeyManager.prototype.toggle = function toggle(onOff) {
    if (_underscore2.default.isUndefined(onOff)) onOff = !this.enabled;
    this.enabled = onOff;
    this.update();
  };

  /**
   * Call the callback when the enter key is pressed, then unregisters the
   * listener.
   */


  KeyManager.prototype.addEnterListener = function addEnterListener(callback, oneTime) {
    return this.addKeyListener('enter', callback, oneTime);
  };

  /**
   * If the list is empty, drop the listener. could get called after the
   * listener is already removed
   */


  KeyManager.prototype._tryDropEscapeListener = function _tryDropEscapeListener() {
    if (this.escapeQueue.length === 0 && this.removeEscapeListener) {
      this.removeEscapeListener();
      this.removeEscapeListener = null;
    }
  };
  /**
   * Call the callback when the escape key is pressed, then unregisters the
   * listener.
   *
   * Unlike the other listeners, addEscapeListener keeps a queue of listeners
   * that are called in order then popped off the list.
   *
   * Escape listeners also only work one time.
   */


  KeyManager.prototype.addEscapeListener = function addEscapeListener(callback) {
    var _this2 = this;

    // if the listener is not set, then add it
    if (this.removeEscapeListener === null) {
      this.removeEscapeListener = this.addKeyListener('escape', function () {
        // pop and run the top callback
        if (_this2.escapeQueue.length > 0) {
          var top = _this2.escapeQueue.pop();
          top();
        }
        _this2._tryDropEscapeListener();
      });
    }

    // push the new callback onto the queue
    this.escapeQueue.push(callback);

    // return a function to pop the callback out of the list
    return function () {
      // find it if it's in the queue
      var index = _this2.escapeQueue.indexOf(callback);
      // if it's the last one, then pop and activate next
      if (index > -1) {
        // remove it
        _this2.escapeQueue.splice(index, 1);
      }
      _this2._tryDropEscapeListener();
    };
  };

  /**
   * Call the callback when the key is pressed, then unregisters the listener.
   * Returns a function that will unbind the event.
   * @param callback: The callback function with no arguments.
   * @param key_name: A key name, or list of key names, as defined by the
   *                  mousetrap library: https://craig.is/killing/mice
   * @param one_time: If True, then cancel the listener after the first execution.
   */


  KeyManager.prototype.addKeyListener = function addKeyListener(keyName, callback) {
    var oneTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    // unbind function ready to go
    var unbind = this.mousetrap.unbind.bind(this.mousetrap, keyName);

    this.mousetrap.bind(addCmd(keyName, this.ctrlEqualsCmd), function (e) {
      e.preventDefault();
      callback();
      if (oneTime) unbind();
    });

    return unbind;
  };

  return KeyManager;
}();

exports.default = KeyManager;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */
/**
 * Copyright 2012-2017 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.6.5
 * @url craig.is/killing/mice
 */
(function(window, document, undefined) {

    // Check if mousetrap is used inside browser, if not, return
    if (!window) {
        return;
    }

    /**
     * mapping of special keycodes to their corresponding keys
     *
     * everything in this dictionary cannot use keypress events
     * so it has to be here to map to the correct keycodes for
     * keyup/keydown events
     *
     * @type {Object}
     */
    var _MAP = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        20: 'capslock',
        27: 'esc',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'ins',
        46: 'del',
        91: 'meta',
        93: 'meta',
        224: 'meta'
    };

    /**
     * mapping for special characters so they can support
     *
     * this dictionary is only used incase you want to bind a
     * keyup or keydown event to one of these keys
     *
     * @type {Object}
     */
    var _KEYCODE_MAP = {
        106: '*',
        107: '+',
        109: '-',
        110: '.',
        111 : '/',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\''
    };

    /**
     * this is a mapping of keys that require shift on a US keypad
     * back to the non shift equivelents
     *
     * this is so you can use keyup events with these keys
     *
     * note that this will only work reliably on US keyboards
     *
     * @type {Object}
     */
    var _SHIFT_MAP = {
        '~': '`',
        '!': '1',
        '@': '2',
        '#': '3',
        '$': '4',
        '%': '5',
        '^': '6',
        '&': '7',
        '*': '8',
        '(': '9',
        ')': '0',
        '_': '-',
        '+': '=',
        ':': ';',
        '\"': '\'',
        '<': ',',
        '>': '.',
        '?': '/',
        '|': '\\'
    };

    /**
     * this is a list of special strings you can use to map
     * to modifier keys when you specify your keyboard shortcuts
     *
     * @type {Object}
     */
    var _SPECIAL_ALIASES = {
        'option': 'alt',
        'command': 'meta',
        'return': 'enter',
        'escape': 'esc',
        'plus': '+',
        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
    };

    /**
     * variable to store the flipped version of _MAP from above
     * needed to check if we should use keypress or not when no action
     * is specified
     *
     * @type {Object|undefined}
     */
    var _REVERSE_MAP;

    /**
     * loop through the f keys, f1 to f19 and add them to the map
     * programatically
     */
    for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = 'f' + i;
    }

    /**
     * loop through to map numbers on the numeric keypad
     */
    for (i = 0; i <= 9; ++i) {

        // This needs to use a string cause otherwise since 0 is falsey
        // mousetrap will never fire for numpad 0 pressed as part of a keydown
        // event.
        //
        // @see https://github.com/ccampbell/mousetrap/pull/258
        _MAP[i + 96] = i.toString();
    }

    /**
     * cross browser add event method
     *
     * @param {Element|HTMLDocument} object
     * @param {string} type
     * @param {Function} callback
     * @returns void
     */
    function _addEvent(object, type, callback) {
        if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
        }

        object.attachEvent('on' + type, callback);
    }

    /**
     * takes the event and returns the key character
     *
     * @param {Event} e
     * @return {string}
     */
    function _characterFromEvent(e) {

        // for keypress events we should return the character as is
        if (e.type == 'keypress') {
            var character = String.fromCharCode(e.which);

            // if the shift key is not pressed then it is safe to assume
            // that we want the character to be lowercase.  this means if
            // you accidentally have caps lock on then your key bindings
            // will continue to work
            //
            // the only side effect that might not be desired is if you
            // bind something like 'A' cause you want to trigger an
            // event when capital A is pressed caps lock will no longer
            // trigger the event.  shift+a will though.
            if (!e.shiftKey) {
                character = character.toLowerCase();
            }

            return character;
        }

        // for non keypress events the special maps are needed
        if (_MAP[e.which]) {
            return _MAP[e.which];
        }

        if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
        }

        // if it is not in the special map

        // with keydown and keyup events the character seems to always
        // come in as an uppercase character whether you are pressing shift
        // or not.  we should make sure it is always lowercase for comparisons
        return String.fromCharCode(e.which).toLowerCase();
    }

    /**
     * checks if two arrays are equal
     *
     * @param {Array} modifiers1
     * @param {Array} modifiers2
     * @returns {boolean}
     */
    function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
    }

    /**
     * takes a key event and figures out what the modifiers are
     *
     * @param {Event} e
     * @returns {Array}
     */
    function _eventModifiers(e) {
        var modifiers = [];

        if (e.shiftKey) {
            modifiers.push('shift');
        }

        if (e.altKey) {
            modifiers.push('alt');
        }

        if (e.ctrlKey) {
            modifiers.push('ctrl');
        }

        if (e.metaKey) {
            modifiers.push('meta');
        }

        return modifiers;
    }

    /**
     * prevents default for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();
            return;
        }

        e.returnValue = false;
    }

    /**
     * stops propogation for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
            return;
        }

        e.cancelBubble = true;
    }

    /**
     * determines if the keycode specified is a modifier key or not
     *
     * @param {string} key
     * @returns {boolean}
     */
    function _isModifier(key) {
        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
    }

    /**
     * reverses the map lookup so that we can look for specific keys
     * to see what can and can't use keypress
     *
     * @return {Object}
     */
    function _getReverseMap() {
        if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {

                // pull out the numeric keypad from here cause keypress should
                // be able to detect the keys from the character
                if (key > 95 && key < 112) {
                    continue;
                }

                if (_MAP.hasOwnProperty(key)) {
                    _REVERSE_MAP[_MAP[key]] = key;
                }
            }
        }
        return _REVERSE_MAP;
    }

    /**
     * picks the best action based on the key combination
     *
     * @param {string} key - character for key
     * @param {Array} modifiers
     * @param {string=} action passed in
     */
    function _pickBestAction(key, modifiers, action) {

        // if no action was picked in we should try to pick the one
        // that we think would work best for this key
        if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
        }

        // modifier keys don't work as expected with keypress,
        // switch to keydown
        if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
        }

        return action;
    }

    /**
     * Converts from a string key combination to an array
     *
     * @param  {string} combination like "command+shift+l"
     * @return {Array}
     */
    function _keysFromString(combination) {
        if (combination === '+') {
            return ['+'];
        }

        combination = combination.replace(/\+{2}/g, '+plus');
        return combination.split('+');
    }

    /**
     * Gets info for a specific key combination
     *
     * @param  {string} combination key combination ("command+s" or "a" or "*")
     * @param  {string=} action
     * @returns {Object}
     */
    function _getKeyInfo(combination, action) {
        var keys;
        var key;
        var i;
        var modifiers = [];

        // take the keys from this pattern and figure out what the actual
        // pattern is all about
        keys = _keysFromString(combination);

        for (i = 0; i < keys.length; ++i) {
            key = keys[i];

            // normalize key names
            if (_SPECIAL_ALIASES[key]) {
                key = _SPECIAL_ALIASES[key];
            }

            // if this is not a keypress event then we should
            // be smart about using shift keys
            // this will only work for US keyboards however
            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
                key = _SHIFT_MAP[key];
                modifiers.push('shift');
            }

            // if this key is a modifier then add it to the list of modifiers
            if (_isModifier(key)) {
                modifiers.push(key);
            }
        }

        // depending on what the key combination is
        // we will try to pick the best event for it
        action = _pickBestAction(key, modifiers, action);

        return {
            key: key,
            modifiers: modifiers,
            action: action
        };
    }

    function _belongsTo(element, ancestor) {
        if (element === null || element === document) {
            return false;
        }

        if (element === ancestor) {
            return true;
        }

        return _belongsTo(element.parentNode, ancestor);
    }

    function Mousetrap(targetElement) {
        var self = this;

        targetElement = targetElement || document;

        if (!(self instanceof Mousetrap)) {
            return new Mousetrap(targetElement);
        }

        /**
         * element to attach key events to
         *
         * @type {Element}
         */
        self.target = targetElement;

        /**
         * a list of all the callbacks setup via Mousetrap.bind()
         *
         * @type {Object}
         */
        self._callbacks = {};

        /**
         * direct map of string combinations to callbacks used for trigger()
         *
         * @type {Object}
         */
        self._directMap = {};

        /**
         * keeps track of what level each sequence is at since multiple
         * sequences can start out with the same sequence
         *
         * @type {Object}
         */
        var _sequenceLevels = {};

        /**
         * variable to store the setTimeout call
         *
         * @type {null|number}
         */
        var _resetTimer;

        /**
         * temporary state where we will ignore the next keyup
         *
         * @type {boolean|string}
         */
        var _ignoreNextKeyup = false;

        /**
         * temporary state where we will ignore the next keypress
         *
         * @type {boolean}
         */
        var _ignoreNextKeypress = false;

        /**
         * are we currently inside of a sequence?
         * type of action ("keyup" or "keydown" or "keypress") or false
         *
         * @type {boolean|string}
         */
        var _nextExpectedAction = false;

        /**
         * resets all sequence counters except for the ones passed in
         *
         * @param {Object} doNotReset
         * @returns void
         */
        function _resetSequences(doNotReset) {
            doNotReset = doNotReset || {};

            var activeSequences = false,
                key;

            for (key in _sequenceLevels) {
                if (doNotReset[key]) {
                    activeSequences = true;
                    continue;
                }
                _sequenceLevels[key] = 0;
            }

            if (!activeSequences) {
                _nextExpectedAction = false;
            }
        }

        /**
         * finds all callbacks that match based on the keycode, modifiers,
         * and action
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event|Object} e
         * @param {string=} sequenceName - name of the sequence we are looking for
         * @param {string=} combination
         * @param {number=} level
         * @returns {Array}
         */
        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
            var i;
            var callback;
            var matches = [];
            var action = e.type;

            // if there are no events related to this keycode
            if (!self._callbacks[character]) {
                return [];
            }

            // if a modifier key is coming up on its own we should allow it
            if (action == 'keyup' && _isModifier(character)) {
                modifiers = [character];
            }

            // loop through all callbacks for the key that was pressed
            // and see if any of them match
            for (i = 0; i < self._callbacks[character].length; ++i) {
                callback = self._callbacks[character][i];

                // if a sequence name is not specified, but this is a sequence at
                // the wrong level then move onto the next match
                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                    continue;
                }

                // if the action we are looking for doesn't match the action we got
                // then we should keep going
                if (action != callback.action) {
                    continue;
                }

                // if this is a keypress event and the meta key and control key
                // are not pressed that means that we need to only look at the
                // character, otherwise check the modifiers as well
                //
                // chrome will not fire a keypress if meta or control is down
                // safari will fire a keypress if meta or meta+shift is down
                // firefox will fire a keypress if meta or control is down
                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

                    // when you bind a combination or sequence a second time it
                    // should overwrite the first one.  if a sequenceName or
                    // combination is specified in this call it does just that
                    //
                    // @todo make deleting its own method?
                    var deleteCombo = !sequenceName && callback.combo == combination;
                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                    if (deleteCombo || deleteSequence) {
                        self._callbacks[character].splice(i, 1);
                    }

                    matches.push(callback);
                }
            }

            return matches;
        }

        /**
         * actually calls the callback function
         *
         * if your callback function returns false this will use the jquery
         * convention - prevent default and stop propogation on the event
         *
         * @param {Function} callback
         * @param {Event} e
         * @returns void
         */
        function _fireCallback(callback, e, combo, sequence) {

            // if this event should not happen stop here
            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
                return;
            }

            if (callback(e, combo) === false) {
                _preventDefault(e);
                _stopPropagation(e);
            }
        }

        /**
         * handles a character key event
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event} e
         * @returns void
         */
        self._handleKey = function(character, modifiers, e) {
            var callbacks = _getMatches(character, modifiers, e);
            var i;
            var doNotReset = {};
            var maxLevel = 0;
            var processedSequenceCallback = false;

            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
            for (i = 0; i < callbacks.length; ++i) {
                if (callbacks[i].seq) {
                    maxLevel = Math.max(maxLevel, callbacks[i].level);
                }
            }

            // loop through matching callbacks for this key event
            for (i = 0; i < callbacks.length; ++i) {

                // fire for all sequence callbacks
                // this is because if for example you have multiple sequences
                // bound such as "g i" and "g t" they both need to fire the
                // callback for matching g cause otherwise you can only ever
                // match the first one
                if (callbacks[i].seq) {

                    // only fire callbacks for the maxLevel to prevent
                    // subsequences from also firing
                    //
                    // for example 'a option b' should not cause 'option b' to fire
                    // even though 'option b' is part of the other sequence
                    //
                    // any sequences that do not match here will be discarded
                    // below by the _resetSequences call
                    if (callbacks[i].level != maxLevel) {
                        continue;
                    }

                    processedSequenceCallback = true;

                    // keep a list of which sequences were matches for later
                    doNotReset[callbacks[i].seq] = 1;
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
                    continue;
                }

                // if there were no sequence matches but we are still here
                // that means this is a regular match so we should fire that
                if (!processedSequenceCallback) {
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
                }
            }

            // if the key you pressed matches the type of sequence without
            // being a modifier (ie "keyup" or "keypress") then we should
            // reset all sequences that were not matched by this event
            //
            // this is so, for example, if you have the sequence "h a t" and you
            // type "h e a r t" it does not match.  in this case the "e" will
            // cause the sequence to reset
            //
            // modifier keys are ignored because you can have a sequence
            // that contains modifiers such as "enter ctrl+space" and in most
            // cases the modifier key will be pressed before the next key
            //
            // also if you have a sequence such as "ctrl+b a" then pressing the
            // "b" key will trigger a "keypress" and a "keydown"
            //
            // the "keydown" is expected when there is a modifier, but the
            // "keypress" ends up matching the _nextExpectedAction since it occurs
            // after and that causes the sequence to reset
            //
            // we ignore keypresses in a sequence that directly follow a keydown
            // for the same character
            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
                _resetSequences(doNotReset);
            }

            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
        };

        /**
         * handles a keydown event
         *
         * @param {Event} e
         * @returns void
         */
        function _handleKeyEvent(e) {

            // normalize e.which for key events
            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
            if (typeof e.which !== 'number') {
                e.which = e.keyCode;
            }

            var character = _characterFromEvent(e);

            // no character found then stop
            if (!character) {
                return;
            }

            // need to use === for the character check because the character can be 0
            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
                _ignoreNextKeyup = false;
                return;
            }

            self.handleKey(character, _eventModifiers(e), e);
        }

        /**
         * called to set a 1 second timeout on the specified sequence
         *
         * this is so after each key press in the sequence you have 1 second
         * to press the next key before you have to start over
         *
         * @returns void
         */
        function _resetSequenceTimer() {
            clearTimeout(_resetTimer);
            _resetTimer = setTimeout(_resetSequences, 1000);
        }

        /**
         * binds a key sequence to an event
         *
         * @param {string} combo - combo specified in bind call
         * @param {Array} keys
         * @param {Function} callback
         * @param {string=} action
         * @returns void
         */
        function _bindSequence(combo, keys, callback, action) {

            // start off by adding a sequence level record for this combination
            // and setting the level to 0
            _sequenceLevels[combo] = 0;

            /**
             * callback to increase the sequence level for this sequence and reset
             * all other sequences that were active
             *
             * @param {string} nextAction
             * @returns {Function}
             */
            function _increaseSequence(nextAction) {
                return function() {
                    _nextExpectedAction = nextAction;
                    ++_sequenceLevels[combo];
                    _resetSequenceTimer();
                };
            }

            /**
             * wraps the specified callback inside of another function in order
             * to reset all sequence counters as soon as this sequence is done
             *
             * @param {Event} e
             * @returns void
             */
            function _callbackAndReset(e) {
                _fireCallback(callback, e, combo);

                // we should ignore the next key up if the action is key down
                // or keypress.  this is so if you finish a sequence and
                // release the key the final key will not trigger a keyup
                if (action !== 'keyup') {
                    _ignoreNextKeyup = _characterFromEvent(e);
                }

                // weird race condition if a sequence ends with the key
                // another sequence begins with
                setTimeout(_resetSequences, 10);
            }

            // loop through keys one at a time and bind the appropriate callback
            // function.  for any key leading up to the final one it should
            // increase the sequence. after the final, it should reset all sequences
            //
            // if an action is specified in the original bind call then that will
            // be used throughout.  otherwise we will pass the action that the
            // next key in the sequence should match.  this allows a sequence
            // to mix and match keypress and keydown events depending on which
            // ones are better suited to the key provided
            for (var i = 0; i < keys.length; ++i) {
                var isFinal = i + 1 === keys.length;
                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
                _bindSingle(keys[i], wrappedCallback, action, combo, i);
            }
        }

        /**
         * binds a single keyboard combination
         *
         * @param {string} combination
         * @param {Function} callback
         * @param {string=} action
         * @param {string=} sequenceName - name of sequence if part of sequence
         * @param {number=} level - what part of the sequence the command is
         * @returns void
         */
        function _bindSingle(combination, callback, action, sequenceName, level) {

            // store a direct mapped reference for use with Mousetrap.trigger
            self._directMap[combination + ':' + action] = callback;

            // make sure multiple spaces in a row become a single space
            combination = combination.replace(/\s+/g, ' ');

            var sequence = combination.split(' ');
            var info;

            // if this pattern is a sequence of keys then run through this method
            // to reprocess each pattern one key at a time
            if (sequence.length > 1) {
                _bindSequence(combination, sequence, callback, action);
                return;
            }

            info = _getKeyInfo(combination, action);

            // make sure to initialize array if this is the first time
            // a callback is added for this key
            self._callbacks[info.key] = self._callbacks[info.key] || [];

            // remove an existing match if there is one
            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

            // add this call back to the array
            // if it is a sequence put it at the beginning
            // if not put it at the end
            //
            // this is important because the way these are processed expects
            // the sequence ones to come first
            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
                callback: callback,
                modifiers: info.modifiers,
                action: info.action,
                seq: sequenceName,
                level: level,
                combo: combination
            });
        }

        /**
         * binds multiple combinations to the same callback
         *
         * @param {Array} combinations
         * @param {Function} callback
         * @param {string|undefined} action
         * @returns void
         */
        self._bindMultiple = function(combinations, callback, action) {
            for (var i = 0; i < combinations.length; ++i) {
                _bindSingle(combinations[i], callback, action);
            }
        };

        // start!
        _addEvent(targetElement, 'keypress', _handleKeyEvent);
        _addEvent(targetElement, 'keydown', _handleKeyEvent);
        _addEvent(targetElement, 'keyup', _handleKeyEvent);
    }

    /**
     * binds an event to mousetrap
     *
     * can be a single key, a combination of keys separated with +,
     * an array of keys, or a sequence of keys separated by spaces
     *
     * be sure to list the modifier keys first to make sure that the
     * correct key ends up getting bound (the last key in the pattern)
     *
     * @param {string|Array} keys
     * @param {Function} callback
     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
     * @returns void
     */
    Mousetrap.prototype.bind = function(keys, callback, action) {
        var self = this;
        keys = keys instanceof Array ? keys : [keys];
        self._bindMultiple.call(self, keys, callback, action);
        return self;
    };

    /**
     * unbinds an event to mousetrap
     *
     * the unbinding sets the callback function of the specified key combo
     * to an empty function and deletes the corresponding key in the
     * _directMap dict.
     *
     * TODO: actually remove this from the _callbacks dictionary instead
     * of binding an empty function
     *
     * the keycombo+action has to be exactly the same as
     * it was defined in the bind method
     *
     * @param {string|Array} keys
     * @param {string} action
     * @returns void
     */
    Mousetrap.prototype.unbind = function(keys, action) {
        var self = this;
        return self.bind.call(self, keys, function() {}, action);
    };

    /**
     * triggers an event that has already been bound
     *
     * @param {string} keys
     * @param {string=} action
     * @returns void
     */
    Mousetrap.prototype.trigger = function(keys, action) {
        var self = this;
        if (self._directMap[keys + ':' + action]) {
            self._directMap[keys + ':' + action]({}, keys);
        }
        return self;
    };

    /**
     * resets the library back to its initial state.  this is useful
     * if you want to clear out the current keyboard shortcuts and bind
     * new ones - for example if you switch to another page
     *
     * @returns void
     */
    Mousetrap.prototype.reset = function() {
        var self = this;
        self._callbacks = {};
        self._directMap = {};
        return self;
    };

    /**
     * should we stop this event before firing off callbacks
     *
     * @param {Event} e
     * @param {Element} element
     * @return {boolean}
     */
    Mousetrap.prototype.stopCallback = function(e, element) {
        var self = this;

        // if the element has the class "mousetrap" then no need to stop
        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
            return false;
        }

        if (_belongsTo(element, self.target)) {
            return false;
        }

        // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,
        // not the initial event target in the shadow tree. Note that not all events cross the
        // shadow boundary.
        // For shadow trees with `mode: 'open'`, the initial event target is the first element in
        // the event’s composed path. For shadow trees with `mode: 'closed'`, the initial event
        // target cannot be obtained.
        if ('composedPath' in e && typeof e.composedPath === 'function') {
            // For open shadow trees, update `element` so that the following check works.
            var initialEventTarget = e.composedPath()[0];
            if (initialEventTarget !== e.target) {
                element = initialEventTarget;
            }
        }

        // stop for input, select, and textarea
        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
    };

    /**
     * exposes _handleKey publicly so it can be overwritten by extensions
     */
    Mousetrap.prototype.handleKey = function() {
        var self = this;
        return self._handleKey.apply(self, arguments);
    };

    /**
     * allow custom key mappings
     */
    Mousetrap.addKeycodes = function(object) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                _MAP[key] = object[key];
            }
        }
        _REVERSE_MAP = null;
    };

    /**
     * Init the global mousetrap functions
     *
     * This method is needed to allow the global mousetrap functions to work
     * now that mousetrap is a constructor function.
     */
    Mousetrap.init = function() {
        var documentMousetrap = Mousetrap(document);
        for (var method in documentMousetrap) {
            if (method.charAt(0) !== '_') {
                Mousetrap[method] = (function(method) {
                    return function() {
                        return documentMousetrap[method].apply(documentMousetrap, arguments);
                    };
                } (method));
            }
        }
    };

    Mousetrap.init();

    // expose mousetrap to the global object
    window.Mousetrap = Mousetrap;

    // expose as a common js module
    if ( true && module.exports) {
        module.exports = Mousetrap;
    }

    // expose mousetrap as an AMD module
    if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return Mousetrap;
        }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * SearchIndex. Define an index for searching for reaction and metabolites in
 * the map. The index is stored in SearchIndex.index, an object of id/record
 * pairs.
 */
var SearchIndex = function () {
  function SearchIndex() {
    _classCallCheck(this, SearchIndex);

    this.index = {};
  }

  /**
   * Insert a record into the index.
   * @param id - A unique string id.
   * @param record - Records have the form: { 'name': '', 'data': {} }
   * Search is performed on substrings of the name.
   * @param overwrite - (Default false) For faster performance, make overwrite true,
   * and records will be inserted without checking for an existing record.
   * @param check_record - (Default false) For faster performance, make
   * check_record * false. If true, records will be checked to make sure they
   * have name and * data attributes.
   */


  SearchIndex.prototype.insert = function insert(id, record, overwrite, checkRecord) {
    if (!overwrite && id in this.index) {
      throw new Error('id is already in the index');
    }
    if (checkRecord && !('name' in record && 'data' in record)) {
      throw new Error('malformed record');
    }
    this.index[id] = record;
  };

  /**
   * Remove the matching record. Returns true is a record is found, or false if
   * no match is found.
   */


  SearchIndex.prototype.remove = function remove(recordId) {
    if (recordId in this.index) {
      delete this.index[recordId];
      return true;
    } else {
      return false;
    }
  };

  /**
   * Find a record that matches the substring. Returns an array of data from
   * matching records.
   */


  SearchIndex.prototype.find = function find(substring) {
    var re = RegExp(substring, 'i'); // ignore case
    var matches = [];
    for (var id in this.index) {
      var record = this.index[id];
      if (re.exec(record.name)) {
        matches.push(record.data);
      }
    }
    return matches;
  };

  return SearchIndex;
}();

exports.default = SearchIndex;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _baconjs = __webpack_require__(37);

var _baconjs2 = _interopRequireDefault(_baconjs);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Hold on to event when holdProperty is true, and only keep them if
 * acceptProperty is true (when holdProperty becomes false).
 */
function convertToConditionalStream(valueStream, statusStream) {
  // Combine values with status to revert to last value when a reject is passed.
  var init = {
    savedValue: null,
    currentValue: null,
    lastStatus: null
  };

  var held = _baconjs2.default.combineAsArray(valueStream, statusStream.toProperty(null)).scan(init, function (_ref, _ref2) {
    var savedValue = _ref.savedValue,
        currentValue = _ref.currentValue,
        lastStatus = _ref.lastStatus;
    var value = _ref2[0],
        status = _ref2[1];

    // See if the status was just set
    var newStatus = lastStatus !== status;

    if (newStatus && status === 'hold') {
      // Record the currentValue as the savedValue
      return {
        savedValue: currentValue,
        currentValue: currentValue,
        lastStatus: status
      };
    } else if (!newStatus && status === 'hold') {
      // Record the current value, and keep the savedValue unchanged
      return {
        savedValue: savedValue,
        currentValue: value,
        lastStatus: status
      };
    } else if (newStatus && status === 'abandon') {
      // Keep the saved value
      return {
        savedValue: null,
        currentValue: savedValue,
        lastStatus: status
      };
    } else if (newStatus && status === 'accept') {
      // Keep the new value
      return {
        savedValue: null,
        currentValue: currentValue,
        lastStatus: status
      };
    } else {
      // Not held, so keep the value
      return {
        savedValue: null,
        currentValue: value,
        lastStatus: status
      };
    }
  })
  // Skip the initial null value
  .skip(1)
  // Get the current value
  .map(function (_ref3) {
    var currentValue = _ref3.currentValue;
    return currentValue;
  })
  // Skip duplicate values
  .skipDuplicates()
  // property -> event stream
  .toEventStream();

  return held;
}

/**
 * Settings. A class to manage settings for a Map.
 *
 * Arguments
 * ---------
 *
 * setOption: A function, fn(key), that returns the option value for the key.
 *
 * getOption: A function, fn(key, value), that sets the option for the key and
 * value.
 *
 * conditionalOptions: The options to that are conditionally accepted when
 * changed. Changes can be abandoned by calling abandonChanges(), or accepted
 * by calling acceptChanges().
  * @param optionsWithDefaults - The current option values
  * @param conditionalOptions - The options to that are conditionally accepted
  *                             when changed. Changes can be abandoned by calling
  *                             abandon_changes(), or accepted by calling
  *                             accept_changes().
  */

var Settings = function () {
  function Settings(optionsWithDefaults, conditionalOptions) {
    var _this = this;

    _classCallCheck(this, Settings);

    this._options = optionsWithDefaults;

    // Manage accepting/abandoning changes
    this.statusBus = new _baconjs2.default.Bus()

    // Create the options
    ;
    var _$chain$mapObject$pai = _underscore2.default.chain(optionsWithDefaults).mapObject(function (value, key) {
      var isConditional = _underscore2.default.contains(conditionalOptions, key);

      var _createSetting = _this.createSetting(key, value, isConditional),
          bus = _createSetting.bus,
          stream = _createSetting.stream,
          acceptedStream = _createSetting.acceptedStream;

      return [bus, stream, acceptedStream];
    }) // { k: [ b, s ], ... }
    .pairs() // [ [ k, [ b, s ] ], ... ]
    .map(function (_ref4) {
      var name = _ref4[0],
          _ref4$ = _ref4[1],
          bus = _ref4$[0],
          stream = _ref4$[1],
          acceptedStream = _ref4$[2];
      return [[name, bus], [name, stream], [name, acceptedStream]];
    }) // [ [ [ k, b ], [ k, s ] ], ... ]
    .unzip() // [ [ [ k, b ], ... ], [ [ k, s ], ... ] ]
    .map(function (x) {
      return _underscore2.default.object(x);
    }) // [ { k: b, ... }, { k: s, ... } ]
    .value();

    this.busses = _$chain$mapObject$pai[0];
    this.streams = _$chain$mapObject$pai[1];
    this.acceptedStreams = _$chain$mapObject$pai[2];
  }

  /**
   * Set up a new bus and stream for a conditional setting (i.e. one that can be
   * canceled in the settings menu.
   */


  Settings.prototype.createSetting = function createSetting(name, initialValue, isConditional) {
    var _this2 = this;

    // Set up the bus
    var bus = new _baconjs2.default.Bus();

    // Make the event stream and conditionally accept changes
    var stream = isConditional ? convertToConditionalStream(bus, this.statusBus) : bus.toEventStream();

    // Make a stream for the accepted values only. First get the latest value
    // after accepting. Also get a latest copy of the correct value if the data
    // is abandoned.
    var acceptedStream = stream.sampledBy(this.statusBus.filter(function (status) {
      return status === 'accept' || status === 'abandon';
    })).merge(
    // Then merge with all the other changes
    stream.filter(this.statusBus.map(function (status) {
      return status === 'accept';
    }).toProperty(true)));

    // Get the latest
    stream.onValue(function (v) {
      _this2._options[name] = v;
    });

    // Push the initial value
    bus.push(initialValue);

    return { bus: bus, stream: stream, acceptedStream: acceptedStream };
  };

  /**
   * Deprecated. Use `set` instead.
   */


  Settings.prototype.set_conditional = function set_conditional(name, value) {
    // eslint-disable-line camelcase
    console.warn('set_conditional is deprecated. Use Settings.set() instead');
    return this.set(name, value);
  };

  /**
   * Set the option. This should always be used instead of setting options
   * directly. To set options that respect the Settings menu Accept/Abandon, use
   * setConditional().
   * @param {String} name - The option name
   * @param {Any} value - The new value
   * can check whether the change was made internally to avoid loops.
   */


  Settings.prototype.set = function set(name, value) {
    if (!(name in this.busses)) {
      throw new Error('Invalid setting name ' + name);
    }
    this.busses[name].push(value);
  };

  /**
   * Deprecated. Use `get` intead.
   */


  Settings.prototype.get_option = function get_option(name) {
    // eslint-disable-line camelcase
    console.warn('get_option is deprecated. Use Settings.get() instead');
    return this.get(name);
  };

  /**
   * Get an option
   */


  Settings.prototype.get = function get(name) {
    return this._options[name];
  };

  Settings.prototype.holdChanges = function holdChanges() {
    this.statusBus.push('hold');
  };

  Settings.prototype.abandonChanges = function abandonChanges() {
    this.statusBus.push('abandon');
  };

  Settings.prototype.acceptChanges = function acceptChanges() {
    this.statusBus.push('accept');
  };

  return Settings;
}();

exports.default = Settings;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _preact = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */


var Wrapper = function (_Component) {
  _inherits(Wrapper, _Component);

  function Wrapper(props) {
    _classCallCheck(this, Wrapper);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.state = {};
    return _this;
  }

  Wrapper.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    this.props.connectSetStateFn(function (props) {
      return _this2.setState(props);
    });
  };

  Wrapper.prototype.is_visible = function is_visible() {
    // eslint-disable-line camelcase
    return this.state.display;
  };

  Wrapper.prototype.render = function render() {
    var _this3 = this;

    if (!this.state.display) return null;

    // Pass the new props, and always pass the ref
    return (0, _preact.h)(this.props.component, _extends({
      setDisplay: function setDisplay(display) {
        return _this3.setState({ display: display });
      },
      ref: this.props.refPassthrough
    }, this.state));
  };

  return Wrapper;
}(_preact.Component);

/**
 * Wrapper for better integration of Preact components with Escher. The
 * component can be updated using the connectSetStateFn to set up a callback for
 * updates from other components.
 * @param {} component - A Preact component
 *
 * @param {} ref - A preact ref for the wrapper so that the "display" state can
 *                 be tracked.
 */


function renderWrapper(component, ref, connectSetStateFn, divNode) {
  var refPassthrough = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

  (0, _preact.render)((0, _preact.h)(Wrapper, {
    component: component,
    connectSetStateFn: connectSetStateFn,
    ref: ref,
    refPassthrough: refPassthrough
  }), divNode,
  // If there is already a div, re-render it. Otherwise make a new one
  divNode.children.length > 0 ? divNode.firstChild : undefined);
}

exports.default = renderWrapper;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.libs = exports.EscherMapModel = exports.EscherMapView = exports.ZoomContainer = exports.dataStyles = exports.Settings = exports.SearchIndex = exports.utils = exports.CobraModel = exports.UndoStack = exports.DataMenu = exports.KeyManager = exports.Behavior = exports.Map = exports.default = exports.Builder = exports.version = undefined;

var _Builder = __webpack_require__(39);

Object.defineProperty(exports, 'Builder', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Builder).default;
  }
});
Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Builder).default;
  }
});

var _Map = __webpack_require__(47);

Object.defineProperty(exports, 'Map', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Map).default;
  }
});

var _Behavior = __webpack_require__(48);

Object.defineProperty(exports, 'Behavior', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Behavior).default;
  }
});

var _KeyManager = __webpack_require__(52);

Object.defineProperty(exports, 'KeyManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_KeyManager).default;
  }
});

var _DataMenu = __webpack_require__(109);

Object.defineProperty(exports, 'DataMenu', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DataMenu).default;
  }
});

var _UndoStack = __webpack_require__(51);

Object.defineProperty(exports, 'UndoStack', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_UndoStack).default;
  }
});

var _CobraModel = __webpack_require__(36);

Object.defineProperty(exports, 'CobraModel', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CobraModel).default;
  }
});

var _utils = __webpack_require__(4);

Object.defineProperty(exports, 'utils', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_utils).default;
  }
});

var _SearchIndex = __webpack_require__(54);

Object.defineProperty(exports, 'SearchIndex', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SearchIndex).default;
  }
});

var _Settings = __webpack_require__(55);

Object.defineProperty(exports, 'Settings', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Settings).default;
  }
});

var _dataStyles = __webpack_require__(20);

Object.defineProperty(exports, 'dataStyles', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_dataStyles).default;
  }
});

var _ZoomContainer = __webpack_require__(46);

Object.defineProperty(exports, 'ZoomContainer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ZoomContainer).default;
  }
});

var _widget = __webpack_require__(110);

Object.defineProperty(exports, 'EscherMapView', {
  enumerable: true,
  get: function get() {
    return _widget.EscherMapView;
  }
});
Object.defineProperty(exports, 'EscherMapModel', {
  enumerable: true,
  get: function get() {
    return _widget.EscherMapModel;
  }
});

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

var _preact = __webpack_require__(6);

var _preact2 = _interopRequireDefault(_preact);

var _baconjs = __webpack_require__(37);

var _baconjs2 = _interopRequireDefault(_baconjs);

var _mousetrap = __webpack_require__(53);

var _mousetrap2 = _interopRequireDefault(_mousetrap);

var _vkbeautify = __webpack_require__(40);

var _vkbeautify2 = _interopRequireDefault(_vkbeautify);

var _d3Selection = __webpack_require__(2);

var _d3Request = __webpack_require__(31);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var version = exports.version = "1.7.3"; /**
                                                * @license
                                                *
                                                * Escher
                                                * Author: Zachary King
                                                *
                                                * The MIT License (MIT)
                                                *
                                                * This software is Copyright © 2015 The Regents of the University of
                                                * California. All Rights Reserved.
                                                *
                                                * Permission is hereby granted, free of charge, to any person obtaining a copy
                                                * of this software and associated documentation files (the "Software"), to deal
                                                * in the Software without restriction, including without limitation the rights
                                                * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                                                * copies of the Software, and to permit persons to whom the Software is
                                                * furnished to do so, subject to the following conditions:
                                                *
                                                * The above copyright notice and this permission notice shall be included in
                                                * all copies or substantial portions of the Software.
                                                *
                                                * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                                                * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                                                * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                                                * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                                                * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                                                * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                                                * THE SOFTWARE.
                                                */

// ESCHER_VERSION provided by webpack plugin or main-node
/* global ESCHER_VERSION */

var libs = exports.libs = {
  _: _underscore2.default,
  underscore: _underscore2.default,
  preact: _preact2.default,
  baconjs: _baconjs2.default,
  mousetrap: _mousetrap2.default,
  vkbeautify: _vkbeautify2.default,
  d3_selection: _d3Selection.selection,
  d3_select: _d3Selection.select,
  d3_json: _d3Request.json
};

/***/ }),
/* 58 */,
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if ( true && module.exports) {
  module.exports.saveAs = saveAs;
} else if (( true && __webpack_require__(44) !== null) && (__webpack_require__(45) !== null)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return saveAs;
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(4);

var _utils2 = _interopRequireDefault(_utils);

var _PlacedDiv = __webpack_require__(35);

var _PlacedDiv2 = _interopRequireDefault(_PlacedDiv);

var _completely = __webpack_require__(61);

var _completely2 = _interopRequireDefault(_completely);

var _DirectionArrow = __webpack_require__(62);

var _DirectionArrow2 = _interopRequireDefault(_DirectionArrow);

var _CobraModel = __webpack_require__(36);

var _CobraModel2 = _interopRequireDefault(_CobraModel);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

var _d3Selection = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * BuildInput
 * @param selection - A d3 selection for the BuildInput.
 * @param map - A Map instance.
 * @param zoomContainer - A ZoomContainer instance.
 * @param settings - A Settings instance.
 */
var BuildInput = function () {
  function BuildInput(selection, map, zoomContainer, settings) {
    var _this = this;

    _classCallCheck(this, BuildInput);

    // set up container
    var newSel = selection.append('div').attr('id', 'rxn-input');
    this.placed_div = (0, _PlacedDiv2.default)(newSel, map, { x: 240, y: 0 });
    this.placed_div.hide();

    // set up complete.ly
    this.completely = (0, _completely2.default)(newSel.node(), { backgroundColor: '#eee' });

    // close button
    newSel.append('button').attr('class', 'button input-close-button').text('×').on('mousedown', function () {
      return _this.hideDropdown();
    });

    // map
    this.map = map;
    // set up the reaction direction arrow
    var defaultAngle = 90; // degrees
    this.direction_arrow = new _DirectionArrow2.default(map.sel);
    this.direction_arrow.setRotation(defaultAngle);
    this.setUpMapCallbacks(map);

    // zoom container
    this.zoomContainer = zoomContainer;
    this.setUpZoomCallbacks(zoomContainer);

    // settings
    this.settings = settings;

    // toggle off
    this.toggle(false);
    this.target_coords = null;
  }

  BuildInput.prototype.setUpMapCallbacks = function setUpMapCallbacks(map) {
    var _this2 = this;

    // input
    map.callback_manager.set('select_metabolite_with_id.input', function (selectedNode, coords) {
      if (_this2.is_active) {
        var hasModel = _this2.reload(selectedNode, coords, false);
        if (hasModel) _this2.showDropdown(coords);
      }
      _this2.hideTarget();
    });
    map.callback_manager.set('select_selectable.input', function (count, selectedNode, coords) {
      _this2.hideTarget();
      if (count === 1 && _this2.is_active && coords) {
        var hasModel = _this2.reload(selectedNode, coords, false);
        if (hasModel) _this2.showDropdown(coords);
      } else {
        _this2.toggle(false);
      }
    });
    map.callback_manager.set('deselect_nodes', function () {
      _this2.direction_arrow.hide();
      _this2.hideDropdown();
    });

    // svg export
    map.callback_manager.set('before_svg_export', function () {
      _this2.direction_arrow.hide();
      _this2.hideTarget();
    });
  };

  BuildInput.prototype.setUpZoomCallbacks = function setUpZoomCallbacks(zoomContainer) {
    // TODO this is broken.
    // Should place either for selected or for location on zoom or pan.
    // zoomContainer.callbackManager.set('zoom_change.input', () => {
    //   if (this.is_active) {
    //     this.place_at_selected()
    //   }
    // })
  };

  BuildInput.prototype.is_visible = function is_visible() {
    // eslint-disable-line camelcase
    return this.placed_div.is_visible();
  };

  BuildInput.prototype.toggle = function toggle(onOff) {
    if (onOff === undefined) this.is_active = !this.is_active;else this.is_active = onOff;
    if (this.is_active) {
      this.toggleStartReactionListener(true);
      var hasModelAndSelection = true;
      if (_underscore2.default.isNull(this.target_coords)) {
        hasModelAndSelection = this.reloadAtSelected();
      } else {
        this.placed_div.place(this.target_coords);
      }
      if (hasModelAndSelection) {
        this.showDropdown();
        this.map.set_status('Click on the canvas or an existing metabolite');
      }
      this.direction_arrow.show();
    } else {
      this.toggleStartReactionListener(false);
      this.hideDropdown();
      this.map.set_status(null);
      this.direction_arrow.hide();
    }
  };

  BuildInput.prototype.showDropdown = function showDropdown(coords) {
    var _this3 = this;

    // escape key
    this.clear_escape = this.map.key_manager.addEscapeListener(function () {
      return _this3.hideDropdown();
    }, true);
    // dropdown
    this.completely.input.blur();
    this.completely.repaint();
    this.completely.setText('');
    this.completely.input.focus();
  };

  BuildInput.prototype.hideDropdown = function hideDropdown() {
    // escape key
    if (this.clear_escape) this.clear_escape();
    this.clear_escape = null;
    // dropdown
    this.placed_div.hide();
    this.completely.input.blur();
    this.completely.hideDropDown();
  };

  BuildInput.prototype.place = function place(coords) {
    this.placed_div.place(coords);
    this.direction_arrow.setLocation(coords);
    this.direction_arrow.show();
  };

  /**
   * Reload data for autocomplete box and redraw box at the first selected node.
   * @return {Boolean} Returns true if a model is present and a node is selected.
   */


  BuildInput.prototype.reloadAtSelected = function reloadAtSelected() {
    // get the selected node
    this.map.deselect_text_labels();
    var selectedNode = this.map.select_single_node();
    if (selectedNode === null) return false;
    var coords = { x: selectedNode.x, y: selectedNode.y
      // reload the reaction input
    };return this.reload(selectedNode, coords, false);
  };

  BuildInput.prototype.alreadyDrawn = function alreadyDrawn(biggId, reactions) {
    for (var drawnId in reactions) {
      if (reactions[drawnId].bigg_id === biggId) {
        return true;
      }
    }
    return false;
  };

  /**
   * Reload data for autocomplete box and redraw box at the new coordinates.
   * @param {} selectedNode -
   * @param {} coords -
   * @param {Boolean} startingFromScratch -
   * @return {Boolean} Returns true if a model is present.
   */


  BuildInput.prototype.reload = function reload(selectedNode, coords, startingFromScratch) {
    var _this4 = this;

    // Try finding the selected node
    if (!startingFromScratch && !selectedNode) {
      console.error('No selected node and not starting from scratch');
      return;
    }

    this.place(coords);

    if (this.map.cobra_model === null) {
      this.completely.setText('Cannot add: No model.');
      // this.completely.repaint()
      return false;
    }

    // settings
    var showNames = this.settings.get('identifiers_on_map') === 'name';
    var allowDuplicates = this.settings.get('allow_building_duplicate_reactions');

    // Find selected
    var options = [];
    var cobraReactions = this.map.cobra_model.reactions;
    var cobraMetabolites = this.map.cobra_model.metabolites;
    var reactions = this.map.reactions;
    var hasDataOnReactions = this.map.has_data_on_reactions;
    var selectedMetName = selectedNode ? showNames ? selectedNode.name : selectedNode.bigg_id : '';
    var boldMetsInStr = function boldMetsInStr(str, mets) {
      return str.replace(new RegExp('(^| )(' + mets.join('|') + ')($| )', 'g'), '$1<b>$2</b>$3');
    };

    // for reactions
    var reactionSuggestions = {};
    for (var biggId in cobraReactions) {
      var reaction = cobraReactions[biggId];
      var reactionName = reaction.name;
      var showReactionName = showNames ? reactionName : biggId;

      // ignore drawn reactions
      if (!allowDuplicates && this.alreadyDrawn(biggId, reactions)) {
        continue;
      }

      // check segments for match to selected metabolite
      for (var metBiggId in reaction.metabolites) {
        // if starting with a selected metabolite, check for that id
        if (startingFromScratch || metBiggId === selectedNode.bigg_id) {
          // don't add suggestions twice
          if (biggId in reactionSuggestions) continue;

          // get the metabolite names or IDs
          var mets = {};
          var showMetNames = [];
          var metId = void 0;
          if (showNames) {
            for (metId in reaction.metabolites) {
              var name = cobraMetabolites[metId].name;
              mets[name] = reaction.metabolites[metId];
              showMetNames.push(name);
            }
          } else {
            mets = _utils2.default.clone(reaction.metabolites);
            for (metId in reaction.metabolites) {
              showMetNames.push(metId);
            }
          }
          var showGeneNames = _underscore2.default.flatten(reaction.genes.map(function (g) {
            return [g.name, g.biggId];
          }));
          // get the reaction string
          var reactionString = _CobraModel2.default.build_reaction_string(mets, reaction.reversibility, reaction.lower_bound, reaction.upper_bound);
          // make the matches list and filter out any missing entries (e.g.
          // missing gene names from model
          var matches = [showReactionName].concat(showMetNames).concat(showGeneNames).filter(function (x) {
            return x;
          });

          if (hasDataOnReactions) {
            options.push({
              reaction_data: reaction.data,
              html: '<b>' + showReactionName + '</b>' + ': ' + reaction.data_string,
              matches: matches,
              id: biggId
            });
          } else {
            options.push({
              html: '<b>' + showReactionName + '</b>' + '\t' + boldMetsInStr(reactionString, [selectedMetName]),
              matches: matches,
              id: biggId
            });
          }
          reactionSuggestions[biggId] = true;
        }
      }
    }

    // Generate the array of reactions to suggest and sort it
    var sortFn = hasDataOnReactions ? function (x, y) {
      return Math.abs(x.reaction_data) > Math.abs(y.reaction_data) ? -1 : 1;
    } : function (x, y) {
      return x.html.toLowerCase() < y.html.toLowerCase() ? -1 : 1;
    };

    // set up the box with data
    this.completely.options = options.sort(sortFn);

    // TODO test this behavior
    // if (strings_to_display.length==1) this.completely.setText(strings_to_display[0])
    // else this.completely.setText("")
    this.completely.setText('');

    var checkAndBuild = function checkAndBuild(id) {
      if (id !== null) {
        // make sure the selected node exists, in case changes were made in the meantime
        if (startingFromScratch) {
          _this4.map.new_reaction_from_scratch(id, coords, _this4.direction_arrow.getRotation());
        } else {
          if (!(selectedNode.node_id in _this4.map.nodes)) {
            console.error('Selected node no longer exists');
            _this4.hideDropdown();
            return;
          }
          _this4.map.new_reaction_for_metabolite(id, selectedNode.node_id, _this4.direction_arrow.getRotation());
        }
      }
    };
    this.completely.onEnter = function (id) {
      this.setText('');
      this.onChange('');
      checkAndBuild(id);
    };

    return true;
  };

  /**
   * Toggle listening for a click to place a new reaction on the canvas.
   */


  BuildInput.prototype.toggleStartReactionListener = function toggleStartReactionListener(onOff) {
    var _this5 = this;

    if (onOff === undefined) {
      this.start_reaction_listener = !this.start_reaction_listener;
    } else if (this.start_reaction_listener === onOff) {
      return;
    } else {
      this.start_reaction_listener = onOff;
    }

    if (this.start_reaction_listener) {
      var node = this.map.sel.node();
      this.map.sel.on('click.start_reaction', function () {
        // TODO fix this hack
        if (_this5.direction_arrow.dragging) return;
        // reload the reaction input
        var coords = {
          x: (0, _d3Selection.mouse)(node)[0],
          y: (0, _d3Selection.mouse)(node)[1]
          // unselect metabolites
        };_this5.map.deselect_nodes();
        _this5.map.deselect_text_labels();
        // reload the reaction input
        var hasModel = _this5.reload(null, coords, true);
        if (hasModel) {
          // show the dropdown
          _this5.showDropdown(coords);
        }
        // generate the target symbol
        _this5.showTarget(_this5.map, coords);
      });
      this.map.sel.style('cursor', 'pointer');
    } else {
      this.map.sel.on('click.start_reaction', null);
      this.map.sel.style('cursor', null);
      this.hideTarget();
    }
  };

  BuildInput.prototype.hideTarget = function hideTarget() {
    if (this.target_coords) {
      this.map.sel.selectAll('.start-reaction-target').remove();
    }
    this.target_coords = null;
  };

  BuildInput.prototype.showTarget = function showTarget(map, coords) {
    var s = map.sel.selectAll('.start-reaction-target').data([12, 5]);
    s.enter().append('circle').classed('start-reaction-target', true).attr('r', function (d) {
      return d;
    }).style('stroke-width', 4).merge(s).style('visibility', 'visible').attr('transform', 'translate(' + coords.x + ',' + coords.y + ')');
    this.target_coords = coords;
  };

  return BuildInput;
}();

exports.default = BuildInput;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _utils = __webpack_require__(4);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

module.exports = function (container, config) {
    var thisDocument = utils.get_document(container);
    var thisWindow = utils.get_window(container);

    config = config || {};
    config.fontSize = config.fontSize || '13px';
    config.fontFamily = config.fontFamily || 'sans-serif';
    config.promptInnerHTML = config.promptInnerHTML || '';
    config.color = config.color || '#333';
    config.hintColor = config.hintColor || '#aaa';
    config.backgroundColor = config.backgroundColor || '#fff';
    config.dropDownBorderColor = config.dropDownBorderColor || '#aaa';
    config.dropDownZIndex = config.dropDownZIndex || '100'; // to ensure we are in front of everybody
    config.dropDownOnHoverBackgroundColor = config.dropDownOnHoverBackgroundColor || '#ddd';

    var txtInput = thisDocument.createElement('input');
    txtInput.type = 'text';
    txtInput.spellcheck = false;
    txtInput.style.fontSize = config.fontSize;
    txtInput.style.fontFamily = config.fontFamily;
    txtInput.style.color = config.color;
    txtInput.style.backgroundColor = config.backgroundColor;
    txtInput.style.width = '100%';
    txtInput.style.outline = '0';
    txtInput.style.border = '0';
    txtInput.style.margin = '0';
    txtInput.style.padding = '0';

    var txtHint = txtInput.cloneNode();
    txtHint.disabled = '';
    txtHint.style.position = 'absolute';
    txtHint.style.top = '0';
    txtHint.style.left = '0';
    txtHint.style.borderColor = 'transparent';
    txtHint.style.boxShadow = 'none';
    txtHint.style.color = config.hintColor;

    txtInput.style.backgroundColor = 'transparent';
    txtInput.style.verticalAlign = 'top';
    txtInput.style.position = 'relative';

    var wrapper = thisDocument.createElement('div');
    wrapper.style.position = 'relative';
    wrapper.style.outline = '0';
    wrapper.style.border = '0';
    wrapper.style.margin = '0';
    wrapper.style.padding = '0';

    var prompt = thisDocument.createElement('div');
    prompt.style.position = 'absolute';
    prompt.style.outline = '0';
    prompt.style.margin = '0';
    prompt.style.padding = '0';
    prompt.style.border = '0';
    prompt.style.fontSize = config.fontSize;
    prompt.style.fontFamily = config.fontFamily;
    prompt.style.color = config.color;
    prompt.style.backgroundColor = config.backgroundColor;
    prompt.style.top = '0';
    prompt.style.left = '0';
    prompt.style.overflow = 'hidden';
    prompt.innerHTML = config.promptInnerHTML;
    prompt.style.background = 'transparent';
    if (thisDocument.body === undefined) {
        throw 'thisDocument.body is undefined. The library was wired up incorrectly.';
    }
    thisDocument.body.appendChild(prompt);
    var w = prompt.getBoundingClientRect().right; // works out the width of the prompt.
    wrapper.appendChild(prompt);
    prompt.style.visibility = 'visible';
    prompt.style.left = '-' + w + 'px';
    wrapper.style.marginLeft = w + 'px';

    wrapper.appendChild(txtHint);
    wrapper.appendChild(txtInput);

    var dropDown = thisDocument.createElement('div');
    dropDown.style.position = 'absolute';
    dropDown.style.visibility = 'hidden';
    dropDown.style.outline = '0';
    dropDown.style.margin = '0';
    dropDown.style.padding = '0';
    dropDown.style.textAlign = 'left';
    dropDown.style.fontSize = config.fontSize;
    dropDown.style.fontFamily = config.fontFamily;
    dropDown.style.backgroundColor = config.backgroundColor;
    dropDown.style.zIndex = config.dropDownZIndex;
    dropDown.style.cursor = 'default';
    dropDown.style.borderStyle = 'solid';
    dropDown.style.borderWidth = '1px';
    dropDown.style.borderColor = config.dropDownBorderColor;
    dropDown.style.overflowX = 'hidden';
    dropDown.style.whiteSpace = 'pre';
    dropDown.style.overflowY = 'scroll';

    var createDropDownController = function createDropDownController(elem) {
        var rows = [];
        var ix = 0;
        var oldIndex = -1;
        var current_row = null;

        var onMouseOver = function onMouseOver() {
            this.style.outline = '1px solid #ddd';
        };
        var onMouseOut = function onMouseOut() {
            this.style.outline = '0';
        };
        var onDblClick = function onDblClick(e) {
            e.preventDefault();
            p.onmouseselection(this.id);
        };

        var p = {
            hide: function hide() {
                elem.style.visibility = 'hidden';
            },
            refresh: function refresh(token, options) {
                elem.style.visibility = 'hidden';
                ix = 0;
                elem.innerHTML = '';
                var vph = thisWindow.innerHeight || thisDocument.documentElement.clientHeight;
                var rect = elem.parentNode.getBoundingClientRect();
                var distanceToTop = rect.top - 6; // heuristic give 6px
                var distanceToBottom = vph - rect.bottom - 6; // distance from the browser border.

                rows = [];
                for (var i = 0; i < options.length; i++) {
                    // ignore case
                    var found = options[i].matches.filter(function (match) {
                        return match.toLowerCase().indexOf(token.toLowerCase()) == 0;
                    });
                    if (found.length == 0) continue;
                    var divRow = thisDocument.createElement('div');
                    divRow.style.color = config.color;
                    divRow.onmouseover = onMouseOver;
                    divRow.onmouseout = onMouseOut;
                    // prevent selection for double click
                    divRow.onmousedown = function (e) {
                        e.preventDefault();
                    };
                    divRow.ondblclick = onDblClick;
                    divRow.__hint = found[0];
                    divRow.id = options[i].id;
                    divRow.innerHTML = options[i].html;
                    rows.push(divRow);
                    elem.appendChild(divRow);
                    // limit results and add a note at the buttom
                    if (rows.length >= rs.display_limit) {
                        var divRow2 = thisDocument.createElement('div');
                        divRow2.innerHTML = ' ' + (options.length - rows.length) + ' more';
                        rows.push(divRow2);
                        elem.appendChild(divRow2);
                        break;
                    }
                }
                if (rows.length === 0) {
                    return; // nothing to show.
                }
                p.highlight(0);

                // Heuristic (only when the distance to the to top is 4
                // times more than distance to the bottom
                if (distanceToTop > distanceToBottom * 3) {
                    // we display the dropDown on the top of the input text
                    elem.style.maxHeight = distanceToTop + 'px';
                    elem.style.top = '';
                    elem.style.bottom = '100%';
                } else {
                    elem.style.top = '100%';
                    elem.style.bottom = '';
                    elem.style.maxHeight = distanceToBottom + 'px';
                }
                elem.style.visibility = 'visible';
            },
            highlight: function highlight(index) {
                if (oldIndex != -1 && rows[oldIndex]) {
                    rows[oldIndex].style.backgroundColor = config.backgroundColor;
                }
                rows[index].style.backgroundColor = config.dropDownOnHoverBackgroundColor; // <-- should be config
                oldIndex = index;
                current_row = rows[index];
            },
            // moves the selection either up or down (unless it's not
            // possible) step is either +1 or -1.
            move: function move(step) {
                // nothing to move if there is no dropDown. (this happens if
                // the user hits escape and then down or up)
                if (elem.style.visibility === 'hidden') return '';
                // No circular scrolling
                if (ix + step === -1 || ix + step === rows.length) return rows[ix].__hint;
                ix += step;
                p.highlight(ix);
                return rows[ix].__hint;
            },
            onmouseselection: function onmouseselection() {},
            get_current_row: function get_current_row() {
                return current_row;
            }
        };
        return p;
    };

    var dropDownController = createDropDownController(dropDown);

    dropDownController.onmouseselection = function (id) {
        rs.onEnter(id);
        rs.input.focus();
    };

    wrapper.appendChild(dropDown);
    container.appendChild(wrapper);

    var spacer,
    // This will contain the leftSide part of the textfield (the bit that
    // was already autocompleted)
    leftSide;

    function calculateWidthForText(text) {
        if (spacer === undefined) {
            // on first call only.
            spacer = thisDocument.createElement('span');
            spacer.style.visibility = 'hidden';
            spacer.style.position = 'fixed';
            spacer.style.outline = '0';
            spacer.style.margin = '0';
            spacer.style.padding = '0';
            spacer.style.border = '0';
            spacer.style.left = '0';
            spacer.style.whiteSpace = 'pre';
            spacer.style.fontSize = config.fontSize;
            spacer.style.fontFamily = config.fontFamily;
            spacer.style.fontWeight = 'normal';
            thisDocument.body.appendChild(spacer);
        }

        // Used to encode an HTML string into a plain text.
        // taken from http://stackoverflow.com/questions/1219860/javascript-jquery-html-encoding
        spacer.innerHTML = String(text).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return spacer.getBoundingClientRect().right;
    }

    var rs = {
        get_hint: function get_hint(x) {
            return x;
        },
        display_limit: 1000,
        onArrowDown: function onArrowDown() {}, // defaults to no action.
        onArrowUp: function onArrowUp() {}, // defaults to no action.
        onEnter: function onEnter() {}, // defaults to no action.
        onTab: function onTab() {}, // defaults to no action.
        onChange: function onChange() {
            rs.repaint();
        }, // defaults to repainting.
        startFrom: 0,
        options: [],

        // Only to allow easy access to the HTML elements to the final user
        // (possibly for minor customizations)
        wrapper: wrapper,
        input: txtInput,
        hint: txtHint,
        dropDown: dropDown,

        prompt: prompt,
        setText: function setText(text) {
            txtHint.value = text;
            txtInput.value = text;
        },
        getText: function getText() {
            return txtInput.value;
        },
        hideDropDown: function hideDropDown() {
            dropDownController.hide();
        },
        repaint: function repaint() {
            var text = txtInput.value;
            var startFrom = rs.startFrom;
            var options = rs.options;
            var optionsLength = options.length;

            // breaking text in leftSide and token.
            var token = text.substring(startFrom);
            leftSide = text.substring(0, startFrom);

            // updating the hint.
            txtHint.value = '';
            for (var i = 0; i < optionsLength; i++) {
                var found = options[i].matches.filter(function (match) {
                    return match.toLowerCase().indexOf(token.toLowerCase()) == 0;
                });
                if (found.length == 0) continue;
                txtHint.value = rs.get_hint(found[0]);
                break;
            }

            // moving the dropDown and refreshing it.
            dropDown.style.left = calculateWidthForText(leftSide) + 'px';
            dropDownController.refresh(token, rs.options);
        }
    };

    var registerOnTextChangeOldValue;

    // Register a callback function to detect changes to the content of the
    // input-type-text.  Those changes are typically followed by user's
    // action: a key-stroke event but sometimes it might be a mouse click.
    var registerOnTextChange = function registerOnTextChange(txt, callback) {
        registerOnTextChangeOldValue = txt.value;
        var handler = function handler() {
            var value = txt.value;
            if (registerOnTextChangeOldValue !== value) {
                registerOnTextChangeOldValue = value;
                callback(value);
            }
        };

        // For user's actions, we listen to both input events and key up events
        // It appears that input events are not enough so we defensively listen to key up events too.
        // source: http://help.dottoro.com/ljhxklln.php
        //
        // The cost of listening to three sources should be negligible as the handler will invoke callback function
        // only if the text.value was effectively changed.
        txt.addEventListener("input", handler, false);
        txt.addEventListener('keyup', handler, false);
        txt.addEventListener('change', handler, false);
    };

    registerOnTextChange(txtInput, function (text) {
        // note the function needs to be wrapped as API-users will define their onChange
        rs.onChange(text);
        rs.repaint();
    });

    var keyDownHandler = function keyDownHandler(e) {
        e = e || thisWindow.event;
        var keyCode = e.keyCode;

        if (keyCode == 33) {
            return;
        } // page up (do nothing)
        if (keyCode == 34) {
            return;
        } // page down (do nothing);

        // right,  end, tab  (autocomplete triggered)
        if (keyCode == 39 || keyCode == 35 || keyCode == 9) {
            // for tabs we need to ensure that we override the default
            // behaviour: move to the next focusable HTML-element
            if (keyCode == 9) {
                e.preventDefault();
                e.stopPropagation();
                if (txtHint.value.length == 0) {
                    // tab was called with no action.
                    rs.onTab();
                }
            }
            // if there is a hint
            if (txtHint.value.length > 0) {
                txtInput.value = txtHint.value;
                var hasTextChanged = registerOnTextChangeOldValue != txtInput.value;
                // avoid dropDown to appear again
                registerOnTextChangeOldValue = txtInput.value;
                // for example imagine the array contains the following
                // words: bee, beef, beetroot. User has hit enter to get
                // 'bee' it would be prompted with the dropDown again (as
                // beef and beetroot also match)
                if (hasTextChanged) {
                    // force it.
                    rs.onChange(txtInput.value);
                }
            }
            return;
        }

        if (keyCode == 13) {
            // enter
            // get current
            var id = dropDownController.get_current_row().id;
            rs.onEnter(id);
            return;
        }

        if (keyCode == 40) {
            // down
            var m = dropDownController.move(+1);
            if (m == '') {
                rs.onArrowDown();
            }
            txtHint.value = rs.get_hint(m);
            return;
        }

        if (keyCode == 38) {
            // up
            var m = dropDownController.move(-1);
            if (m == '') {
                rs.onArrowUp();
            }
            txtHint.value = rs.get_hint(m);
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        // it's important to reset the txtHint on key down. Think: user
        // presses a letter (e.g. 'x') and never releases. You get
        // (xxxxxxxxxxxxxxxxx) and you would see still the hint. Reset the
        // txtHint. (it might be updated onKeyUp).
        txtHint.value = '';
    };

    txtInput.addEventListener("keydown", keyDownHandler, false);
    return rs;
}; /**
    * @license
    *
    * complete.ly 1.0.0
    * MIT Licensing
    * Copyright (c) 2013 Lorenzo Puccetti
    *
    * This Software shall be used for doing good things, not bad things.
    *
    *
    * Modified by Zachary King (c) 2014.
    *
    **/

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(4);

var utils = _interopRequireWildcard(_utils);

var _d3Drag = __webpack_require__(22);

var _d3Selection = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * DirectionArrow. A constructor for an arrow that can be rotated and dragged,
 * and supplies its direction.
 * @param {D3 Selection} sel - The sel to render the arrow in.
 */
var DirectionArrow = function () {
  function DirectionArrow(sel) {
    _classCallCheck(this, DirectionArrow);

    this.arrowContainer = sel.append('g').attr('id', 'direction-arrow-container').attr('transform', 'translate(0,0)rotate(0)');

    this.arrow = this.arrowContainer.append('path').classed('direction-arrow', true).attr('d', 'M0 -5 L0 5 L20 5 L20 10 L30 0 L20 -10 L20 -5 Z').style('visibility', 'hidden').attr('transform', 'translate(30,0)scale(2.5)');

    this.sel = sel;
    this.center = { x: 0, y: 0 };

    this._setupDrag();
    this.dragging = false;

    this.isVisible = false;
    this.show();
  }

  /**
   * Move the arrow to coords.
   */


  DirectionArrow.prototype.setLocation = function setLocation(coords) {
    this.center = coords;
    var transform = utils.d3_transform_catch(this.arrowContainer.attr('transform'));
    this.arrowContainer.attr('transform', 'translate(' + coords.x + ',' + coords.y + ')rotate(' + transform.rotate + ')');
  };

  /**
   * Rotate the arrow to rotation.
   */


  DirectionArrow.prototype.setRotation = function setRotation(rotation) {
    var transform = utils.d3_transform_catch(this.arrowContainer.attr('transform'));
    this.arrowContainer.attr('transform', 'translate(' + transform.translate + ')rotate(' + rotation + ')');
  };

  /**
   * Displace the arrow rotation by a set amount.
   */


  DirectionArrow.prototype.displaceRotation = function displaceRotation(dRotation) {
    var transform = utils.d3_transform_catch(this.arrowContainer.attr('transform'));
    this.arrowContainer.attr('transform', 'translate(' + transform.translate + ')' + 'rotate(' + (transform.rotate + dRotation) + ')');
  };

  /**
   * Returns the arrow rotation.
   */


  DirectionArrow.prototype.getRotation = function getRotation() {
    return utils.d3_transform_catch(this.arrowContainer.attr('transform')).rotate;
  };

  DirectionArrow.prototype.toggle = function toggle(onOff) {
    if (onOff === undefined) this.isVisible = !this.isVisible;else this.isVisible = onOff;
    this.arrow.style('visibility', this.isVisible ? 'visible' : 'hidden');
  };

  DirectionArrow.prototype.show = function show() {
    this.toggle(true);
  };

  DirectionArrow.prototype.hide = function hide() {
    this.toggle(false);
  };

  DirectionArrow.prototype.right = function right() {
    this.setRotation(0);
  };

  DirectionArrow.prototype.down = function down() {
    this.setRotation(90);
  };

  DirectionArrow.prototype.left = function left() {
    this.setRotation(180);
  };

  DirectionArrow.prototype.up = function up() {
    this.setRotation(270);
  };

  DirectionArrow.prototype._setupDrag = function _setupDrag() {
    var _this = this;

    var drag = (0, _d3Drag.drag)().on('start', function (d) {
      // silence other listeners
      _d3Selection.event.sourceEvent.stopPropagation();
      _this.dragging = true;
    }).on('drag', function (d) {
      var displacement = {
        x: _d3Selection.event.dx,
        y: _d3Selection.event.dy
      };
      var location = {
        x: (0, _d3Selection.mouse)(_this.sel.node())[0],
        y: (0, _d3Selection.mouse)(_this.sel.node())[1]
      };
      var dAngle = utils.angle_for_event(displacement, location, _this.center);
      _this.displaceRotation(utils.to_degrees(dAngle));
    }).on('end', function (d) {
      setTimeout(function () {
        _this.dragging = false;
      }, 200);
    });
    this.arrowContainer.call(drag);
  };

  return DirectionArrow;
}();

exports.default = DirectionArrow;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Draw. Manages creating, updating, and removing objects during d3 data
 * binding.
 *
 * Arguments
 * ---------
 *
 * behavior: An escher.Behavior object.
 * settings: An escher.Settings object.
 *
 * Callbacks
 * ---------
 *
 * draw.callback_manager.run('create_membrane', draw, enter_selection)
 * draw.callback_manager.run('update_membrane', draw, update_selection)
 * draw.callback_manager.run('create_reaction', draw, enter_selection)
 * draw.callback_manager.run('update_reaction', draw, update_selection)
 * draw.callback_manager.run('create_reaction_label', draw, enter_selection)
 * draw.callback_manager.run('update_reaction_label', draw, update_selection)
 * draw.callback_manager.run('create_segment', draw, enter_selection)
 * draw.callback_manager.run('update_segment', draw, update_selection)
 * draw.callback_manager.run('create_bezier', draw, enter_selection)
 * draw.callback_manager.run('update_bezier', draw, update_selection)
 * draw.callback_manager.run('create_node', draw, enter_selection)
 * draw.callback_manager.run('update_node', draw, update_selection)
 * draw.callback_manager.run('create_text_label', draw, enter_selection)
 * draw.callback_manager.run('update_text_label', draw, update_selection)
 *
 */

var utils = __webpack_require__(4);
var dataStyles = __webpack_require__(20);
var CallbackManager = __webpack_require__(21).default;
var d3_format = __webpack_require__(7).format;

var Draw = utils.make_class();
// instance methods
Draw.prototype = {
  init: init,
  create_reaction: create_reaction,
  update_reaction: update_reaction,
  create_bezier: create_bezier,
  update_bezier: update_bezier,
  create_node: create_node,
  update_node: update_node,
  create_text_label: create_text_label,
  update_text_label: update_text_label,
  create_membrane: create_membrane,
  update_membrane: update_membrane,
  create_reaction_label: create_reaction_label,
  update_reaction_label: update_reaction_label,
  create_segment: create_segment,
  update_segment: update_segment
};
module.exports = Draw;

function init(behavior, settings, map) {
  this.behavior = behavior;
  this.settings = settings;
  this.map = map;
  this.callback_manager = new CallbackManager();
}

/**
 * Create membranes in the enter_selection.
 * @param {} enter_selection - The D3 enter selection.
 * @returns {} The selection of the new nodes.
 */
function create_membrane(enter_selection) {
  var rect = enter_selection.append('rect').attr('class', 'membrane');

  this.callback_manager.run('create_membrane', this, enter_selection);

  return rect;
}

/**
 * Update the membrane
 */
function update_membrane(update_selection) {
  update_selection.attr('width', function (d) {
    return d.width;
  }).attr('height', function (d) {
    return d.height;
  }).attr('transform', function (d) {
    return 'translate(' + d.x + ',' + d.y + ')';
  }).style('stroke-width', function (d) {
    return 10;
  }).attr('rx', function (d) {
    return 20;
  }).attr('ry', function (d) {
    return 20;
  });

  this.callback_manager.run('update_membrane', this, update_selection);
}

/**
 * Create reactions in the enter_selection.
 * @param {} enter_selection - The D3 enter selection.
 * @returns {} The selection of the new nodes.
 */
function create_reaction(enter_selection) {
  // attributes for new reaction group
  var group = enter_selection.append('g').attr('id', function (d) {
    return 'r' + d.reaction_id;
  }).attr('class', 'reaction');
  this.create_reaction_label(group);

  this.callback_manager.run('create_reaction', this, enter_selection);

  return group;
}

/**
 * Run on the update selection for reactions.
 * update_selection: The D3.js update selection.
 * scale: A Scale object.
 * cobra_model: A CobraModel object.
 * drawn_nodes: The nodes object (e.g. Map.nodes).
 * defs: The defs object generated by utils.setup_defs() (e.g. Map.defs).
 * has_data_on_reactions: Boolean to determine whether data needs to be drawn.
 */
function update_reaction(update_selection, scale, cobra_model, drawn_nodes, defs, has_data_on_reactions) {
  // Update reaction label
  update_selection.select('.reaction-label-group').call(function (sel) {
    return this.update_reaction_label(sel, has_data_on_reactions);
  }.bind(this));

  // draw segments
  utils.draw_a_nested_object(update_selection, '.segment-group', 'segments', 'segment_id', this.create_segment.bind(this), function (sel) {
    return this.update_segment(sel, scale, cobra_model, drawn_nodes, defs, has_data_on_reactions);
  }.bind(this), function (sel) {
    sel.remove();
  });

  // run the callback
  this.callback_manager.run('update_reaction', this, update_selection);
}

/**
 * Draw reaction labels in the enter selection.
 * @param {} enter_selection - The D3 enter selection.
 * @returns {} The selection of the new nodes.
 */
function create_reaction_label(enter_selection, tool) {
  var group = enter_selection.append('g').attr('class', 'reaction-label-group');
  group.append('text').attr('class', 'reaction-label label');
  group.append('g').attr('class', 'all-genes-label-group');

  this.callback_manager.run('create_reaction_label', this, enter_selection);

  return group;
}

/**
 * Run on the update selection for reaction labels.
 * @param {D3 Selection} update_selection - The D3.js update selection.
 * @param {Boolean} has_data_on_reactions - Whether data needs to be drawn.
 */
function update_reaction_label(update_selection, has_data_on_reactions) {
  var decimal_format = d3_format('.4g');
  var identifiers_on_map = this.settings.get('identifiers_on_map');
  var reaction_data_styles = this.settings.get('reaction_styles');
  var show_gene_reaction_rules = this.settings.get('show_gene_reaction_rules');
  var hide_all_labels = this.settings.get('hide_all_labels');
  var gene_font_size = this.settings.get('gene_font_size');
  var reactionLabelMouseover = this.behavior.reactionLabelMouseover;
  var reactionLabelMouseout = this.behavior.reactionLabelMouseout;
  var reactionLabelTouch = this.behavior.reactionLabelTouch;
  var geneLabelMouseover = this.behavior.geneLabelMouseover;
  var geneLabelMouseout = this.behavior.geneLabelMouseout;
  var geneLabelTouch = this.behavior.geneLabelTouch;

  // label location
  update_selection.attr('transform', function (d) {
    return 'translate(' + d.label_x + ',' + d.label_y + ')';
  }).call(this.behavior.turnOffDrag).call(this.behavior.reactionLabelDrag);

  // update label visibility
  var label = update_selection.select('.reaction-label').attr('visibility', hide_all_labels ? 'hidden' : 'visible');

  if (!hide_all_labels) {
    label.text(function (d) {
      var t = d[identifiers_on_map];
      if (has_data_on_reactions && reaction_data_styles.indexOf('text') !== -1) {
        t += ' ' + d.data_string;
      }
      return t;
    }).on('mouseover', reactionLabelMouseover).on('mouseout', reactionLabelMouseout).on('touchend', reactionLabelTouch);
  }

  var add_gene_height = function add_gene_height(y, i) {
    return y + gene_font_size * 1.5 * (i + 1);
  };

  // gene label
  var all_genes_g = update_selection.select('.all-genes-label-group').selectAll('.gene-label-group').data(function (d) {
    var show_gene_string = 'gene_string' in d && d.gene_string !== null && show_gene_reaction_rules && !hide_all_labels && reaction_data_styles.indexOf('text') !== -1;
    var show_gene_reaction_rule = 'gene_reaction_rule' in d && d.gene_reaction_rule !== null && show_gene_reaction_rules && !hide_all_labels;
    if (show_gene_string) {
      // TODO do we ever use gene_string?
      console.warn('Showing gene_string. See TODO in source.');
      return d.gene_string;
    } else if (show_gene_reaction_rule) {
      // make the gene string with no data
      var sd = dataStyles.gene_string_for_data(d.gene_reaction_rule, null, d.genes, null, identifiers_on_map, null);
      // add coords for tooltip
      sd.forEach(function (td, i) {
        td.label_x = d.label_x;
        td.label_y = add_gene_height(d.label_y, i);
      });
      return sd;
    } else {
      return [];
    }
  });

  // enter
  var gene_g = all_genes_g.enter().append('g').attr('class', 'gene-label-group');
  gene_g.append('text').attr('class', 'gene-label').style('font-size', gene_font_size + 'px');

  // update
  var gene_update = gene_g.merge(all_genes_g);
  gene_update.attr('transform', function (d, i) {
    return 'translate(0, ' + add_gene_height(0, i) + ')';
  });
  // update text
  gene_update.select('text').text(function (d) {
    return d.text;
  }).on('mouseover', geneLabelMouseover).on('mouseout', geneLabelMouseout).on('touchend', geneLabelTouch);

  // exit
  all_genes_g.exit().remove();

  this.callback_manager.run('update_reaction_label', this, update_selection);
}

/**
 * Create segments in the enter_selection.
 * @param {} enter_selection - The D3 enter selection.
 * @returns {} The selection of the new nodes.
 */
function create_segment(enter_selection) {
  // create segments
  var g = enter_selection.append('g').attr('class', 'segment-group').attr('id', function (d) {
    return 's' + d.segment_id;
  });

  // create reaction arrow
  g.append('path').attr('class', 'segment');

  g.append('g').attr('class', 'arrowheads');

  g.append('g').attr('class', 'stoichiometry-labels');

  this.callback_manager.run('create_segment', this, enter_selection);

  return g;
}

/**
 * Update segments in update selection.
 * @param {} -
 * @param {} -
 * @param {} -
 * @param {} -
 * @param {} -
 * @param {} -
 * @return {}
 */
function update_segment(update_selection, scale, cobra_model, drawn_nodes, defs, has_data_on_reactions) {
  var reaction_data_styles = this.settings.get('reaction_styles');
  var should_size = has_data_on_reactions && reaction_data_styles.indexOf('size') !== -1;
  var should_color = has_data_on_reactions && reaction_data_styles.indexOf('color') !== -1;
  var no_data_size = this.settings.get('reaction_no_data_size');
  var no_data_color = this.settings.get('reaction_no_data_color');

  // update segment attributes
  var highlight_missing = this.settings.get('highlight_missing');
  var hide_secondary_metabolites = this.settings.get('hide_secondary_metabolites');
  var primary_r = this.settings.get('primary_metabolite_radius');
  var secondary_r = this.settings.get('secondary_metabolite_radius');

  var objectMouseover = this.behavior.reactionObjectMouseover;
  var objectMouseout = this.behavior.reactionObjectMouseout;

  var get_arrow_size = function get_arrow_size(data, should_size) {
    var width = 20;
    var height = 13;
    if (should_size) {
      height = data === null ? no_data_size : scale.reaction_size(data);
      // check for nan
      if (isNaN(height)) {
        height = no_data_size;
      }
      width = height * 2;
    }
    return { width: width, height: height };
  };
  var get_disp = function get_disp(arrow_size, reversibility, coefficient, node_is_primary) {
    var arrow_height = reversibility || coefficient > 0 ? arrow_size.height : 0;
    var r = node_is_primary ? primary_r : secondary_r;
    return r + arrow_height + 10;
  };

  // update arrows
  update_selection.selectAll('.segment').datum(function () {
    // Concatenate the segment data with the reaction data from its parent node
    return Object.assign({}, this.parentNode.__data__, this.parentNode.parentNode.__data__);
  }).style('visibility', function (d) {
    var start = drawn_nodes[d.from_node_id];
    var end = drawn_nodes[d.to_node_id];
    if (hide_secondary_metabolites && (end['node_type'] === 'metabolite' && !end.node_is_primary || start['node_type'] === 'metabolite' && !start.node_is_primary)) {
      return 'hidden';
    }
    return null;
  }).attr('d', function (d) {
    if (d.from_node_id === null || d.to_node_id === null) {
      return null;
    }
    var start = drawn_nodes[d.from_node_id];
    var end = drawn_nodes[d.to_node_id];
    var b1 = d.b1;
    var b2 = d.b2;
    // if metabolite, then displace the arrow
    if (start['node_type'] === 'metabolite') {
      var arrow_size = get_arrow_size(d.data, should_size);
      var disp = get_disp(arrow_size, d.reversibility, d.from_node_coefficient, start.node_is_primary);
      var direction = b1 === null ? end : b1;
      start = displacedCoords(disp, start, direction, 'start');
    }
    if (end['node_type'] == 'metabolite') {
      var arrow_size = get_arrow_size(d.data, should_size);
      var disp = get_disp(arrow_size, d.reversibility, d.to_node_coefficient, end.node_is_primary);
      var direction = b2 === null ? start : b2;
      end = displacedCoords(disp, direction, end, 'end');
    }
    var curve = 'M' + start.x + ',' + start.y + ' ';
    if (b1 !== null && b2 !== null) {
      curve += 'C' + b1.x + ',' + b1.y + ' ' + b2.x + ',' + b2.y + ' ';
    }
    curve += end.x + ',' + end.y;
    return curve;
  }).style('stroke', function (d) {
    var reaction_id = this.parentNode.parentNode.__data__.bigg_id;
    var show_missing = highlight_missing && cobra_model !== null && !(reaction_id in cobra_model.reactions);
    if (show_missing) {
      return 'red';
    }
    if (should_color) {
      var f = d.data;
      return f === null ? no_data_color : "#C8C8C8";
    }
    return null;
  }).style('stroke-width', function (d) {
    if (should_size) {
      var f = d.data;
      return f === null ? no_data_size : scale.reaction_size(f);
    } else {
      return null;
    }
  }).attr('pointer-events', 'visibleStroke').on('mouseover', objectMouseover).on('mouseout', objectMouseout);

  // new arrowheads
  var arrowheads = update_selection.select('.arrowheads').selectAll('.arrowhead').data(function (d) {
    var arrowheads = [];
    var start = drawn_nodes[d.from_node_id];
    var b1 = d.b1;
    var end = drawn_nodes[d.to_node_id];
    var b2 = d.b2;
    // hide_secondary_metabolites option
    if (hide_secondary_metabolites && (end['node_type'] === 'metabolite' && !end.node_is_primary || start['node_type'] === 'metabolite' && !start.node_is_primary)) {
      return arrowheads;
    }

    if (start.node_type === 'metabolite' && (d.reversibility || d.from_node_coefficient > 0)) {
      var arrow_size = get_arrow_size(d.data, should_size);
      var disp = get_disp(arrow_size, d.reversibility, d.from_node_coefficient, start.node_is_primary);
      var direction = b1 === null ? end : b1;
      var rotation = utils.to_degrees(utils.get_angle([start, direction])) + 90;
      var loc = displacedCoords(disp, start, direction, 'start');
      arrowheads.push({
        data: d.data,
        x: loc.x,
        y: loc.y,
        size: arrow_size,
        rotation: rotation,
        show_arrowhead_flux: d.from_node_coefficient < 0 === d.reverse_flux || d.data === 0
      });
    }

    if (end.node_type === 'metabolite' && (d.reversibility || d.to_node_coefficient > 0)) {
      var arrow_size = get_arrow_size(d.data, should_size);
      var disp = get_disp(arrow_size, d.reversibility, d.to_node_coefficient, end.node_is_primary);
      var direction = b2 === null ? start : b2;
      var rotation = utils.to_degrees(utils.get_angle([end, direction])) + 90;
      var loc = displacedCoords(disp, direction, end, 'end');
      arrowheads.push({
        data: d.data,
        x: loc.x,
        y: loc.y,
        size: arrow_size,
        rotation: rotation,
        show_arrowhead_flux: d.to_node_coefficient < 0 === d.reverse_flux || d.data === 0
      });
    }

    if (d.unconnected_segment_with_arrow) {
      var arrow_size = get_arrow_size(d.data, should_size);
      var direction = end;
      var rotation = utils.to_degrees(utils.get_angle([start, direction])) + 90;
      arrowheads.push({
        data: d.data,
        x: start.x,
        y: start.y,
        size: arrow_size,
        rotation: rotation,
        show_arrowhead_flux: d.to_node_coefficient < 0 === d.reverse_flux || d.data === 0
      });
    }

    return arrowheads;
  });
  arrowheads.enter().append('path').classed('arrowhead', true)
  // update arrowheads
  .merge(arrowheads).attr('d', function (d) {
    return 'M' + [-d.size.width / 2, 0] + ' L' + [0, d.size.height] + ' L' + [d.size.width / 2, 0] + ' Z';
  }).attr('transform', function (d) {
    return 'translate(' + d.x + ',' + d.y + ')rotate(' + d.rotation + ')';
  }).style('fill', function (d) {
    if (should_color) {
      if (d.show_arrowhead_flux) {
        // show the flux
        var f = d.data;
        return f === null ? no_data_color : "#C8C8C8";
      } else {
        // if the arrowhead is not filled because it is reversed
        return '#FFFFFF';
      }
    }
    // default fill color
    return null;
  }).style('stroke', function (d) {
    if (should_color) {
      // show the flux color in the stroke whether or not the fill is present
      var f = d.data;
      return f === null ? no_data_color : "#C8C8C8";
    }
    // default stroke color
    return null;
  });
  // remove
  arrowheads.exit().remove();

  // new stoichiometry labels
  var stoichiometry_labels = update_selection.select('.stoichiometry-labels').selectAll('.stoichiometry-label').data(function (d) {
    var labels = [];
    var start = drawn_nodes[d.from_node_id];
    var b1 = d.b1;
    var end = drawn_nodes[d.to_node_id];
    var b2 = d.b2;
    var disp_factor = 1.5;

    // hide_secondary_metabolites option
    if (hide_secondary_metabolites && (end['node_type'] == 'metabolite' && !end.node_is_primary || start['node_type'] == 'metabolite' && !start.node_is_primary)) {
      return labels;
    }

    if (start.node_type === 'metabolite' && Math.abs(d.from_node_coefficient) != 1) {
      var arrow_size = get_arrow_size(d.data, should_size);
      var disp = disp_factor * get_disp(arrow_size, false, 0, end.node_is_primary);
      var direction = b1 === null ? end : b1;
      direction = utils.c_plus_c(direction, utils.rotate_coords(direction, 0.5, start));
      var loc = displacedCoords(disp, start, direction, 'start');
      loc = utils.c_plus_c(loc, { x: 0, y: 7 });
      labels.push({
        coefficient: Math.abs(d.from_node_coefficient),
        x: loc.x,
        y: loc.y,
        data: d.data
      });
    }

    if (end.node_type === 'metabolite' && Math.abs(d.to_node_coefficient) !== 1) {
      var arrow_size = get_arrow_size(d.data, should_size);
      var disp = disp_factor * get_disp(arrow_size, false, 0, end.node_is_primary);
      var direction = b2 === null ? start : b2;
      direction = utils.c_plus_c(direction, utils.rotate_coords(direction, 0.5, end));
      var loc = displacedCoords(disp, direction, end, 'end');
      loc = utils.c_plus_c(loc, { x: 0, y: 7 });
      labels.push({
        coefficient: Math.abs(d.to_node_coefficient),
        x: loc.x,
        y: loc.y,
        data: d.data
      });
    }
    return labels;
  });

  // add labels
  stoichiometry_labels.enter().append('text').attr('class', 'stoichiometry-label').attr('text-anchor', 'middle')
  // update stoichiometry_labels
  .merge(stoichiometry_labels).attr('transform', function (d) {
    return 'translate(' + d.x + ',' + d.y + ')';
  }).text(function (d) {
    return d.coefficient;
  }).style('fill', function (d) {
    if (should_color) {
      // show the flux color
      var f = d.data;
      return f === null ? no_data_color : "#C8C8C8";
    }
    // default segment color
    return null;
  });

  // remove
  stoichiometry_labels.exit().remove();

  this.callback_manager.run('update_segment', this, update_selection);
}

/**
 * Create beziers in the enter_selection.
 * @param {} enter_selection - The D3 enter selection.
 * @returns {} The selection of the new nodes.
 */
function create_bezier(enter_selection) {
  var g = enter_selection.append('g').attr('id', function (d) {
    return d.bezier_id;
  }).attr('class', function (d) {
    return 'bezier';
  });
  g.append('path').attr('class', 'connect-line');
  g.append('circle').attr('class', function (d) {
    return 'bezier-circle ' + d.bezier;
  }).style('stroke-width', String(1) + 'px').attr('r', String(7) + 'px');

  this.callback_manager.run('create_bezier', this, enter_selection);

  return g;
}

/**
 * Update beziers in update_selection.
 */
function update_bezier(update_selection, show_beziers, drag_behavior, mouseover, mouseout, drawn_nodes, drawn_reactions) {
  var hide_secondary_metabolites = this.settings.get('hide_secondary_metabolites');

  if (!show_beziers) {
    update_selection.attr('visibility', 'hidden');
    return;
  } else {
    update_selection.attr('visibility', 'visible');
  }

  // hide secondary
  update_selection.style('visibility', function (d) {
    var seg_data = drawn_reactions[d.reaction_id].segments[d.segment_id];
    var start = drawn_nodes[seg_data.from_node_id];
    var end = drawn_nodes[seg_data.to_node_id];
    if (hide_secondary_metabolites && (end['node_type'] === 'metabolite' && !end.node_is_primary || start['node_type'] === 'metabolite' && !start.node_is_primary)) {
      return 'hidden';
    }
    return null;
  });

  // Draw bezier points
  update_selection.select('.bezier-circle').call(this.behavior.turnOffDrag).call(drag_behavior).on('mouseover', mouseover).on('mouseout', mouseout).attr('transform', function (d) {
    if (d.x === null || d.y === null) return '';
    return 'translate(' + d.x + ',' + d.y + ')';
  });

  // Update bezier line
  update_selection.select('.connect-line').attr('d', function (d) {
    var segment_d = drawn_reactions[d.reaction_id].segments[d.segment_id];
    var node = d.bezier === 'b1' ? drawn_nodes[segment_d.from_node_id] : drawn_nodes[segment_d.to_node_id];
    if (d.x === null || d.y === null || node.x === null || node.y === null) {
      return '';
    }
    return 'M' + d.x + ', ' + d.y + ' ' + node.x + ',' + node.y;
  });

  this.callback_manager.run('update_bezier', this, update_selection);
}

/**
 * Create nodes in the enter_selection.
 * @param {} enter_selection - The D3 enter selection.
 * @param {} drawn_nodes - The nodes object (e.g. Map.nodes).
 * @param {} drawn_reactions - The reactions object (e.g. Map.reactions).
 * @returns {} The selection of the new nodes.
 */
function create_node(enter_selection, drawn_nodes, drawn_reactions) {
  // create nodes
  var g = enter_selection.append('g').attr('class', 'node').attr('id', function (d) {
    return 'n' + d.node_id;
  });

  // create metabolite circle and label
  g.append('circle').attr('class', function (d) {
    var c = 'node-circle';
    if (d.node_type !== null) c += ' ' + d.node_type + '-circle';
    return c;
  });

  // labels
  var metabolite_groups = g.filter(function (d) {
    return d.node_type === 'metabolite';
  });

  metabolite_groups.append('text').attr('class', 'node-label label');

  this.callback_manager.run('create_node', this, enter_selection);

  return g;
}

/**
 * Run on the update selection for nodes.
 * @param {D3 Selection} update_selection - The D3.js update selection.
 * @param {Scale} scale - A Scale object.
 * @param {Boolean} has_data_on_nodes - Boolean to determine whether data needs to be drawn.
 * @param {Function} mousedown_fn - A function to call on mousedown for a node.
 * @param {Function} click_fn - A function to call on click for a node.
 * @param {Function} mouseover_fn - A function to call on mouseover for a node.
 * @param {Function} mouseout_fn - A function to call on mouseout for a node.
 * @param {D3 Behavior} drag_behavior - The D3.js drag behavior object for the nodes.
 * @param {D3 Behavior} label_drag_behavior - The D3.js drag behavior object for the node labels.
 */
function update_node(update_selection, scale, has_data_on_nodes, mousedown_fn, click_fn, mouseover_fn, mouseout_fn, drag_behavior, label_drag_behavior) {
  // update circle and label location
  var hide_secondary_metabolites = this.settings.get('hide_secondary_metabolites');
  var primary_r = this.settings.get('primary_metabolite_radius');
  var secondary_r = this.settings.get('secondary_metabolite_radius');
  var marker_r = this.settings.get('marker_radius');
  var hide_all_labels = this.settings.get('hide_all_labels');
  var identifiers_on_map = this.settings.get('identifiers_on_map');
  var metabolite_data_styles = this.settings.get('metabolite_styles');
  var no_data_style = { color: this.settings.get('metabolite_no_data_color'),
    size: this.settings.get('metabolite_no_data_size') };
  var labelMouseover = this.behavior.nodeLabelMouseover;
  var labelMouseout = this.behavior.nodeLabelMouseout;
  var labelTouch = this.behavior.nodeLabelTouch;
  var objectMouseover = this.behavior.nodeObjectMouseover;
  var objectMouseout = this.behavior.nodeObjectMouseout;

  var mg = update_selection.select('.node-circle').attr('transform', function (d) {
    return 'translate(' + d.x + ',' + d.y + ')';
  }).style('visibility', function (d) {
    return hideNode(d, hide_secondary_metabolites) ? 'hidden' : null;
  }).attr('r', function (d) {
    if (d.node_type === 'metabolite') {
      var should_scale = has_data_on_nodes && metabolite_data_styles.indexOf('size') !== -1;
      if (should_scale) {
        var f = d.data;
        return f === null ? no_data_style['size'] : scale.metabolite_size(f);
      } else {
        return d.node_is_primary ? primary_r : secondary_r;
      }
    }
    // midmarkers and multimarkers
    return marker_r;
  }).style('fill', function (d) {
    if (d.node_type === 'metabolite') {
      var should_color_data = has_data_on_nodes && metabolite_data_styles.indexOf('color') !== -1;
      if (should_color_data) {
        var f = d.data;
        return f === null ? no_data_style['color'] : scale.metabolite_color(f);
      } else {
        return null;
      }
    }
    // midmarkers and multimarkers
    return null;
  }).call(this.behavior.turnOffDrag).call(drag_behavior).on('mousedown', mousedown_fn).on('click', click_fn).on('mouseover', objectMouseover).on('mouseout', objectMouseout);

  // update node label visibility
  var node_label = update_selection.select('.node-label').attr('visibility', hide_all_labels ? 'hidden' : 'visible');
  if (!hide_all_labels) {
    node_label.style('visibility', function (d) {
      return hideNode(d, hide_secondary_metabolites) ? 'hidden' : null;
    }).attr('transform', function (d) {
      return 'translate(' + d.label_x + ',' + d.label_y + ')';
    }).text(function (d) {
      var t = d[identifiers_on_map];
      if (has_data_on_nodes && metabolite_data_styles.indexOf('text') !== -1) t += ' ' + d.data_string;
      return t;
    }).call(this.behavior.turnOffDrag).call(label_drag_behavior).on('mouseover', labelMouseover).on('mouseout', labelMouseout).on('touchend', labelTouch);
  }

  this.callback_manager.run('update_node', this, update_selection);

  function hideNode(d, hide_secondary_metabolites) {
    return d.node_type === 'metabolite' && hide_secondary_metabolites && !d.node_is_primary;
  }
}

/**
 * Create text labels in the enter_selection.
 * @param {} enter_selection - The D3 enter selection.
 * @returns {} The selection of the new nodes.
 */
function create_text_label(enter_selection) {
  var g = enter_selection.append('g').attr('id', function (d) {
    return 'l' + d.text_label_id;
  }).attr('class', 'text-label');
  g.append('text').attr('class', 'label');

  this.callback_manager.run('create_text_label', this, enter_selection);

  return g;
}

function update_text_label(update_selection) {
  var mousedown = this.behavior.textLabelMousedown;
  var click = this.behavior.textLabelClick;
  var turnOffDrag = this.behavior.turnOffDrag;
  var drag = this.behavior.selectableDrag;

  update_selection.select('.label').text(function (d) {
    return d.text;
  }).attr('transform', function (d) {
    return 'translate(' + d.x + ',' + d.y + ')';
  }).on('mousedown', mousedown).on('click', click).call(turnOffDrag).call(drag);

  this.callback_manager.run('update_text_label', this, update_selection);
}

function displacedCoords(reactionArrowDisplacement, start, end, displace) {
  var length = reactionArrowDisplacement;
  var hyp = utils.distance(start, end);
  if (!length || !hyp) {
    console.warn('No space for displacement');
    return { x: start.x, y: start.y };
  }
  if (displace === 'start') {
    return {
      x: start.x + length * (end.x - start.x) / hyp,
      y: start.y + length * (end.y - start.y) / hyp
    };
  } else if (displace === 'end') {
    return {
      x: end.x - length * (end.x - start.x) / hyp,
      y: end.y - length * (end.y - start.y) / hyp
    };
  } else {
    console.error('bad displace value: ' + displace);
  }
}

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _scalePresets = __webpack_require__(50);

var _scalePresets2 = _interopRequireDefault(_scalePresets);

var _d3Scale = __webpack_require__(112);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scale = function () {
  function Scale() {
    _classCallCheck(this, Scale);

    this.x = (0, _d3Scale.scaleLinear)();
    this.y = (0, _d3Scale.scaleLinear)();
    this.x_size = (0, _d3Scale.scaleLinear)();
    this.y_size = (0, _d3Scale.scaleLinear)();
    this.size = (0, _d3Scale.scaleLinear)();
    this.reaction_color = (0, _d3Scale.scaleLinear)().clamp(true);
    this.reaction_size = (0, _d3Scale.scaleLinear)().clamp(true);
    this.metabolite_color = (0, _d3Scale.scaleLinear)().clamp(true);
    this.metabolite_size = (0, _d3Scale.scaleLinear)().clamp(true);
  }

  Scale.prototype.connectToSettings = function connectToSettings(settings, map, getDataStatistics) {
    var _this = this;

    // Wire up default scales. First warn if preset and scale are set. Use
    // presets to set scales, avoiding loops.
    var types = ['reaction', 'metabolite'];
    types.forEach(function (type) {
      var scale = type + '_scale';
      var preset = type + '_scale_preset';

      // initial
      var presetVal = settings.get(preset);
      var scaleVal = settings.get(scale);
      if (presetVal && scaleVal && scaleVal !== _scalePresets2.default[presetVal]) {
        console.warn('Both ' + scale + ' and ' + preset + ' are defined. Ignoring ' + preset + '. Set ' + preset + ' to "false" to hide this warning.');
        settings.set(preset, null);
      } else if (presetVal) {
        settings.set(scale, _scalePresets2.default[presetVal]);
      } else if (!scaleVal) {
        console.error('Must provide a ' + scale + ' or ' + preset);
      }

      // Warn if scales are too short
      if (settings.get(scale) && settings.get(scale).length < 2) {
        console.error('Bad value for option ' + scale + '. Scales must have at least 2 points.');
      } else {
        _this.setScale(type, scale, getDataStatistics);
      }

      // reactive
      settings.streams[scale].onValue(function (val) {
        // if the scale did not come from the preset, then reset the preset setting
        if (val && val !== _scalePresets2.default[settings.get(preset)]) {
          settings.set(preset, null);
        }
        _this.setScale(type, val, getDataStatistics);
      });
      settings.streams[preset].onValue(function (val) {
        // if there is a new preset, then set the scale
        if (val) {
          settings.set(scale, _scalePresets2.default[val]);
        }
      });

      // stats changes
      map.callback_manager.set('calc_data_stats__' + type, function (changed) {
        if (changed) {
          _this.setScale(type, settings.get(type + '_scale'), getDataStatistics);
        }
      });
    });
  };

  Scale.prototype.sortScale = function sortScale(scale, stats) {
    var sorted = scale.map(function (x) {
      var v = void 0;
      if (x.type in stats) {
        v = stats[x.type];
      } else if (x.type === 'value') {
        v = x.value;
      } else {
        throw new Error('Bad domain type ' + x.type);
      }
      return { v: v, color: x.color, size: x.size };
    }).sort(function (a, b) {
      return a.v - b.v;
    });
    return {
      domain: sorted.map(function (x) {
        return x.v;
      }),
      color_range: sorted.map(function (x) {
        return x.color;
      }),
      size_range: sorted.map(function (x) {
        return x.size;
      })
    };
  };

  Scale.prototype.setScale = function setScale(type, scale, getDataStatistics) {
    if (type === 'reaction') {
      this.setReactionScale(scale, getDataStatistics);
    } else {
      this.setMetaboliteScale(scale, getDataStatistics);
    }
  };

  Scale.prototype.setReactionScale = function setReactionScale(scale, getDataStatistics) {
    var stats = getDataStatistics().reaction;
    // If stats are null, then no data, so don't worry about it.
    if (stats !== null) {
      var out = this.sortScale(scale, stats);
      this.reaction_color.domain(out.domain);
      this.reaction_size.domain(out.domain);
      this.reaction_color.range(out.color_range);
      this.reaction_size.range(out.size_range);
    }
  };

  Scale.prototype.setMetaboliteScale = function setMetaboliteScale(scale, getDataStatistics) {
    var stats = getDataStatistics().metabolite;
    // If stats are null, then no data, so don't worry about it.
    if (stats !== null) {
      var out = this.sortScale(scale, stats);
      this.metabolite_color.domain(out.domain);
      this.metabolite_size.domain(out.domain);
      this.metabolite_color.range(out.color_range);
      this.metabolite_size.range(out.size_range);
    }
  };

  return Scale;
}();

exports.default = Scale;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(4);

var utils = _interopRequireWildcard(_utils);

var _CallbackManager = __webpack_require__(21);

var _CallbackManager2 = _interopRequireDefault(_CallbackManager);

var _d3Drag = __webpack_require__(22);

var _d3Selection = __webpack_require__(2);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Canvas. Defines a canvas that accepts drag/zoom events and can be resized.
 * Canvas(selection, x, y, width, height)
 * Adapted from http://bl.ocks.org/mccannf/1629464.
 */
var Canvas = function () {
  function Canvas(selection, sizeAndLocation) {
    _classCallCheck(this, Canvas);

    this.selection = selection;
    this.x = sizeAndLocation.x;
    this.y = sizeAndLocation.y;
    this.width = sizeAndLocation.width;
    this.height = sizeAndLocation.height;

    // enable by default
    this.resizeEnabled = true;

    // set up the callbacks
    this.callbackManager = new _CallbackManager2.default();

    this.setup();
  }

  /**
   * Turn the resize on or off
   */


  Canvas.prototype.toggleResize = function toggleResize(onOff) {
    if (_underscore2.default.isUndefined(onOff)) onOff = !this.resizeEnabled;

    if (onOff) {
      this.selection.selectAll('.drag-rect').style('pointer-events', 'auto');
    } else {
      this.selection.selectAll('.drag-rect').style('pointer-events', 'none');
    }
  };

  Canvas.prototype.setup = function setup() {
    var _this = this;

    var dragbarWidth = 100;
    var mouseNodeMult = 10;
    var newSel = this.selection.append('g').classed('canvas-group', true).data([{ x: this.x, y: this.y }]);

    var stopPropagation = function stopPropagation() {
      _d3Selection.event.sourceEvent.stopPropagation();
    };

    var transformString = function transformString(x, y, currentTransform) {
      var tr = utils.d3_transform_catch(currentTransform);
      var translate = tr.translate;
      if (x !== null) translate[0] = x;
      if (y !== null) translate[1] = y;
      return 'translate(' + translate + ')';
    };

    var mouseNode = newSel.append('rect').attr('id', 'mouse-node').attr('width', this.width * mouseNodeMult).attr('height', this.height * mouseNodeMult).attr('transform', 'translate(' + [this.x - this.width * mouseNodeMult / 2, this.y - this.height * mouseNodeMult / 2] + ')').attr('pointer-events', 'all');
    this.mouseNode = mouseNode;

    var rect = newSel.append('rect').attr('id', 'canvas').attr('width', this.width).attr('height', this.height).attr('transform', 'translate(' + [this.x, this.y] + ')');

    var dragLeft = (0, _d3Drag.drag)().on('start', stopPropagation).on('drag', function (d) {
      var oldX = d.x;
      d.x = Math.min(d.x + _this.width - dragbarWidth / 2, _d3Selection.event.x);
      _this.x = d.x;
      _this.width = _this.width + (oldX - d.x);
      left.attr('transform', function (d) {
        return transformString(d.x - dragbarWidth / 2, null, left.attr('transform'));
      });
      mouseNode.attr('transform', function (d) {
        return transformString(d.x, null, mouseNode.attr('transform'));
      }).attr('width', _this.width * mouseNodeMult);
      rect.attr('transform', function (d) {
        return transformString(d.x, null, rect.attr('transform'));
      }).attr('width', _this.width);
      top.attr('transform', function (d) {
        return transformString(d.x + dragbarWidth / 2, null, top.attr('transform'));
      }).attr('width', _this.width - dragbarWidth);
      bottom.attr('transform', function (d) {
        return transformString(d.x + dragbarWidth / 2, null, bottom.attr('transform'));
      }).attr('width', _this.width - dragbarWidth);

      _this.callbackManager.run('resize');
    });

    var left = newSel.append('rect').classed('drag-rect', true).attr('transform', function (d) {
      return 'translate(' + [d.x - dragbarWidth / 2, d.y + dragbarWidth / 2] + ')';
    }).attr('height', this.height - dragbarWidth).attr('id', 'dragleft').attr('width', dragbarWidth).attr('cursor', 'ew-resize').classed('resize-rect', true).call(dragLeft);

    var dragRight = (0, _d3Drag.drag)().on('start', stopPropagation).on('drag', function (d) {
      _d3Selection.event.sourceEvent.stopPropagation();
      var dragX = Math.max(d.x + dragbarWidth / 2, d.x + _this.width + _d3Selection.event.dx);
      // recalculate width
      _this.width = dragX - d.x;
      // move the right drag handle
      right.attr('transform', function (d) {
        return transformString(dragX - dragbarWidth / 2, null, right.attr('transform'));
      });
      // resize the drag rectangle. as we are only resizing from the
      // right, the x coordinate does not need to change
      mouseNode.attr('width', _this.width * mouseNodeMult);
      rect.attr('width', _this.width);
      top.attr('width', _this.width - dragbarWidth);
      bottom.attr('width', _this.width - dragbarWidth);

      _this.callbackManager.run('resize');
    });

    var right = newSel.append('rect').classed('drag-rect', true).attr('transform', function (d) {
      return 'translate(' + [d.x + _this.width - dragbarWidth / 2, d.y + dragbarWidth / 2] + ')';
    }).attr('id', 'dragright').attr('height', this.height - dragbarWidth).attr('width', dragbarWidth).attr('cursor', 'ew-resize').classed('resize-rect', true).call(dragRight);

    var dragTop = (0, _d3Drag.drag)().on('start', stopPropagation).on('drag', function (d) {
      _d3Selection.event.sourceEvent.stopPropagation();
      var oldY = d.y;
      d.y = Math.min(d.y + _this.height - dragbarWidth / 2, _d3Selection.event.y);
      _this.y = d.y;
      _this.height = _this.height + (oldY - d.y);
      top.attr('transform', function (d) {
        return transformString(null, d.y - dragbarWidth / 2, top.attr('transform'));
      });
      mouseNode.attr('transform', function (d) {
        return transformString(null, d.y, mouseNode.attr('transform'));
      }).attr('width', _this.height * mouseNodeMult);
      rect.attr('transform', function (d) {
        return transformString(null, d.y, rect.attr('transform'));
      }).attr('height', _this.height);
      left.attr('transform', function (d) {
        return transformString(null, d.y + dragbarWidth / 2, left.attr('transform'));
      }).attr('height', _this.height - dragbarWidth);
      right.attr('transform', function (d) {
        return transformString(null, d.y + dragbarWidth / 2, right.attr('transform'));
      }).attr('height', _this.height - dragbarWidth);

      _this.callbackManager.run('resize');
    });

    var top = newSel.append('rect').classed('drag-rect', true).attr('transform', function (d) {
      return 'translate(' + [d.x + dragbarWidth / 2, d.y - dragbarWidth / 2] + ')';
    }).attr('height', dragbarWidth).attr('width', this.width - dragbarWidth).attr('cursor', 'ns-resize').classed('resize-rect', true).call(dragTop);

    var dragBottom = (0, _d3Drag.drag)().on('start', stopPropagation).on('drag', function (d) {
      _d3Selection.event.sourceEvent.stopPropagation();
      var dragY = Math.max(d.y + dragbarWidth / 2, d.y + _this.height + _d3Selection.event.dy);
      // recalculate width
      _this.height = dragY - d.y;
      // move the right drag handle
      bottom.attr('transform', function (d) {
        return transformString(null, dragY - dragbarWidth / 2, bottom.attr('transform'));
      });
      // resize the drag rectangle. as we are only resizing from the
      // right, the x coordinate does not need to change
      mouseNode.attr('height', _this.height * mouseNodeMult);
      rect.attr('height', _this.height);
      left.attr('height', _this.height - dragbarWidth);
      right.attr('height', _this.height - dragbarWidth);

      _this.callbackManager.run('resize');
    });

    var bottom = newSel.append('rect').classed('drag-rect', true).attr('transform', function (d) {
      return 'translate(' + [d.x + dragbarWidth / 2, d.y + _this.height - dragbarWidth / 2] + ')';
    }).attr('height', dragbarWidth).attr('width', this.width - dragbarWidth).attr('cursor', 'ns-resize').classed('resize-rect', true).call(dragBottom);
  };

  Canvas.prototype.sizeAndLocation = function sizeAndLocation() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  };

  return Canvas;
}();

exports.default = Canvas;

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _d3Brush = __webpack_require__(114);

var _d3Selection = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Define a brush to select elements in a map.
 * @param {D3 Selection} selection - A d3 selection to place the brush in.
 * @param {Boolean} is_enabled - Whether to turn the brush on.
 * @param {escher.Map} map - The map where the brush will be active.
 * @param {String} insert_after - A d3 selector string to choose the svg element
 *                                that the brush will be inserted after. Often a
 *                                canvas element (e.g. '.canvas-group').
 */
var Brush = function () {
  function Brush(selection, isEnabled, map, insertAfter) {
    _classCallCheck(this, Brush);

    this.brushSel = selection.append('g').attr('id', 'brush-container');
    var node = this.brushSel.node();
    var insertBeforeNode = selection.select(insertAfter).node().nextSibling;
    if (node !== insertBeforeNode) {
      node.parentNode.insertBefore(node, insertBeforeNode);
    }
    this.enabled = isEnabled;
    this.map = map;
  }

  /**
   * Returns a boolean for the on/off status of the brush
   * @return {Boolean}
   */


  Brush.prototype.brushIsEnabled = function brushIsEnabled() {
    return this.map.sel.select('.brush').empty();
  };

  /**
   * Turn the brush on or off
   * @param {Boolean} on_off
   */


  Brush.prototype.toggle = function toggle(onOff) {
    if (onOff === undefined) {
      onOff = !this.enabled;
    }
    if (onOff) {
      this.setupSelectionBrush();
    } else {
      this.brushSel.selectAll('*').remove();
    }
  };

  /**
   * Turn off the mouse crosshair
   */


  Brush.prototype.turnOffCrosshair = function turnOffCrosshair(sel) {
    sel.selectAll('rect').attr('cursor', null);
  };

  Brush.prototype.setupSelectionBrush = function setupSelectionBrush() {
    var _this = this;

    var map = this.map;
    var selection = this.brushSel;
    var selectableSelection = map.sel.selectAll('#nodes,#text-labels');
    var sizeAndLocation = map.canvas.sizeAndLocation();
    var width = sizeAndLocation.width;
    var height = sizeAndLocation.height;
    var x = sizeAndLocation.x;
    var y = sizeAndLocation.y;
    var turnOffCrosshair = this.turnOffCrosshair.bind(this);

    // Clear existing brush
    selection.selectAll('*').remove();

    // Set a flag so we know that the brush is being cleared at the end of a
    // successful brush
    var clearingFlag = false;

    var brush = (0, _d3Brush.brush)().extent([[x, y], [x + width, y + height]]).on('start', function () {
      _this.turnOffCrosshair(selection);
      // unhide secondary metabolites if they are hidden
      if (map.settings.get('hide_secondary_metabolites')) {
        map.settings.set('hide_secondary_metabolites', false);
        map.draw_everything();
        map.set_status('Showing secondary metabolites. You can hide them ' + 'again in Settings.', 2000);
      }
    }).on('brush', function () {
      var shiftKeyOn = _d3Selection.event.sourceEvent.shiftKey;
      var rect = (0, _d3Brush.brushSelection)(this);
      // Check for no selection (e.g. after clearing brush)
      if (rect !== null) {
        // When shift is pressed, ignore the currently selected nodes.
        // Otherwise, brush all nodes.
        var selection = shiftKeyOn ? selectableSelection.selectAll('.node:not(.selected),.text-label:not(.selected)') : selectableSelection.selectAll('.node,.text-label');
        selection.classed('selected', function (d) {
          var sx = d.x;
          var sy = d.y;
          return rect[0][0] <= sx && sx < rect[1][0] && rect[0][1] <= sy && sy < rect[1][1];
        });
      }
    }).on('end', function () {
      turnOffCrosshair(selection);
      // Clear brush
      var rect = (0, _d3Brush.brushSelection)(this);
      if (rect === null) {
        if (clearingFlag) {
          clearingFlag = false;
        } else {
          // Empty selection, deselect all
          map.select_none();
        }
      } else {
        // Not empty, then clear the box
        clearingFlag = true;
        selection.call(brush.move, null);
      }
    });

    selection
    // Initialize brush
    .call(brush);

    // Turn off the pan grab icons
    turnOffCrosshair(selection);
  };

  return Brush;
}();

exports.default = Brush;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _PlacedDiv = __webpack_require__(35);

var _PlacedDiv2 = _interopRequireDefault(_PlacedDiv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * TextEditInput
 */
var TextEditInput = function () {
  function TextEditInput(selection, map, zoomContainer) {
    _classCallCheck(this, TextEditInput);

    var div = selection.append('div').attr('id', 'text-edit-input');
    this.placedDiv = (0, _PlacedDiv2.default)(div, map);
    this.placedDiv.hide();
    this.input = div.append('input');

    this.map = map;
    this.setUpMapCallbacks(map);
    this.zoomContainer = zoomContainer;
    this.setUpZoomCallbacks(zoomContainer);

    this.isNew = false;
  }

  TextEditInput.prototype.setUpMapCallbacks = function setUpMapCallbacks(map) {
    var _this = this;

    // Input
    map.callback_manager.set('edit_text_label.text_edit_input', function (target, coords) {
      _this.show(target, coords);
    });

    // new text_label
    map.callback_manager.set('new_text_label.text_edit_input', function (coords) {
      if (_this.activeTarget !== null) {
        _this._acceptChanges(_this.activeTarget.target);
      }
      _this.hide();
      _this._addAndEdit(coords);
    });

    map.callback_manager.set('hide_text_label_editor.text_edit_input', function () {
      _this.hide();
    });
  };

  TextEditInput.prototype.setUpZoomCallbacks = function setUpZoomCallbacks(zoomContainer) {
    var _this2 = this;

    zoomContainer.callbackManager.set('zoom.text_edit_input', function () {
      if (_this2.activeTarget) {
        _this2._acceptChanges(_this2.activeTarget.target);
      }
      if (_this2.is_visible()) {
        _this2.hide();
      }
    });
    zoomContainer.callbackManager.set('go_to.text_edit_input', function () {
      if (_this2.activeTarget) {
        _this2._acceptChanges(_this2.activeTarget.target);
      }
      if (_this2.is_visible()) {
        _this2.hide();
      }
    });
  };

  TextEditInput.prototype.is_visible = function is_visible() {
    // eslint-disable-line camelcase
    return this.placedDiv.is_visible();
  };

  TextEditInput.prototype.show = function show(target, coords) {
    var _this3 = this;

    // save any existing edit
    if (this.activeTarget) {
      this._acceptChanges(this.activeTarget.target);
    }

    // set the current target
    this.activeTarget = { target: target, coords: coords

      // set the new value
    };target.each(function (d) {
      _this3.input.node().value = d.text;
    });

    // place the input
    this.placedDiv.place(coords);
    this.input.node().focus();

    // escape key
    this.clearEscape = this.map.key_manager.addEscapeListener(function () {
      _this3._acceptChanges(target);
      _this3.hide();
    }, true);
    // enter key
    this.clearEnter = this.map.key_manager.addEnterListener(function () {
      _this3._acceptChanges(target);
      _this3.hide();
    }, true);
  };

  TextEditInput.prototype.hide = function hide() {
    this.isNew = false;

    // hide the input
    this.placedDiv.hide();

    // clear the value
    this.input.attr('value', '');
    this.activeTarget = null;

    // clear escape
    if (this.clearEscape) this.clearEscape();
    this.clearEscape = null;
    // clear enter
    if (this.clearEnter) this.clearEnter();
    this.clearEnter = null;
    // turn off click listener
    // this.map.sel.on('click.', null)
  };

  TextEditInput.prototype._acceptChanges = function _acceptChanges(target) {
    var _this4 = this;

    var value = this.input.node().value;
    if (value === '') {
      // Delete the label
      target.each(function (d) {
        var selected = {};
        selected[d.text_label_id] = _this4.map.text_labels[d.text_label_id];
        _this4.map.delete_selectable({}, selected, true);
      });
    } else {
      // Set the text
      var textLabelIds = [];
      target.each(function (d) {
        _this4.map.edit_text_label(d.text_label_id, value, true, _this4.isNew);
        textLabelIds.push(d.text_label_id);
      });
    }
  };

  TextEditInput.prototype._addAndEdit = function _addAndEdit(coords) {
    this.isNew = true;

    // Make an empty label
    var textLabelId = this.map.new_text_label(coords, '');
    // Apply the cursor to the new label
    var sel = this.map.sel.select('#text-labels').selectAll('.text-label').filter(function (d) {
      return d.text_label_id === textLabelId;
    });
    sel.select('text').classed('edit-text-cursor', true);
    this.show(sel, coords);
  };

  return TextEditInput;
}();

exports.default = TextEditInput;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

var _ScaleSelector = __webpack_require__(70);

var _ScaleSelector2 = _interopRequireDefault(_ScaleSelector);

var _ScaleSlider = __webpack_require__(71);

var _ScaleSlider2 = _interopRequireDefault(_ScaleSlider);

var _ScaleSelection = __webpack_require__(80);

var _ScaleSelection2 = _interopRequireDefault(_ScaleSelection);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

__webpack_require__(81);

var _scalePresets = __webpack_require__(50);

var _scalePresets2 = _interopRequireDefault(_scalePresets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */


/**
 * SettingsMenu. Handles the functions associated with the UI for changing
 * settings. Implements Settings.js but otherwise only uses
 * Preact.
 */
var SettingsMenu = function (_Component) {
  _inherits(SettingsMenu, _Component);

  function SettingsMenu() {
    _classCallCheck(this, SettingsMenu);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  SettingsMenu.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    this.props.settings.holdChanges();
    this.setState({
      clearEscape: this.props.map.key_manager.addEscapeListener(function () {
        return _this2.abandonChanges();
      }, true),
      clearEnter: this.props.map.key_manager.addKeyListener(['enter'], function () {
        return _this2.saveChanges();
      }, true)
    });
  };

  SettingsMenu.prototype.componentWillUnmount = function componentWillUnmount() {
    this.state.clearEscape();
    this.state.clearEnter();
  };

  SettingsMenu.prototype.abandonChanges = function abandonChanges() {
    this.props.settings.abandonChanges();
    this.props.setDisplay(false);
  };

  SettingsMenu.prototype.saveChanges = function saveChanges() {
    this.props.settings.acceptChanges();
    this.props.setDisplay(false);
  };

  /**
   * Function to toggle one option in the reaction or metabolite styling.
   * @param {String} value - the style option to be added or removed
   * @param {String} type - reaction_style or metabolite_style
   */


  SettingsMenu.prototype.handleStyle = function handleStyle(value, type) {
    var currentSetting = this.props.settings.get(type);
    var index = currentSetting.indexOf(value);
    if (index === -1) {
      this.props.settings.set(type, [].concat(currentSetting, [value]));
    } else {
      this.props.settings.set(type, [].concat(currentSetting.slice(0, index), currentSetting.slice(index + 1)));
    }
  };

  SettingsMenu.prototype.render = function render() {
    var _this3 = this;

    var settings = this.props.settings;
    var enableTooltips = settings.get('enable_tooltips') || [];
    var dataStatistics = this.props.map.get_data_statistics();

    return (0, _preact.h)(
      'div',
      { className: 'settingsBackground' },
      (0, _preact.h)(
        'div',
        { className: 'settingsBoxContainer' },
        (0, _preact.h)(
          'button',
          { className: 'discardChanges btn', onClick: function onClick() {
              return _this3.abandonChanges();
            } },
          (0, _preact.h)('i', { className: 'icon-cancel', 'aria-hidden': 'true' })
        ),
        (0, _preact.h)(
          'button',
          { className: 'saveChanges btn', onClick: function onClick() {
              return _this3.saveChanges();
            } },
          (0, _preact.h)('i', { className: 'icon-ok', 'aria-hidden': 'true' })
        ),
        (0, _preact.h)(
          'div',
          { className: 'settingsBox' },
          (0, _preact.h)(
            'div',
            { className: 'settingsTip' },
            (0, _preact.h)(
              'i',
              null,
              'Tip: Hover over an option to see more details about it.'
            )
          ),
          (0, _preact.h)('hr', null),
          (0, _preact.h)(
            'div',
            { className: 'title' },
            'View and build options'
          ),
          (0, _preact.h)(
            'div',
            { className: 'settingsContainer' },
            (0, _preact.h)(
              'table',
              { className: 'radioSelection' },
              (0, _preact.h)(
                'tr',
                { title: 'The identifiers that are show in the reaction, gene, and metabolite labels on the map.' },
                (0, _preact.h)(
                  'td',
                  { className: 'optionLabel' },
                  'Identifiers:'
                ),
                (0, _preact.h)(
                  'td',
                  { className: 'singleLine' },
                  (0, _preact.h)(
                    'label',
                    { className: 'optionGroup' },
                    (0, _preact.h)('input', {
                      type: 'radio',
                      name: 'identifiers',
                      onClick: function onClick() {
                        settings.set('identifiers_on_map', 'bigg_id');
                      },
                      checked: settings.get('identifiers_on_map') === 'bigg_id'
                    }),
                    'ID\'s'
                  ),
                  (0, _preact.h)(
                    'label',
                    { className: 'optionGroup' },
                    (0, _preact.h)('input', {
                      type: 'radio',
                      name: 'identifiers',
                      onClick: function onClick() {
                        settings.set('identifiers_on_map', 'name');
                      },
                      checked: settings.get('identifiers_on_map') === 'name'
                    }),
                    'Descriptive names'
                  )
                )
              )
            ),
            (0, _preact.h)(
              'label',
              { title: 'If checked, then the scroll wheel and trackpad will control zoom rather than pan.' },
              (0, _preact.h)('input', {
                type: 'checkbox',
                onClick: function onClick() {
                  if (settings.get('scroll_behavior') === 'zoom') {
                    settings.set('scroll_behavior', 'pan');
                  } else {
                    settings.set('scroll_behavior', 'zoom');
                  }
                },
                checked: settings.get('scroll_behavior') === 'zoom'
              }),
              'Scroll to zoom (instead of scroll to pan)'
            ),
            (0, _preact.h)(
              'label',
              { title: 'If checked, then only the primary metabolites will be displayed.' },
              (0, _preact.h)('input', {
                type: 'checkbox',
                onClick: function onClick() {
                  return settings.set('hide_secondary_metabolites', !settings.get('hide_secondary_metabolites'));
                },
                checked: settings.get('hide_secondary_metabolites')
              }),
              'Hide secondary metabolites'
            ),
            (0, _preact.h)(
              'label',
              {
                title: 'If checked, then gene reaction rules will be displayed below each reaction label. (Gene reaction rules are always shown when gene data is loaded.)'
              },
              (0, _preact.h)('input', {
                type: 'checkbox',
                onClick: function onClick() {
                  return settings.set('show_gene_reaction_rules', !settings.get('show_gene_reaction_rules'));
                },
                checked: settings.get('show_gene_reaction_rules')
              }),
              'Show gene reaction rules'
            ),
            (0, _preact.h)(
              'label',
              { title: 'If checked, hide all reaction, gene, and metabolite labels' },
              (0, _preact.h)('input', {
                type: 'checkbox',
                onClick: function onClick() {
                  return settings.set('hide_all_labels', !settings.get('hide_all_labels'));
                },
                checked: settings.get('hide_all_labels')
              }),
              'Hide reaction, gene, and metabolite labels'
            ),
            (0, _preact.h)(
              'label',
              { title: 'If checked, then allow duplicate reactions during model building.' },
              (0, _preact.h)('input', {
                type: 'checkbox',
                onClick: function onClick() {
                  return settings.set('allow_building_duplicate_reactions', !settings.get('allow_building_duplicate_reactions'));
                },
                checked: settings.get('allow_building_duplicate_reactions')
              }),
              'Allow duplicate reactions'
            ),
            (0, _preact.h)(
              'label',
              { title: 'If checked, then highlight in red all the reactions on the map that are not present in the loaded model.' },
              (0, _preact.h)('input', {
                type: 'checkbox',
                onClick: function onClick() {
                  settings.set('highlight_missing', !settings.get('highlight_missing'));
                },
                checked: settings.get('highlight_missing')
              }),
              'Highlight reactions not in model'
            ),
            (0, _preact.h)(
              'label',
              { title: 'If true, then use CSS3 3D transforms to speed up panning and zooming.' },
              (0, _preact.h)('input', {
                type: 'checkbox',
                onClick: function onClick() {
                  settings.set('use_3d_transform', !settings.get('use_3d_transform'));
                },
                checked: settings.get('use_3d_transform')
              }),
              'Use 3D transform for responsive panning and zooming'
            ),
            (0, _preact.h)(
              'table',
              { style: { marginTop: '5px' } },
              (0, _preact.h)(
                'tr',
                { title: 'Determines over which elements tooltips will display for reactions, metabolites, and genes' },
                (0, _preact.h)(
                  'td',
                  null,
                  'Show tooltips over:'
                ),
                (0, _preact.h)(
                  'td',
                  { className: 'singleLine' },
                  (0, _preact.h)(
                    'label',
                    { className: 'tooltipOption', title: 'If checked, tooltips will display over the gene, reaction, and metabolite labels' },
                    (0, _preact.h)('input', {
                      type: 'checkbox',
                      onClick: function onClick() {
                        var type = 'label';
                        var newEnableTooltips = _underscore2.default.contains(enableTooltips, type) ? _underscore2.default.filter(enableTooltips, function (x) {
                          return x !== type;
                        }) : [].concat(enableTooltips, [type]);
                        settings.set('enable_tooltips', newEnableTooltips);
                      },
                      checked: _underscore2.default.contains(enableTooltips, 'label')
                    }),
                    'Labels'
                  ),
                  (0, _preact.h)(
                    'label',
                    { className: 'tooltipOption', title: 'If checked, tooltips will display over the reaction line segments and metabolite circles' },
                    (0, _preact.h)('input', {
                      type: 'checkbox',
                      onClick: function onClick() {
                        var type = 'object';
                        var newEnableTooltips = _underscore2.default.contains(enableTooltips, type) ? _underscore2.default.filter(enableTooltips, function (x) {
                          return x !== type;
                        }) : [].concat(enableTooltips, [type]);
                        settings.set('enable_tooltips', newEnableTooltips);
                      },
                      checked: _underscore2.default.contains(enableTooltips, 'object')
                    }),
                    'Objects'
                  )
                )
              )
            )
          ),
          (0, _preact.h)(
            'div',
            { className: 'settingsTip', style: { marginTop: '16px' } },
            (0, _preact.h)(
              'i',
              null,
              'Tip: To increase map performance, turn off text boxes (i.e. labels and gene reaction rules).'
            )
          ),
          (0, _preact.h)('hr', null),
          (0, _preact.h)(
            'div',
            { className: 'scaleTitle' },
            (0, _preact.h)(
              'div',
              { className: 'title' },
              'Reactions'
            ),
            (0, _preact.h)(
              _ScaleSelector2.default,
              { disabled: dataStatistics.reaction === null },
              Object.values(_underscore2.default.mapObject(_scalePresets2.default, function (value, key) {
                return (0, _preact.h)(_ScaleSelection2.default, {
                  name: key,
                  scale: value,
                  onClick: function onClick() {
                    settings.set('reaction_scale_preset', key);
                  }
                });
              }))
            )
          ),
          (0, _preact.h)(_ScaleSlider2.default, {
            scale: settings.get('reaction_scale'),
            settings: settings,
            type: 'Reaction',
            stats: dataStatistics.reaction,
            noDataColor: settings.get('reaction_no_data_color'),
            noDataSize: settings.get('reaction_no_data_size'),
            onChange: function onChange(scale) {
              settings.set('reaction_scale', scale);
            },
            onNoDataColorChange: function onNoDataColorChange(val) {
              settings.set('reaction_no_data_color', val);
            },
            onNoDataSizeChange: function onNoDataSizeChange(val) {
              settings.set('reaction_no_data_size', val);
            },
            abs: settings.get('reaction_styles').indexOf('abs') > -1
          }),
          (0, _preact.h)(
            'div',
            { className: 'subheading' },
            'Reaction or Gene data'
          ),
          (0, _preact.h)(
            'table',
            { className: 'radioSelection' },
            (0, _preact.h)(
              'tr',
              null,
              (0, _preact.h)(
                'td',
                {
                  className: 'optionLabel',
                  title: 'Options for reactions data'
                },
                'Options:'
              ),
              (0, _preact.h)(
                'td',
                null,
                (0, _preact.h)(
                  'label',
                  {
                    className: 'optionGroup',
                    title: 'If checked, use the absolute value when calculating colors and sizes of reactions on the map'
                  },
                  (0, _preact.h)('input', {
                    type: 'checkbox',
                    name: 'reactionStyle',
                    onClick: function onClick() {
                      return _this3.handleStyle('abs', 'reaction_styles');
                    },
                    checked: _underscore2.default.contains(settings.get('reaction_styles'), 'abs'),
                    disabled: dataStatistics.reaction === null
                  }),
                  'Absolute value'
                ),
                (0, _preact.h)(
                  'label',
                  {
                    className: 'optionGroup',
                    title: 'If checked, then size the thickness of reaction lines according to the value of the reaction data'
                  },
                  (0, _preact.h)('input', {
                    type: 'checkbox',
                    name: 'reactionStyle',
                    onClick: function onClick() {
                      return _this3.handleStyle('size', 'reaction_styles');
                    },
                    checked: _underscore2.default.contains(settings.get('reaction_styles'), 'size'),
                    disabled: dataStatistics.reaction === null
                  }),
                  'Size'
                ),
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup', title: 'If checked, then color the reaction lines according to the value of the reaction data' },
                  (0, _preact.h)('input', {
                    type: 'checkbox',
                    name: 'reactionStyle',
                    onClick: function onClick() {
                      return _this3.handleStyle('color', 'reaction_styles');
                    },
                    checked: _underscore2.default.contains(settings.get('reaction_styles'), 'color'),
                    disabled: dataStatistics.reaction === null
                  }),
                  'Color'
                ),
                (0, _preact.h)('br', null),
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup', title: 'If checked, then show data values in the reaction labels' },
                  (0, _preact.h)('input', {
                    type: 'checkbox',
                    name: 'reactionStyle',
                    onClick: function onClick() {
                      return _this3.handleStyle('text', 'reaction_styles');
                    },
                    checked: _underscore2.default.contains(settings.get('reaction_styles'), 'text'),
                    disabled: dataStatistics.reaction === null
                  }),
                  'Text (Show data in label)'
                )
              )
            ),
            (0, _preact.h)(
              'tr',
              { title: 'The function that will be used to compare datasets, when paired data is loaded' },
              (0, _preact.h)(
                'td',
                { className: 'optionLabel' },
                'Comparison:'
              ),
              (0, _preact.h)(
                'td',
                null,
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup' },
                  (0, _preact.h)('input', {
                    type: 'radio',
                    name: 'reactionCompare',
                    onClick: function onClick() {
                      return settings.set('reaction_compare_style', 'fold');
                    },
                    checked: settings.get('reaction_compare_style') === 'fold',
                    disabled: dataStatistics.reaction === null
                  }),
                  'Fold Change'
                ),
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup' },
                  (0, _preact.h)('input', {
                    type: 'radio',
                    name: 'reactionCompare',
                    onClick: function onClick() {
                      return settings.set('reaction_compare_style', 'log2_fold');
                    },
                    checked: settings.get('reaction_compare_style') === 'log2_fold',
                    disabled: dataStatistics.reaction === null
                  }),
                  'Log2 (Fold Change)'
                ),
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup' },
                  (0, _preact.h)('input', {
                    type: 'radio',
                    name: 'reactionCompare',
                    onClick: function onClick() {
                      return settings.set('reaction_compare_style', 'diff');
                    },
                    checked: settings.get('reaction_compare_style') === 'diff',
                    disabled: dataStatistics.reaction === null
                  }),
                  'Difference'
                )
              )
            )
          ),
          (0, _preact.h)(
            'table',
            { className: 'radioSelection' },
            (0, _preact.h)(
              'tr',
              {
                title: 'The function that will be used to evaluate AND connections in gene reaction rules (AND connections generally connect components of an enzyme complex)'
              },
              (0, _preact.h)(
                'td',
                { className: 'optionLabelWide' },
                'Method for evaluating AND:'
              ),
              (0, _preact.h)(
                'td',
                null,
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup' },
                  (0, _preact.h)('input', {
                    type: 'radio',
                    name: 'andMethod',
                    onClick: function onClick() {
                      return settings.set('and_method_in_gene_reaction_rule', 'mean');
                    },
                    checked: settings.get('and_method_in_gene_reaction_rule') === 'mean',
                    disabled: dataStatistics.reaction === null
                  }),
                  'Mean'
                ),
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup' },
                  (0, _preact.h)('input', {
                    type: 'radio',
                    name: 'andMethod',
                    onClick: function onClick() {
                      return settings.set('and_method_in_gene_reaction_rule', 'min');
                    },
                    checked: settings.get('and_method_in_gene_reaction_rule') === 'min',
                    disabled: dataStatistics.reaction === null
                  }),
                  'Min'
                )
              )
            )
          ),
          (0, _preact.h)('hr', null),
          (0, _preact.h)(
            'div',
            { className: 'scaleTitle' },
            (0, _preact.h)(
              'div',
              { className: 'title' },
              'Metabolites'
            ),
            (0, _preact.h)(
              _ScaleSelector2.default,
              { disabled: dataStatistics.metabolite === null },
              Object.values(_underscore2.default.mapObject(_scalePresets2.default, function (value, key) {
                return (0, _preact.h)(_ScaleSelection2.default, {
                  name: key,
                  scale: value,
                  onClick: function onClick() {
                    return settings.set('metabolite_scale', value);
                  }
                });
              }))
            )
          ),
          (0, _preact.h)(_ScaleSlider2.default, {
            scale: settings.get('metabolite_scale'),
            settings: settings,
            type: 'Metabolite',
            stats: dataStatistics.metabolite,
            noDataColor: settings.get('metabolite_no_data_color'),
            noDataSize: settings.get('metabolite_no_data_size'),
            onChange: function onChange(scale) {
              settings.set('metabolite_scale', scale);
            },
            onNoDataColorChange: function onNoDataColorChange(val) {
              settings.set('metabolite_no_data_color', val);
            },
            onNoDataSizeChange: function onNoDataSizeChange(val) {
              settings.set('metabolite_no_data_size', val);
            },
            abs: _underscore2.default.contains(settings.get('metabolite_styles'), 'abs')
          }),
          (0, _preact.h)(
            'div',
            { className: 'subheading' },
            'Metabolite data'
          ),
          (0, _preact.h)(
            'table',
            { className: 'radioSelection' },
            (0, _preact.h)(
              'tr',
              null,
              (0, _preact.h)(
                'td',
                {
                  className: 'optionLabel',
                  title: 'Options for metabolite data'
                },
                'Options:'
              ),
              (0, _preact.h)(
                'td',
                null,
                (0, _preact.h)(
                  'label',
                  {
                    className: 'optionGroup',
                    title: 'If checked, use the absolute value when calculating colors and sizes of metabolites on the map'
                  },
                  (0, _preact.h)('input', {
                    type: 'checkbox',
                    name: 'metaboliteStyle',
                    onClick: function onClick() {
                      return _this3.handleStyle('abs', 'metabolite_styles');
                    },
                    checked: _underscore2.default.contains(settings.get('metabolite_styles'), 'abs'),
                    disabled: dataStatistics.metabolite === null
                  }),
                  'Absolute value'
                ),
                (0, _preact.h)(
                  'label',
                  {
                    className: 'optionGroup',
                    title: 'If checked, then size the thickness of reaction lines according to the value of the metabolite data'
                  },
                  (0, _preact.h)('input', {
                    type: 'checkbox',
                    name: 'metaboliteStyle',
                    onClick: function onClick() {
                      return _this3.handleStyle('size', 'metabolite_styles');
                    },
                    checked: _underscore2.default.contains(settings.get('metabolite_styles'), 'size'),
                    disabled: dataStatistics.metabolite === null
                  }),
                  'Size'
                ),
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup', title: 'If checked, then color the reaction lines according to the value of the metabolite data' },
                  (0, _preact.h)('input', {
                    type: 'checkbox',
                    name: 'metaboliteStyle',
                    onClick: function onClick() {
                      return _this3.handleStyle('color', 'metabolite_styles');
                    },
                    checked: _underscore2.default.contains(settings.get('metabolite_styles'), 'color'),
                    disabled: dataStatistics.metabolite === null
                  }),
                  'Color'
                ),
                (0, _preact.h)('br', null),
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup', title: 'If checked, then show data values in the metabolite labels' },
                  (0, _preact.h)('input', {
                    type: 'checkbox',
                    name: 'metaboliteStyle',
                    onClick: function onClick() {
                      return _this3.handleStyle('text', 'metabolite_styles');
                    },
                    checked: _underscore2.default.contains(settings.get('metabolite_styles'), 'text'),
                    disabled: dataStatistics.metabolite === null
                  }),
                  'Text (Show data in label)'
                )
              )
            ),
            (0, _preact.h)(
              'tr',
              { title: 'The function that will be used to compare datasets, when paired data is loaded' },
              (0, _preact.h)(
                'td',
                { className: 'optionLabel' },
                'Comparison:'
              ),
              (0, _preact.h)(
                'td',
                null,
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup' },
                  (0, _preact.h)('input', {
                    type: 'radio',
                    name: 'metaboliteCompare',
                    onClick: function onClick() {
                      return settings.set('metabolite_compare_style', 'fold');
                    },
                    checked: settings.get('metabolite_compare_style') === 'fold',
                    disabled: dataStatistics.metabolite === null
                  }),
                  'Fold Change'
                ),
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup' },
                  (0, _preact.h)('input', {
                    type: 'radio',
                    name: 'metaboliteCompare',
                    onClick: function onClick() {
                      return settings.set('metabolite_compare_style', 'log2_fold');
                    },
                    checked: settings.get('metabolite_compare_style') === 'log2_fold',
                    disabled: dataStatistics.metabolite === null
                  }),
                  'Log2 (Fold Change)'
                ),
                (0, _preact.h)(
                  'label',
                  { className: 'optionGroup' },
                  (0, _preact.h)('input', {
                    type: 'radio',
                    name: 'metaboliteCompare',
                    onClick: function onClick() {
                      return settings.set('metabolite_compare_style', 'diff');
                    },
                    checked: settings.get('metabolite_compare_style') === 'diff',
                    disabled: dataStatistics.metabolite === null
                  }),
                  'Difference'
                )
              )
            )
          )
        )
      )
    );
  };

  return SettingsMenu;
}(_preact.Component);

exports.default = SettingsMenu;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */

var ScaleSelector = function (_Component) {
  _inherits(ScaleSelector, _Component);

  function ScaleSelector(props) {
    _classCallCheck(this, ScaleSelector);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.setWrapperRef = _this.setWrapperRef.bind(_this);
    _this.handleClickOutside = _this.handleClickOutside.bind(_this);
    _this.state = {
      visible: false
    };
    return _this;
  }

  ScaleSelector.prototype.componentDidMount = function componentDidMount() {
    document.addEventListener('mouseup', this.handleClickOutside);
  };

  // Reference for hiding the menu when a mouse event happens outside


  ScaleSelector.prototype.setWrapperRef = function setWrapperRef(node) {
    this.wrapperRef = node;
  };

  ScaleSelector.prototype.handleClickOutside = function handleClickOutside(event) {
    if (this.wrapperRef && !this.wrapperRef.contains(event.target)) {
      this.setState({ visible: false });
    }
  };

  ScaleSelector.prototype.render = function render() {
    var _this2 = this;

    return (0, _preact.h)(
      'div',
      { className: 'selector' },
      (0, _preact.h)(
        'div',
        {
          className: ['selectorTitle', this.props.disabled ? 'disabled' : ''].join(' '),
          ref: this.setWrapperRef,
          onClick: function onClick() {
            if (!_this2.props.disabled) {
              _this2.setState({ visible: !_this2.state.visible });
            }
          }
        },
        'Preset Scale Selections',
        (0, _preact.h)('i', { className: 'icon-sort-down' })
      ),
      (0, _preact.h)(
        'div',
        {
          className: 'selectorMenu',
          style: this.state.visible ? { display: 'block' } : { display: 'none' }
        },
        this.props.children.map(function (listItem) {
          return listItem;
        })
      )
    );
  };

  return ScaleSelector;
}(_preact.Component);

exports.default = ScaleSelector;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

var _Picker = __webpack_require__(72);

var _Picker2 = _interopRequireDefault(_Picker);

var _immutabilityHelper = __webpack_require__(76);

var _immutabilityHelper2 = _interopRequireDefault(_immutabilityHelper);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

__webpack_require__(78);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */

var TRACK_WIDTH = 400;

var ScaleSlider = function (_Component) {
  _inherits(ScaleSlider, _Component);

  function ScaleSlider() {
    _classCallCheck(this, ScaleSlider);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Sorts the color scale for makeGradient
   */
  ScaleSlider.prototype.sortScale = function sortScale() {
    var _this2 = this;

    var newScale = _underscore2.default.sortBy(this.props.scale, function (stop) {
      if (stop.type === 'value') {
        return stop.value;
      } else {
        return _this2.props.stats[stop.type];
      }
    });
    return newScale;
  };

  /**
   * Places the pickers as a percentage of the max
   */


  ScaleSlider.prototype.placePickers = function placePickers() {
    var stats = this.props.stats;

    // Get min and max from scale stops too

    var _props$scale$reduce = this.props.scale.reduce(function (_ref, stop) {
      var curMin = _ref[0],
          curMax = _ref[1];

      if (stop.type === 'value') {
        return [Math.min(stop.value, curMin), Math.max(stop.value, curMax)];
      } else {
        return [curMin, curMax];
      }
    }, [stats.min, stats.max]),
        absoluteMin = _props$scale$reduce[0],
        absoluteMax = _props$scale$reduce[1];

    // Calculate positions


    var pickerLocations = this.props.scale.map(function (stop) {
      var value = stop.type === 'value' ? stop.value : stats[stop.type];
      // normalize within min/max
      return (value - absoluteMin) / (absoluteMax - absoluteMin);
    });

    return { pickerLocations: pickerLocations, absoluteMax: absoluteMax, absoluteMin: absoluteMin };
  };

  /**
   * Function enabling modification of any color scale attribute
   * @param {number} index - index of the scale object to be modified
   * @param {string} parameter - the parameter to be replaced
   * @param {(number|string)} value - the new value of the parameter
   */


  ScaleSlider.prototype.scaleChange = function scaleChange(index, parameter, value) {
    var newScale = null;
    if (parameter === 'type' && value !== 'value') {
      var _index, _update;

      newScale = (0, _immutabilityHelper2.default)(this.props.scale, (_update = {}, _update[index] = (_index = {}, _index[parameter] = { $set: value }, _index.$unset = ['value'], _index), _update));
      this.props.onChange(newScale);
    } else if (parameter === 'value' && this.props.scale[index].type !== 'value') {
      var _index2, _update2;

      newScale = (0, _immutabilityHelper2.default)(this.props.scale, (_update2 = {}, _update2[index] = (_index2 = {}, _index2[parameter] = { $set: value }, _index2['type'] = { $set: 'value' }, _index2), _update2));
      this.props.onChange(newScale);
    } else if (value === 'value') {
      var _index3, _update3;

      newScale = (0, _immutabilityHelper2.default)(this.props.scale, (_update3 = {}, _update3[index] = (_index3 = {}, _index3[parameter] = { $set: value }, _index3.$merge = { 'value': this.props.stats[this.props.scale[index].type] }, _index3), _update3));
      this.props.onChange(newScale);
    } else if (!isNaN(parseFloat(value)) || value[0] === '#' && parameter === 'color') {
      var _index4, _update4;

      newScale = (0, _immutabilityHelper2.default)(this.props.scale, (_update4 = {}, _update4[index] = (_index4 = {}, _index4[parameter] = { $set: value }, _index4), _update4));
      this.props.onChange(newScale);
    }
  };

  ScaleSlider.prototype.addColorStop = function addColorStop(event) {
    var newScale = (0, _immutabilityHelper2.default)(this.props.scale, {
      $push: [{
        type: 'value',
        value: event.layerX / event.target.clientWidth * this.props.stats.max + (1 - event.layerX / event.target.clientWidth) * this.props.stats.min,
        color: '#9696ff',
        size: 20
      }]
    });
    this.props.onChange(newScale);
  };

  /**
   * Sorts and then returns a string that can be fed into the HTML linear-gradient style
   */


  ScaleSlider.prototype.makeGradient = function makeGradient(min, max) {
    var _this3 = this;

    var sortedScale = this.sortScale();
    // Fix for when there is one or zero stops
    var sortedScaleFix = sortedScale.length < 2 ? [{ type: 'min', color: '#f1ecfa' }, { type: 'max', color: '#f1ecfa' }] : sortedScale;
    return sortedScaleFix.map(function (stop) {
      var value = stop.type === 'value' ? stop.value : _this3.props.stats[stop.type];
      return ' ' + stop.color + ' ' + (value - min) / (max - min) * 100 + '%';
    }).toString();
  };

  ScaleSlider.prototype.removeColorStop = function removeColorStop(index) {
    var newScale = (0, _immutabilityHelper2.default)(this.props.scale, { $splice: [[[index], 1]] });
    this.props.onChange(newScale);
  };

  ScaleSlider.prototype.render = function render() {
    var _this4 = this;

    // -------
    // No data
    // -------

    // Check for data
    if (!this.props.stats) {
      return (0, _preact.h)(
        'div',
        { className: 'scaleEditor' },
        (0, _preact.h)(
          'div',
          null,
          (0, _preact.h)(
            'div',
            {
              className: 'scaleTrack disabled',
              style: { width: TRACK_WIDTH }
            },
            this.props.type,
            ' data not loaded',
            (0, _preact.h)(_Picker2.default, { location: 0, trackWidth: TRACK_WIDTH, disabled: true }),
            (0, _preact.h)(_Picker2.default, { location: 1, trackWidth: TRACK_WIDTH, disabled: true })
          )
        ),
        (0, _preact.h)(
          'div',
          { className: 'scaleLabels' },
          (0, _preact.h)(
            'label',
            null,
            'Value:'
          ),
          (0, _preact.h)(
            'label',
            null,
            'Color:'
          ),
          (0, _preact.h)(
            'label',
            null,
            'Size:'
          )
        ),
        (0, _preact.h)(
          'div',
          { className: 'noDataStyle' },
          (0, _preact.h)(
            'label',
            { className: 'styleHeader' },
            'Styles for reactions with no data'
          ),
          (0, _preact.h)('br', null),
          (0, _preact.h)(
            'label',
            null,
            'Color:'
          ),
          (0, _preact.h)('input', { type: 'text', className: 'colorInput', disabled: true }),
          (0, _preact.h)('input', { type: 'color', className: 'colorWheel', disabled: true }),
          (0, _preact.h)(
            'label',
            null,
            'Size:'
          ),
          (0, _preact.h)('input', { type: 'text', className: 'sizeInput', disabled: true })
        )
      );
    }

    // --------
    // Has data
    // --------

    var _placePickers = this.placePickers(),
        pickerLocations = _placePickers.pickerLocations,
        absoluteMax = _placePickers.absoluteMax,
        absoluteMin = _placePickers.absoluteMin;

    // Create the pickers


    var pickers = this.props.scale.map(function (stop, i) {
      if (stop.type !== 'value') {
        return (0, _preact.h)(_Picker2.default, {
          trackWidth: TRACK_WIDTH,
          type: stop.type,
          location: pickerLocations[i],
          onChange: function onChange(parameter, value) {
            return _this4.scaleChange(i, parameter, value);
          },
          focus: function focus() {
            return _this4.setState({ focusedPicker: i });
          },
          remove: function remove() {
            return _this4.removeColorStop(i);
          },
          min: absoluteMin,
          max: absoluteMax,
          value: _this4.props.stats[stop.type],
          color: stop.color,
          size: stop.size,
          zIndex: _this4.state.focusedPicker === i ? '2' : '0',
          showTrash: _this4.props.scale.length >= 3
        });
      } else if (stop.value != null) {
        // Check for valid value type
        return (0, _preact.h)(_Picker2.default, {
          trackWidth: TRACK_WIDTH,
          type: stop.type,
          location: pickerLocations[i],
          onChange: function onChange(parameter, value) {
            return _this4.scaleChange(i, parameter, value);
          },
          focus: function focus() {
            return _this4.setState({ focusedPicker: i });
          },
          remove: function remove() {
            return _this4.removeColorStop(i);
          },
          min: absoluteMin,
          max: absoluteMax,
          value: stop.value,
          color: stop.color,
          size: stop.size,
          zIndex: _this4.state.focusedPicker === i ? '2' : '0',
          showTrash: _this4.props.scale.length >= 3
        });
      }
    });

    // Render everything
    return (0, _preact.h)(
      'div',
      { className: 'scaleEditor' },
      (0, _preact.h)(
        'div',
        null,
        (0, _preact.h)(
          'i',
          { className: 'settingsTip' },
          'To add a color stop to the scale, click the gradient'
        ),
        (0, _preact.h)(
          'div',
          {
            className: 'scaleTrack',
            style: { width: TRACK_WIDTH }
          },
          (0, _preact.h)('div', {
            className: 'gradient',
            onClick: function onClick(event) {
              return _this4.addColorStop(event);
            },
            style: {
              background: 'linear-gradient(to right,' + this.makeGradient(absoluteMin, absoluteMax) + ')'
            }
          }),
          pickers
        )
      ),
      (0, _preact.h)(
        'div',
        { className: 'scaleLabels' },
        (0, _preact.h)(
          'label',
          null,
          'Value:'
        ),
        (0, _preact.h)(
          'label',
          null,
          'Color:'
        ),
        (0, _preact.h)(
          'label',
          null,
          'Size:'
        )
      ),
      (0, _preact.h)(
        'div',
        { className: 'noDataStyle' },
        (0, _preact.h)(
          'label',
          { className: 'styleHeader' },
          'Styles for reactions with no data'
        ),
        (0, _preact.h)('br', null),
        (0, _preact.h)(
          'label',
          null,
          'Color:'
        ),
        (0, _preact.h)('input', {
          type: 'text',
          className: 'colorInput',
          value: this.props.noDataColor,
          onInput: function onInput(event) {
            return _this4.props.onNoDataColorChange(event.target.value);
          }
        }),
        (0, _preact.h)('input', {
          type: 'color',
          className: 'colorWheel',
          value: this.props.noDataColor,
          onInput: function onInput(event) {
            return _this4.props.onNoDataColorChange(event.target.value);
          }
        }),
        (0, _preact.h)(
          'label',
          null,
          'Size:'
        ),
        (0, _preact.h)('input', {
          type: 'text',
          className: 'sizeInput',
          value: this.props.noDataSize,
          onInput: function onInput(event) {
            return _this4.props.onNoDataSizeChange(parseFloat(event.target.value));
          }
        })
      )
    );
  };

  return ScaleSlider;
}(_preact.Component);

exports.default = ScaleSlider;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

var _d3Selection = __webpack_require__(2);

var _d3Drag = __webpack_require__(22);

__webpack_require__(73);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */

var Picker = function (_Component) {
  _inherits(Picker, _Component);

  function Picker() {
    _classCallCheck(this, Picker);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  Picker.prototype.setUpDrag = function setUpDrag() {
    var _this2 = this;

    // Double check that the drag is not left over from a previous use of this
    // node.
    (0, _d3Selection.select)(this.base).select('.pickerBox').on('mousedown.drag', null);

    if (!this.props.disabled) {
      var drag = (0, _d3Drag.drag)().on('start', function () {
        if (_this2.props.focus) _this2.props.focus();
      }).on('drag', function () {
        // If it was not a value slider before, make it one
        if (_this2.props.type !== 'value') {
          if (_this2.props.onChange) _this2.props.onChange('type', 'value');
        }

        // New location
        var newValue = _this2.props.value + _d3Selection.event.dx / _this2.props.trackWidth * (_this2.props.max - _this2.props.min);

        // Don't go outside bar
        var newLimValue = Math.max(_this2.props.min, Math.min(_this2.props.max, newValue));

        _this2.props.onChange('value', newLimValue);
      }).container(function () {
        return _this2.base.parentNode.parentNode;
      });
      (0, _d3Selection.select)(this.base).select('.pickerBox').call(drag);
    }
  };

  Picker.prototype.componentDidUpdate = function componentDidUpdate() {
    this.setUpDrag();
  };

  Picker.prototype.componentDidMount = function componentDidMount() {
    this.setUpDrag();
  };

  Picker.prototype.render = function render() {
    var _this3 = this;

    return (0, _preact.h)(
      'div',
      {
        className: 'picker',
        style: {
          left: this.props.location * this.props.trackWidth + 'px',
          zIndex: this.props.zIndex
        }
      },
      this.props.showTrash && (0, _preact.h)(
        'div',
        { className: 'trashDiv' },
        (0, _preact.h)('i', {
          className: 'icon-trash-empty',
          'aria-hidden': 'true',
          onClick: function onClick() {
            if (_this3.props.remove) _this3.props.remove();
          }
        })
      ),
      (0, _preact.h)('div', {
        className: 'pickerBox',
        onClick: function onClick() {
          if (_this3.props.focus) _this3.props.focus();
        }
      }),
      (0, _preact.h)(
        'div',
        {
          className: ['pickerOptions', this.props.location > 0.8 ? 'rightOptions' : ''].join(' ')
        },
        (0, _preact.h)('input', {
          type: 'text',
          className: 'option',
          value: this.props.disabled ? '' : this.props.type === 'value' ? parseFloat(this.props.value.toFixed(2)) : this.props.type + ' (' + parseFloat(this.props.value.toFixed(2)) + ')',
          disabled: this.props.disabled,
          onInput: function onInput(event) {
            var newVal = parseFloat(event.target.value);
            if (!isNaN(newVal)) _this3.props.onChange('value', newVal);
          },
          onFocus: function onFocus(event) {
            event.target.select();
            if (_this3.props.focus) _this3.props.focus();
          }
        }),
        (0, _preact.h)(
          'select',
          {
            className: 'typePicker',
            value: this.props.type,
            onChange: function onChange(event) {
              if (_this3.props.onChange) _this3.props.onChange('type', event.target.value);
            },
            disabled: this.props.disabled,
            onFocus: function onFocus(event) {
              if (_this3.props.focus) _this3.props.focus();
            }
          },
          (0, _preact.h)(
            'option',
            { value: 'value' },
            'Value'
          ),
          (0, _preact.h)(
            'option',
            { value: 'min' },
            'Min'
          ),
          (0, _preact.h)(
            'option',
            { value: 'mean' },
            'Mean'
          ),
          (0, _preact.h)(
            'option',
            { value: 'Q1' },
            'Q1'
          ),
          (0, _preact.h)(
            'option',
            { value: 'median' },
            'Median'
          ),
          (0, _preact.h)(
            'option',
            { value: 'Q3' },
            'Q3'
          ),
          (0, _preact.h)(
            'option',
            { value: 'max' },
            'Max'
          )
        ),
        (0, _preact.h)(
          'div',
          { className: 'colorOptions' },
          (0, _preact.h)('input', {
            type: 'text',
            className: 'colorText',
            onInput: function onInput(event) {
              if (_this3.props.onChange) _this3.props.onChange('color', event.target.value);
            },
            onFocus: function onFocus(event) {
              event.target.select();
              if (_this3.props.focus) _this3.props.focus();
            },
            value: this.props.color || '',
            disabled: this.props.disabled
          }),
          (0, _preact.h)('input', {
            type: 'color',
            className: 'colorWheel',
            onInput: function onInput(event) {
              if (_this3.props.onChange) _this3.props.onChange('color', event.target.value);
            },
            onFocus: function onFocus(event) {
              event.target.select();
              if (_this3.props.focus) _this3.props.focus();
            },
            value: this.props.color || '',
            disabled: this.props.disabled
          })
        ),
        (0, _preact.h)('input', {
          type: 'text',
          className: 'option',
          onInput: function onInput(event) {
            if (_this3.props.onChange) _this3.props.onChange('size', parseInt(event.target.value));
          },
          onFocus: function onFocus(event) {
            event.target.select();
            if (_this3.props.focus) _this3.props.focus();
          },
          value: this.props.size,
          disabled: this.props.disabled
        })
      )
    );
  };

  return Picker;
}(_preact.Component);

exports.default = Picker;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(74);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(13)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(12);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".escher-container .picker {\n  top: 35px;\n  margin-left: -7px;\n  position: absolute;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.escher-container .pickerBox {\n  position: absolute;\n  cursor: pointer;\n  background: rgba(0, 0, 0, 0.375);\n  width: 14px;\n  height: 35px;\n  top: -35px\n}\n\n.escher-container .scaleTrack .rightOptions {\n  position: absolute;\n  left: -76px;\n}\n\n.escher-container .pickerOptions {\n  box-shadow: 0 2px 14px #c5c5c5;\n  margin-top: 1px;\n  display: inline-flex;\n  flex-direction: column;\n  width: 90px;\n}\n\n.escher-container .pickerOptions * {\n  font-size: 12px;\n}\n\n.escher-container .pickerOptions .option {\n  padding: 3px 0px;\n}\n\n.escher-container .pickerOptions .typePicker {\n  width: 20px;\n  position: absolute;\n  left: 70px;\n  top: 1px;\n  right: 0px;\n  height: 14px;\n  background-color: rgb(232, 232, 232);\n}\n\n.escher-container .pickerOptions .colorOptions {\n  display: inline-flex;\n}\n\n.escher-container .colorOptions .colorText {\n  padding: 3px 0px;\n  width: 100%;\n}\n\n.escher-container .colorOptions .colorWheel {\n  padding: 0px;\n  position: absolute;\n  right: 0;\n  height: 24px;\n  width: 21px;\n  border: 1px solid black;\n}\n\n.escher-container .picker .trashDiv {\n  position: absolute;\n  top: -56px;\n  font-size: 17px;\n}\n\n.escher-container .picker .trashDiv * {\n  font-size: 17px;\n  cursor: pointer;\n}\n\n.escher-container .picker .icon-trash-empty {\n  margin: -5px;\n}\n\n.escher-container .scaleEditor :disabled {\n  background: #f1ecfa;\n}\n\n.escher-container .scaleEditor input[type=color]:disabled {\n  margin-top: 1px;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 75 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var invariant = __webpack_require__(77);

var hasOwnProperty = Object.prototype.hasOwnProperty;
var splice = Array.prototype.splice;

var toString = Object.prototype.toString
var type = function(obj) {
  return toString.call(obj).slice(8, -1);
}

var assign = Object.assign || /* istanbul ignore next */ function assign(target, source) {
  getAllKeys(source).forEach(function(key) {
    if (hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  });
  return target;
};

var getAllKeys = typeof Object.getOwnPropertySymbols === 'function' ?
  function(obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)) } :
  /* istanbul ignore next */ function(obj) { return Object.keys(obj) };

/* istanbul ignore next */
function copy(object) {
  if (Array.isArray(object)) {
    return assign(object.constructor(object.length), object)
  } else if (type(object) === 'Map') {
    return new Map(object)
  } else if (type(object) === 'Set') {
    return new Set(object)
  } else if (object && typeof object === 'object') {
    var prototype = Object.getPrototypeOf(object);
    return assign(Object.create(prototype), object);
  } else {
    return object;
  }
}

function newContext() {
  var commands = assign({}, defaultCommands);
  update.extend = function(directive, fn) {
    commands[directive] = fn;
  };
  update.isEquals = function(a, b) { return a === b; };

  return update;

  function update(object, spec) {
    if (typeof spec === 'function') {
      spec = { $apply: spec };
    }

    if (!(Array.isArray(object) && Array.isArray(spec))) {
      invariant(
        !Array.isArray(spec),
        'update(): You provided an invalid spec to update(). The spec may ' +
        'not contain an array except as the value of $set, $push, $unshift, ' +
        '$splice or any custom command allowing an array value.'
      );
    }

    invariant(
      typeof spec === 'object' && spec !== null,
      'update(): You provided an invalid spec to update(). The spec and ' +
      'every included key path must be plain objects containing one of the ' +
      'following commands: %s.',
      Object.keys(commands).join(', ')
    );

    var nextObject = object;
    var index, key;
    getAllKeys(spec).forEach(function(key) {
      if (hasOwnProperty.call(commands, key)) {
        var objectWasNextObject = object === nextObject;
        nextObject = commands[key](spec[key], nextObject, spec, object);
        if (objectWasNextObject && update.isEquals(nextObject, object)) {
          nextObject = object;
        }
      } else {
        var nextValueForKey =
          type(object) === 'Map'
            ? update(object.get(key), spec[key])
            : update(object[key], spec[key]);
        var nextObjectValue =
          type(nextObject) === 'Map'
              ? nextObject.get(key)
              : nextObject[key];
        if (!update.isEquals(nextValueForKey, nextObjectValue) || typeof nextValueForKey === 'undefined' && !hasOwnProperty.call(object, key)) {
          if (nextObject === object) {
            nextObject = copy(object);
          }
          if (type(nextObject) === 'Map') {
            nextObject.set(key, nextValueForKey);
          } else {
            nextObject[key] = nextValueForKey;
          }
        }
      }
    })
    return nextObject;
  }

}

var defaultCommands = {
  $push: function(value, nextObject, spec) {
    invariantPushAndUnshift(nextObject, spec, '$push');
    return value.length ? nextObject.concat(value) : nextObject;
  },
  $unshift: function(value, nextObject, spec) {
    invariantPushAndUnshift(nextObject, spec, '$unshift');
    return value.length ? value.concat(nextObject) : nextObject;
  },
  $splice: function(value, nextObject, spec, originalObject) {
    invariantSplices(nextObject, spec);
    value.forEach(function(args) {
      invariantSplice(args);
      if (nextObject === originalObject && args.length) nextObject = copy(originalObject);
      splice.apply(nextObject, args);
    });
    return nextObject;
  },
  $set: function(value, nextObject, spec) {
    invariantSet(spec);
    return value;
  },
  $toggle: function(targets, nextObject) {
    invariantSpecArray(targets, '$toggle');
    var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;

    targets.forEach(function(target) {
      nextObjectCopy[target] = !nextObject[target];
    });

    return nextObjectCopy;
  },
  $unset: function(value, nextObject, spec, originalObject) {
    invariantSpecArray(value, '$unset');
    value.forEach(function(key) {
      if (Object.hasOwnProperty.call(nextObject, key)) {
        if (nextObject === originalObject) nextObject = copy(originalObject);
        delete nextObject[key];
      }
    });
    return nextObject;
  },
  $add: function(value, nextObject, spec, originalObject) {
    invariantMapOrSet(nextObject, '$add');
    invariantSpecArray(value, '$add');
    if (type(nextObject) === 'Map') {
      value.forEach(function(pair) {
        var key = pair[0];
        var value = pair[1];
        if (nextObject === originalObject && nextObject.get(key) !== value) nextObject = copy(originalObject);
        nextObject.set(key, value);
      });
    } else {
      value.forEach(function(value) {
        if (nextObject === originalObject && !nextObject.has(value)) nextObject = copy(originalObject);
        nextObject.add(value);
      });
    }
    return nextObject;
  },
  $remove: function(value, nextObject, spec, originalObject) {
    invariantMapOrSet(nextObject, '$remove');
    invariantSpecArray(value, '$remove');
    value.forEach(function(key) {
      if (nextObject === originalObject && nextObject.has(key)) nextObject = copy(originalObject);
      nextObject.delete(key);
    });
    return nextObject;
  },
  $merge: function(value, nextObject, spec, originalObject) {
    invariantMerge(nextObject, value);
    getAllKeys(value).forEach(function(key) {
      if (value[key] !== nextObject[key]) {
        if (nextObject === originalObject) nextObject = copy(originalObject);
        nextObject[key] = value[key];
      }
    });
    return nextObject;
  },
  $apply: function(value, original) {
    invariantApply(value);
    return value(original);
  }
};

var contextForExport = newContext();

module.exports = contextForExport;
module.exports.default = contextForExport;
module.exports.newContext = newContext;

// invariants

function invariantPushAndUnshift(value, spec, command) {
  invariant(
    Array.isArray(value),
    'update(): expected target of %s to be an array; got %s.',
    command,
    value
  );
  invariantSpecArray(spec[command], command)
}

function invariantSpecArray(spec, command) {
  invariant(
    Array.isArray(spec),
    'update(): expected spec of %s to be an array; got %s. ' +
    'Did you forget to wrap your parameter in an array?',
    command,
    spec
  );
}

function invariantSplices(value, spec) {
  invariant(
    Array.isArray(value),
    'Expected $splice target to be an array; got %s',
    value
  );
  invariantSplice(spec['$splice']);
}

function invariantSplice(value) {
  invariant(
    Array.isArray(value),
    'update(): expected spec of $splice to be an array of arrays; got %s. ' +
    'Did you forget to wrap your parameters in an array?',
    value
  );
}

function invariantApply(fn) {
  invariant(
    typeof fn === 'function',
    'update(): expected spec of $apply to be a function; got %s.',
    fn
  );
}

function invariantSet(spec) {
  invariant(
    Object.keys(spec).length === 1,
    'Cannot have more than one key in an object with $set'
  );
}

function invariantMerge(target, specValue) {
  invariant(
    specValue && typeof specValue === 'object',
    'update(): $merge expects a spec of type \'object\'; got %s',
    specValue
  );
  invariant(
    target && typeof target === 'object',
    'update(): $merge expects a target of type \'object\'; got %s',
    target
  );
}

function invariantMapOrSet(target, command) {
  var typeOfTarget = type(target);
  invariant(
    typeOfTarget === 'Map' || typeOfTarget === 'Set',
    'update(): %s expects a target of type Set or Map; got %s',
    command,
    typeOfTarget
  );
}


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {}

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(79);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(13)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(12);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".escher-container .scaleEditor * {\n  font-size: 12px;\n  color: #777;\n  box-sizing: border-box;\n}\n\n.escher-container .scaleEditor {\n  position: relative;\n  display: flex;\n  justify-content: center;\n  flex-direction: column;\n}\n\n.escher-container .scaleTrack {\n  position: relative;\n  display: flex;\n  height: 30px;\n  margin-bottom: 9px;\n  margin-top: 30px;\n  margin-left: 55px;\n  font-size: 15px;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.escher-container .scaleTrack.disabled {\n  background: #f1ecfa;\n  color: #b19ec0;\n  padding: 4px 0;\n  justify-content: center;\n}\n\n.escher-container .gradient {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n}\n\n.escher-container .scaleLabels {\n  display: inline-flex;\n  flex-direction: column;\n  font-size: 12px;\n}\n\n.escher-container .scaleLabels label {\n  margin-bottom: 6px;\n}\n\n.escher-container .noDataStyle {\n  position: relative;\n  margin-top: 20px;\n}\n\n.escher-container .noDataStyle .styleHeader {\n  font-size: 12px;\n  font-weight: bold;\n}\n\n.escher-container .noDataStyle label {\n  margin-right: 5px;\n}\n\n.escher-container .noDataStyle input[type=text] {\n  margin-right: 10px;\n  padding: 3px 0px;\n  width: 86px;\n}\n\n.escher-container .noDataStyle input[type=color] {\n  position: absolute;\n  padding: 0px;\n  border: 1px solid black;\n  left: 103px;\n  height: 24px;\n  width: 21px;\n}\n\n.escher-container .scaleEditor .icon-plus {\n  cursor: pointer;\n  position: absolute;\n  font-size: 14px;\n  right: 19px;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */


var ScaleSelection = function (_Component) {
  _inherits(ScaleSelection, _Component);

  function ScaleSelection(props) {
    _classCallCheck(this, ScaleSelection);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    var colors = [];
    if (props.scale) {
      for (var i = 0; i < props.scale.length; i++) {
        colors.push(props.scale[i].color);
      }
    }
    _this.state = {
      colors: colors
    };
    return _this;
  }

  ScaleSelection.prototype.render = function render() {
    var _this2 = this;

    return (0, _preact.h)(
      'div',
      { className: 'scaleSelection', onClick: function onClick() {
          return _this2.props.onClick();
        } },
      (0, _preact.h)(
        'div',
        null,
        this.props.name
      ),
      (0, _preact.h)(
        'div',
        { className: 'scaleColors' },
        this.state.colors.map(function (color) {
          return (0, _preact.h)('i', { className: 'icon-blank', style: { color: color } });
        })
      )
    );
  };

  return ScaleSelection;
}(_preact.Component);

exports.default = ScaleSelection;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(82);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(13)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(12);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".escher-container .settingsBackground {\n  box-sizing: border-box;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 9;\n  background: rgba(0,0,0,.4);\n  padding: 5% 0 80px;\n  text-align: center;\n}\n\n.escher-container .scale-editor .domain-input {\n  color: #333;\n}\n\n.escher-container .settingsBoxContainer button {\n  position: absolute;\n  top: 5px;\n  right: 20px;\n  z-index: 10;\n  text-align: center;\n  vertical-align: middle;\n  font-weight: normal!important;\n  width: 34px;\n  height: 30px;\n  margin: 0;\n  padding: unset;\n  font-size: 14px!important;\n  border-radius: 3px;\n  -ms-touch-action: none;\n  touch-action: none;\n}\n\n.escher-container .settingsBoxContainer button:active {\n  background-image: linear-gradient(#3F4141, #474949 6%, #4F5151);\n}\n\n.escher-container .settingsBoxContainer .discardChanges {\n  right: 60px;\n}\n\n.escher-container .settingsBoxContainer {\n  color: rgb(119, 119, 119);\n  display: inline-block;\n  position: relative;\n  width: 90%;\n  max-width: 520px;\n  height: 100%;\n  z-index: 10;\n}\n\n.escher-container .settingsBox {\n  font-size: 13px;\n  box-sizing: border-box;\n  display: inline-block;\n  max-height: 100%;\n  width: 100%;\n  overflow-y: scroll;\n  overflow-x: hidden;\n  background: rgba(255, 255, 255, 0.953);\n  padding: 8px;\n  margin: 0;\n  border: 1px solid #ddd;\n  text-align: left;\n}\n\n.escher-container .settingsBox * {\n  box-sizing: border-box;\n}\n\n.escher-container .settingsBox .title {\n  font-size: 17px;\n  font-weight: 700;\n  color: #777777;\n}\n\n.escher-container .settingsBox .subheading {\n  font-size: 13px;\n  font-weight: 700;\n  margin-top: 15px;\n  color: #777777;\n}\n\n.escher-container .settingsBox table {\n  border-collapse: collapse;\n}\n\n.escher-container .settingsBox label {\n  display: inline;\n}\n\n.escher-container .settingsBox .radioSelection {\n  cursor: default;\n}\n\n.escher-container .radioSelection td {\n  padding: 3px 5px;\n}\n\n.escher-container .radioSelection input[type=radio] {\n  margin: 0;\n  margin-top: 4px;\n  margin-right: 4px;\n}\n\n.escher-container .radioSelection .optionLabel {\n  width: 88px;\n}\n\n.escher-container .radioSelection .optionLabelWide {\n  width: 192px;\n}\n\n.escher-container .radioSelection .optionGroup {\n  margin-right: 10px\n}\n\n.escher-container .settingsBox .singleLine {\n  display: flex;\n}\n\n.escher-container .settingsContainer label {\n  display: block;\n  margin-bottom: 0;\n}\n\n.escher-container .settingsBoxContainer input[type=checkbox] {\n  margin: 0;\n  margin-top: 4px;\n  margin-right: 4px;\n}\n\n.escher-container .settingsTip {\n  font-size: 13px;\n}\n\n.escher-container .settingsBoxContainer hr {\n  margin: 18px 0;\n  border: 0;\n  border-top: 1px solid #dddddd;\n}\n\n.escher-container .scaleTitle {\n  margin-top: 15px;\n  display: flex;\n  justify-content: space-between;\n}\n\n.escher-container .selector {\n  position: relative;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  padding-top: 2px;\n}\n\n.escher-container .selectorTitle {\n  background-color: white;\n  border: 1px solid #a9a9a9;\n  padding-left: 4px;\n  cursor: default;\n  width: 162px;\n}\n\n.escher-container .selectorTitle:hover:not(.disabled) {\n  border-color: black;\n}\n\n.escher-container .selectorTitle.disabled {\n  background-color: #f1ecfa;\n}\n\n.escher-container .selectorMenu {\n  position: absolute;\n  z-index: 4;\n  background-color: white;\n  border: 1px solid #a9a9a9;\n  min-width: 162px;\n}\n\n.escher-container .scaleSelection {\n  cursor: default;\n  padding: 0 6px;\n  display: flex;\n  justify-content: space-between;\n}\n\n.escher-container .scaleSelection:hover {\n  background-color: dodgerblue;\n  color: white;\n}\n\n.escher-container .settingsBox .icon-sort-down {\n  position: absolute;\n  top: 0;\n}\n\n.escher-container .settingsBox .tooltipOption {\n  margin-left: 10px;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

var _Dropdown = __webpack_require__(84);

var _Dropdown2 = _interopRequireDefault(_Dropdown);

var _MenuButton = __webpack_require__(87);

var _MenuButton2 = _interopRequireDefault(_MenuButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */


/**
 * MenuBar implements generic Dropdown and MenuButton objects to create the
 * Builder menu bar. Currently re-renders every time an edit mode is chosen.
 * This can be changed once Builder is ported to Preact.
 */
var MenuBar = function (_Component) {
  _inherits(MenuBar, _Component);

  function MenuBar() {
    _classCallCheck(this, MenuBar);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  MenuBar.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    this.props.sel.selectAll('.escher-zoom-container').on('touchend.menuBar', function () {
      return _this2.setState({ dropdownVisible: false });
    }).on('click.menuBar', function () {
      return _this2.setState({ dropdownVisible: false });
    });
  };

  MenuBar.prototype.componentWillUnmount = function componentWillUnmount() {
    this.props.sel.selectAll('.escher-zoom-container').on('touchend.menuBar', null).on('click.menuBar', null);
  };

  MenuBar.prototype.render = function render() {
    var _this3 = this;

    var enableKeys = this.props.settings.get('enable_keys');
    var disabledButtons = this.props.settings.get('disabled_buttons');
    var beziersEnabled = this.props.map.beziers_enabled;
    var fullScreenButtonEnabled = this.props.settings.get('full_screen_button');

    return (0, _preact.h)(
      'ul',
      { className: 'menu-bar' },
      (0, _preact.h)(
        _Dropdown2.default,
        { name: 'Map', dropdownVisible: this.props.dropdownVisible },
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Save map JSON' + (enableKeys ? ' (Ctrl+S)' : ''),
          onClick: function onClick() {
            return _this3.props.saveMap();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Load map JSON' + (enableKeys ? ' (Ctrl+O)' : ''),
          onClick: function onClick(file) {
            return _this3.props.loadMap(file);
          },
          assignKey: this.props.assignKeyLoadMap,
          type: 'load',
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Export as SVG' + (enableKeys ? ' (Ctrl+Shift+S)' : ''),
          onClick: function onClick() {
            return _this3.props.save_svg();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Export as PNG' + (enableKeys ? ' (Ctrl+Shift+P)' : ''),
          onClick: function onClick() {
            return _this3.props.save_png();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Clear map',
          onClick: function onClick() {
            return _this3.props.clear_map();
          },
          disabledButtons: disabledButtons
        })
      ),
      (0, _preact.h)(
        _Dropdown2.default,
        { name: 'Model', dropdownVisible: this.props.dropdownVisible },
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Load COBRA model JSON' + (enableKeys ? ' (Ctrl+M)' : ''),
          onClick: function onClick(file) {
            return _this3.props.loadModel(file);
          },
          assignKey: this.props.assignKeyLoadModel,
          type: 'load',
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Update names and gene reaction rules using model',
          onClick: function onClick() {
            return _this3.props.updateRules();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Clear model',
          onClick: function onClick() {
            return _this3.props.clearModel();
          },
          disabledButtons: disabledButtons
        })
      ),
      (0, _preact.h)(
        _Dropdown2.default,
        { name: 'Data', dropdownVisible: this.props.dropdownVisible },
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Load reaction data',
          onClick: function onClick(d) {
            return _this3.props.setReactionData(d);
          },
          type: 'load',
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Clear reaction data',
          onClick: function onClick() {
            return _this3.props.clearReactionData();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)('li', { name: 'divider' }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Load gene data',
          onClick: function onClick(d) {
            return _this3.props.setGeneData(d);
          },
          type: 'load',
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Clear gene data',
          onClick: function onClick() {
            return _this3.props.clearGeneData();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)('li', { name: 'divider' }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Load metabolite data',
          onClick: function onClick(d) {
            return _this3.props.setMetaboliteData(d);
          },
          type: 'load',
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Clear metabolite data',
          onClick: function onClick() {
            return _this3.props.clearMetaboliteData();
          },
          disabledButtons: disabledButtons
        })
      ),
      (0, _preact.h)(
        _Dropdown2.default,
        {
          name: 'Edit',
          rightMenu: 'true',
          dropdownVisible: this.props.dropdownVisible,
          disabledEditing: !this.props.settings.get('enable_editing')
        },
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Pan mode' + (enableKeys ? ' (Z)' : ''),
          checkMark: this.props.mode === 'zoom',
          onClick: function onClick() {
            return _this3.props.setMode('zoom');
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Select mode' + (enableKeys ? ' (V)' : ''),
          checkMark: this.props.mode === 'brush',
          onClick: function onClick() {
            return _this3.props.setMode('brush');
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Add reaction mode' + (enableKeys ? ' (N)' : ''),
          checkMark: this.props.mode === 'build',
          onClick: function onClick() {
            return _this3.props.setMode('build');
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Rotate mode' + (enableKeys ? ' (R)' : ''),
          checkMark: this.props.mode === 'rotate',
          onClick: function onClick() {
            return _this3.props.setMode('rotate');
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Text mode' + (enableKeys ? ' (T)' : ''),
          checkMark: this.props.mode === 'text',
          onClick: function onClick() {
            return _this3.props.setMode('text');
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)('li', { name: 'divider' }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Delete' + (enableKeys ? ' (Del)' : ''),
          onClick: function onClick() {
            return _this3.props.deleteSelected();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Undo' + (enableKeys ? ' (Ctrl+Z)' : ''),
          onClick: function onClick() {
            return _this3.props.undo();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Redo' + (enableKeys ? ' (Ctrl+Shift+Z)' : ''),
          onClick: function onClick() {
            return _this3.props.redo();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)('li', { name: 'divider' }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Align vertical' + (enableKeys ? ' (Alt+L)' : ''),
          onClick: this.props.align_vertical,
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Align horizontal' + (enableKeys ? ' (Shift+Alt+L)' : ''),
          onClick: this.props.align_horizontal,
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Toggle primary/secondary' + (enableKeys ? ' (P)' : ''),
          onClick: function onClick() {
            return _this3.props.togglePrimary();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Rotate reactant locations' + (enableKeys ? ' (C)' : ''),
          onClick: function onClick() {
            return _this3.props.cyclePrimary();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)('li', { name: 'divider' }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Select all' + (enableKeys ? ' (Ctrl+A)' : ''),
          onClick: function onClick() {
            return _this3.props.selectAll();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Select none' + (enableKeys ? ' (Ctrl+Shift+A)' : ''),
          onClick: function onClick() {
            return _this3.props.selectNone();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Invert selection',
          onClick: function onClick() {
            return _this3.props.invertSelection();
          },
          disabledButtons: disabledButtons
        })
      ),
      (0, _preact.h)(
        _Dropdown2.default,
        { name: 'View', rightMenu: 'true', dropdownVisible: this.props.dropdownVisible },
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Zoom in' + (enableKeys ? ' (+)' : ''),
          onClick: function onClick() {
            return _this3.props.zoom_in();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Zoom out' + (enableKeys ? ' (-)' : ''),
          onClick: function onClick() {
            return _this3.props.zoom_out();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Zoom to nodes' + (enableKeys ? ' (0)' : ''),
          onClick: function onClick() {
            return _this3.props.zoomExtentNodes();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Zoom to canvas' + (enableKeys ? ' (1)' : ''),
          onClick: function onClick() {
            return _this3.props.zoomExtentCanvas();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Find' + (enableKeys ? ' (F)' : ''),
          onClick: function onClick() {
            return _this3.props.search();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)(_MenuButton2.default, {
          name: (beziersEnabled ? 'Hide' : 'Show') + ' control points' + (enableKeys ? ' (B)' : ''),
          onClick: function onClick() {
            return _this3.props.toggleBeziers();
          },
          disabledButtons: disabledButtons
        }),
        (0, _preact.h)('li', { name: 'divider' }),
        fullScreenButtonEnabled && (0, _preact.h)(_MenuButton2.default, {
          name: 'Full screen',
          onClick: function onClick() {
            return _this3.props.full_screen();
          },
          checkMark: this.props.isFullScreen,
          disabledButtons: disabledButtons
        }),
        fullScreenButtonEnabled && (0, _preact.h)('li', { name: 'divider' }),
        (0, _preact.h)(_MenuButton2.default, {
          name: 'Settings' + (enableKeys ? ' (,)' : ''),
          onClick: function onClick() {
            return _this3.props.renderSettingsMenu();
          },
          disabledButtons: disabledButtons,
          type: 'settings'
        })
      ),
      (0, _preact.h)(
        'a',
        { className: 'helpButton', target: '#', href: 'https://escher.readthedocs.org' },
        '?'
      )
    );
  };

  return MenuBar;
}(_preact.Component);

exports.default = MenuBar;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

__webpack_require__(85);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Dropdown. Handles the behavior of the menu bar and the dropdowns. Composed of
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * a menu button and a corresponding menu that displays when the button is
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * clicked.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/** @jsx h */


var Dropdown = function (_Component) {
  _inherits(Dropdown, _Component);

  function Dropdown(props) {
    _classCallCheck(this, Dropdown);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.state = {
      visible: null
    };
    _this.setWrapperRef = _this.setWrapperRef.bind(_this);
    _this.handleClickOutside = _this.handleClickOutside.bind(_this);
    return _this;
  }

  Dropdown.prototype.componentWillMount = function componentWillMount() {
    this.setState({
      visible: false
    });
  };

  Dropdown.prototype.componentDidMount = function componentDidMount() {
    document.addEventListener('mouseup', this.handleClickOutside);
  };

  Dropdown.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    this.setState({ visible: nextProps.visible });
  };

  Dropdown.prototype.setWrapperRef = function setWrapperRef(node) {
    this.wrapperRef = node;
  };

  Dropdown.prototype.handleClickOutside = function handleClickOutside(event) {
    if (this.wrapperRef && !this.wrapperRef.contains(event.target)) {
      this.setState({ visible: false });
    }
  };

  Dropdown.prototype.render = function render() {
    var _this2 = this;

    return (0, _preact.h)(
      'li',
      {
        className: 'dropdown',
        style: this.props.disabledEditing ? { display: 'none' } : { display: 'block' }
      },
      (0, _preact.h)(
        'div',
        {
          className: 'dropdownButton',
          tabindex: '0',
          ref: this.setWrapperRef,
          onClick: function onClick() {
            return _this2.setState({ visible: !_this2.state.visible });
          }
        },
        this.props.name,
        '\xA0',
        (0, _preact.h)('i', { className: 'icon-sort-down' })
      ),
      (0, _preact.h)(
        'ul',
        {
          className: 'menu',
          style: this.state.visible ? { display: 'block' } : { display: 'none' },
          id: this.props.rightMenu === 'true' ? 'rightMenu' : ''
        },
        this.props.children.map(function (listItem) {
          if (listItem && listItem.attributes.name === 'divider') {
            return (0, _preact.h)('li', {
              style: {
                height: '1px',
                backgroundColor: '#e5e5e5',
                padding: '0',
                margin: '8px 0'
              }
            });
          } else {
            return listItem;
          }
        })
      )
    );
  };

  return Dropdown;
}(_preact.Component);

exports.default = Dropdown;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(86);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(13)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(12);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".escher-container .menu-bar {\n  box-sizing: border-box;\n  list-style-type: none;\n  padding: 0;\n  padding-right: 20px;\n  position: relative;\n  margin: 5px 0px;\n  background-color: white;\n  border: 1px solid #ddd;\n  display: inline-flex;\n  box-sizing: border-box;\n  width: 100%;\n  justify-content: space-between;\n}\n\n.escher-container .dropdown {\n  position: relative;\n  float: left;\n  box-sizing: border-box;\n  font-size: 12px;\n  border-radius: 3px;\n\n  /* these sometimes get overridden */\n  margin: 0 !important;\n  font-weight: normal !important;\n\n  text-align: center;\n  vertical-align: middle;\n  -ms-touch-action: none;\n  touch-action: none;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.escher-container .dropdownButton {\n  color: #d9230f!important;\n  border: 1px solid transparent;\n  padding: 6px 9px;\n}\n\n.escher-container .helpButton {\n  color: #d9230f!important;\n  padding: 0px 5px;\n  background-color: #f5f5f5!important;\n  border: 0!important;\n  text-decoration: unset;\n  height: fit-content;\n  position: absolute;\n  right: 0;\n  font-size: 12px;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.escher-container .dropdownButton:focus, .escher-container .helpButton:focus {\n  color: #91170a!important;\n  text-decoration: underline;\n}\n\n.escher-container .dropdownButton:hover, .escher-container .helpButton:hover {\n  color: #91170a!important;\n  text-decoration: underline;\n}\n\n.escher-container .menu-bar .icon-sort-down {\n  position: absolute;\n  font-size: 10px;\n  margin-left: -5px;\n}\n\n@media (min-width: 550px) {\n  .escher-container .menu-bar {\n    padding-right: 25px;\n  }\n\n  .escher-container .dropdown {\n    font-size: 18px;\n  }\n\n  .escher-container .dropdownButton {\n    padding: 6px 10px;\n    padding-right: 16px;\n  }\n\n  .escher-container .helpButton {\n    font-size: 16px;\n  }\n\n  .escher-container .menu-bar .icon-sort-down {\n    font-size: 14px;\n  }\n}\n\n.escher-container .menu {\n  box-sizing: border-box;\n  font-weight: normal!important;\n  word-spacing: 0;\n  position: absolute;\n  white-space: nowrap;\n  top: 103%;\n  left: -1%;\n  z-index: 1000;\n  display: block;\n  float: none;\n  min-width: 160px;\n  padding: 5px 0;\n  list-style: none;\n  font-size: 13px;\n  box-shadow: 0 6px 12px rgba(0,0,0,0.175);\n  background-clip: padding-box;\n  border: 1px solid #ddd;\n  background-color: rgba(255, 255, 255, 0.95);\n  border-radius: 0;\n  margin: 0;\n  text-align: left;\n}\n\n.escher-container #rightMenu {\n  left: auto;\n  right: -2%;\n}\n\n.escher-container .menu li:hover {\n  background-color: #d9230f;\n  color: #FFFFFF;\n}\n\n.escher-container .menu li, .menu label {\n  font-size: 15px;\n  display: block;\n  color: #444444;\n\n  /* these sometimes get overridden */\n  font-weight: normal !important;\n  margin: 0 !important;\n}\n\n.escher-container .menu.ul.li {\n  background-color: rgba(255, 255, 255, 0.95);\n}\n\n.escher-container .menuButton {\n  box-sizing: border-box;\n  width: 100%;\n  padding: 5px 20px;\n  margin: 0;\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.escher-container label:focus, .menuButton:focus {\n  background-color: #d9230f;\n  color: #FFFFFF;\n}\n\n.escher-container .menuButton:hover {\n  background-color: #d9230f;\n  color: #FFFFFF;\n}\n\n.escher-container input[type=\"file\"] {\n  display: none;\n}\n\n.escher-container #disabled {\n  color: #e0e0e0;\n}\n\n.escher-container #disabled:hover, #disabled:focus {\n  background-color: rgba(255, 255, 255, 0.95);\n  cursor: default;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

var _utils = __webpack_require__(4);

var _utils2 = _interopRequireDefault(_utils);

var _dataStyles = __webpack_require__(20);

var dataStyles = _interopRequireWildcard(_dataStyles);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * MenuButton. Handles the individual menu items within the Dropdown menus.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Takes in a name and a function and binds the function to a button. If the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * type prop is defined as 'load' will instead render a label with an attached
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * hidden input[file] element.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/** @jsx h */


var MenuButton = function (_Component) {
  _inherits(MenuButton, _Component);

  function MenuButton(props) {
    _classCallCheck(this, MenuButton);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.assignKeyForInput = _this.assignKeyForInput.bind(_this);
    return _this;
  }

  MenuButton.prototype.handleFileInput = function handleFileInput(target) {
    var _this2 = this;

    var file = target.files[0];
    var reader = new window.FileReader();
    reader.onload = function () {
      _utils2.default.load_json_or_csv(file, dataStyles.csv_converter, function (e, d) {
        return _this2.props.onClick(d);
      });
    };
    if (file !== undefined) {
      reader.readAsText(file);
    }
    // reset input
    target.value = null;
  };

  MenuButton.prototype.assignKeyForInput = function assignKeyForInput(node) {
    if (this.props.assignKey) {
      this.props.assignKey(function () {
        return node.click();
      });
    }
  };

  MenuButton.prototype.render = function render() {
    var _this3 = this;

    var disabled = _underscore2.default.contains(this.props.disabledButtons, this.props.name.replace(/ \(.*\)$/, ''));
    if (this.props.type === 'load') {
      return (0, _preact.h)(
        'label',
        {
          className: 'menuButton',
          tabindex: disabled ? '-1' : '0',
          id: disabled ? 'disabled' : ''
        },
        (0, _preact.h)('input', {
          type: 'file',
          onChange: function onChange(event) {
            return _this3.handleFileInput(event.target);
          },
          disabled: disabled,
          ref: this.assignKeyForInput
        }),
        this.props.name
      );
    } else if (this.props.checkMark) {
      return (0, _preact.h)(
        'li',
        {
          className: 'menuButton',
          tabindex: disabled ? '-1' : '0',
          onClick: this.props.onClick,
          id: disabled ? 'disabled' : ''
        },
        (0, _preact.h)(
          'i',
          { className: 'icon-ok', 'aria-hidden': 'true' },
          '\xA0'
        ),
        this.props.name
      );
    } else {
      return (0, _preact.h)(
        'li',
        {
          className: 'menuButton',
          tabindex: disabled ? '-1' : '0',
          onClick: disabled ? null : this.props.onClick,
          id: disabled ? 'disabled' : ''
        },
        this.props.name
      );
    }
  };

  return MenuButton;
}(_preact.Component);

exports.default = MenuButton;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

__webpack_require__(89);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** SearchBar */

/** @jsx h */


var SearchBar = function (_Component) {
  _inherits(SearchBar, _Component);

  function SearchBar(props) {
    _classCallCheck(this, SearchBar);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.state = {
      current: 0,
      searchItem: props.searchItem,
      counter: ''
    };
    return _this;
  }

  SearchBar.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    this.setState({
      clearEscape: this.props.map.key_manager.addEscapeListener(function () {
        return _this2.close();
      }, true),
      clearNext: this.props.map.key_manager.addKeyListener(['enter', 'ctrl+g'], function () {
        return _this2.next();
      }, false),
      clearPrevious: this.props.map.key_manager.addKeyListener(['shift+enter', 'shift+ctrl+g'], function () {
        return _this2.previous();
      }, false)
    });
  };

  SearchBar.prototype.componentDidMount = function componentDidMount() {
    this.inputRef.focus();
  };

  SearchBar.prototype.componentWillUnmount = function componentWillUnmount() {
    this.state.clearEscape();
    this.state.clearNext();
    this.state.clearPrevious();
    this.props.map.highlight(null);
  };

  /**
   * Updates map focus and search bar counter when new search term is entered.
   * @param {string} value - Search term
   */


  SearchBar.prototype.handleInput = function handleInput(value) {
    var results = this.dropDuplicates(this.props.map.search_index.find(value));
    var counter = '';
    if (results === null || !value) {
      this.props.map.highlight(null);
    } else if (results.length === 0) {
      counter = '0 / 0';
      this.props.map.highlight(null);
    } else {
      // Catches case where new search term shortens results to less than current index
      if (this.state.current >= results.length) {
        this.setState({
          current: 0
        });
      }
      counter = this.state.current + 1 + '/' + results.length;
      var r = results[this.state.current];
      if (r.type === 'reaction') {
        this.props.map.zoom_to_reaction(r.reaction_id);
        this.props.map.highlight_reaction(r.reaction_id);
      } else if (r.type === 'metabolite') {
        this.props.map.zoom_to_node(r.node_id);
        this.props.map.highlight_node(r.node_id);
      } else if (r.type === 'text_label') {
        this.props.map.zoom_to_text_label(r.text_label_id);
        this.props.map.highlight_text_label(r.text_label_id);
      } else {
        throw new Error('Bad search index data type: ' + r.type);
      }
    }
    this.setState({
      searchItem: value,
      current: 0,
      counter: counter,
      results: results
    });
  };

  SearchBar.prototype.dropDuplicates = function dropDuplicates(results) {
    var compKeys = {
      metabolite: {
        type: 'm',
        key: 'node_id'
      },
      reaction: {
        type: 'r',
        key: 'reaction_id'
      },
      text_label: {
        type: 't',
        key: 'text_label_id'
      }
    };
    return _underscore2.default.uniq(results, function (item) {
      // make a string for fast comparison
      var _compKeys$item$type = compKeys[item.type],
          type = _compKeys$item$type.type,
          key = _compKeys$item$type.key;

      return '' + type + item[key];
    });
  };

  SearchBar.prototype.next = function next() {
    if (!(this.state.results && this.state.results.length > 0)) return;
    this.update((this.state.current + 1) % this.state.results.length);
  };

  SearchBar.prototype.previous = function previous() {
    if (!(this.state.results && this.state.results.length > 0)) return;
    this.update((this.state.current + this.state.results.length - 1) % this.state.results.length);
  };

  /**
   * Updates the map focus and search bar counter for when buttons are clicked.
   * @param {number} current - index of current search result
   */


  SearchBar.prototype.update = function update(current) {
    this.setState({
      current: current,
      counter: current + 1 + '/' + this.state.results.length
    });
    var r = this.state.results[current];
    if (r.type === 'reaction') {
      this.props.map.zoom_to_reaction(r.reaction_id);
      this.props.map.highlight_reaction(r.reaction_id);
    } else if (r.type === 'metabolite') {
      this.props.map.zoom_to_node(r.node_id);
      this.props.map.highlight_node(r.node_id);
    } else if (r.type === 'text_label') {
      this.props.map.zoom_to_text_label(r.text_label_id);
      this.props.map.highlight_text_label(r.text_label_id);
    } else {
      throw new Error('Bad search index data type: ' + r.type);
    }
  };

  SearchBar.prototype.close = function close() {
    this.props.setDisplay(false);
  };

  SearchBar.prototype.render = function render() {
    var _this3 = this;

    return (0, _preact.h)(
      'div',
      { className: 'search-container' },
      (0, _preact.h)('input', {
        className: 'search-field',
        value: this.state.searchItem,
        onInput: function onInput(event) {
          return _this3.handleInput(event.target.value);
        },
        ref: function ref(input) {
          _this3.inputRef = input;
        }
      }),
      (0, _preact.h)(
        'button',
        { className: 'search-bar-button left btn', onClick: function onClick() {
            return _this3.previous();
          } },
        (0, _preact.h)('i', { className: 'icon-left-open' })
      ),
      (0, _preact.h)(
        'button',
        { className: 'search-bar-button right btn', onClick: function onClick() {
            return _this3.next();
          } },
        (0, _preact.h)('i', { className: 'icon-right-open' })
      ),
      (0, _preact.h)(
        'div',
        { className: 'search-counter' },
        this.state.counter
      ),
      (0, _preact.h)(
        'button',
        { className: 'search-bar-button btn', onClick: function onClick() {
            return _this3.close();
          } },
        (0, _preact.h)('i', { className: 'icon-cancel' })
      )
    );
  };

  return SearchBar;
}(_preact.Component);

exports.default = SearchBar;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(90);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(13)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(12);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".escher-container .search-container {\n  display: flex;\n  flex-direction: row;\n  background-color: rgba(255, 255, 255, 0.95);\n  padding: 3px;\n  border: 1px solid #DDD;\n}\n\n.escher-container .search-container .search-field {\n  flex: 0 0 auto;\n  color: #777;\n  border: 1px solid #DDD;\n  width: 114px;\n  height: 29px;\n  border-radius: 3px;\n  font-size: 13px;\n}\n\n.escher-container .search-container .search-counter {\n  flex: 1;\n  color: #777;\n  font-size: 13px;\n  padding: 9px 0 0 6px;\n}\n\n.escher-container .search-container .search-bar-button {\n  flex: 0 0 auto;\n  border-radius: 4px;\n  text-align: center;\n  vertical-align: middle;\n  font-size: 14px;\n  font-weight: 400;\n  height: 29px;\n  width: 34px;\n  margin: 3px;\n}\n\n.escher-container .search-container .search-bar-button.left {\n  border-top-right-radius: 0px;\n  border-bottom-right-radius: 0px;\n  margin-right: 0;\n}\n\n.escher-container .search-container .search-bar-button.right {\n  border-top-left-radius: 0px;\n  border-bottom-left-radius: 0px;\n  margin-left: 0;\n}\n\n.escher-container .search-container .search-bar-button:active {\n  background-image: linear-gradient(#3F4141, #474949 6%, #4F5151);\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

__webpack_require__(92);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */


/**
 * ButtonPanel. Sets up the button panel for Builder. Currently calls a
 * re-render on itself every time the mode is changed. This can be removed upon
 * porting Builder to Preact
 */
var ButtonPanel = function (_Component) {
  _inherits(ButtonPanel, _Component);

  function ButtonPanel() {
    _classCallCheck(this, ButtonPanel);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  ButtonPanel.prototype.render = function render() {
    var _this2 = this;

    var menuSetting = this.props.settings.get('menu');
    var enableKeys = this.props.settings.get('enable_keys');
    var enableEditing = this.props.settings.get('enable_editing');

    return (0, _preact.h)(
      'ul',
      { className: 'button-panel' },
      (0, _preact.h)(
        'li',
        null,
        (0, _preact.h)(
          'button',
          {
            className: 'button btn',
            onClick: function onClick() {
              return _this2.props.zoomContainer.zoom_in();
            },
            title: 'Zoom in' + (enableKeys ? ' (+)' : '')
          },
          (0, _preact.h)('i', { className: 'icon-zoom-in' })
        )
      ),
      (0, _preact.h)(
        'li',
        null,
        (0, _preact.h)(
          'button',
          {
            className: 'button btn',
            onClick: function onClick() {
              return _this2.props.zoomContainer.zoom_out();
            },
            title: 'Zoom out' + (enableKeys ? ' (-)' : '')
          },
          (0, _preact.h)('i', { className: 'icon-zoom-out' })
        )
      ),
      (0, _preact.h)(
        'li',
        null,
        (0, _preact.h)(
          'button',
          {
            className: 'button btn',
            onClick: function onClick() {
              return _this2.props.map.zoom_extent_canvas();
            },
            title: 'Zoom to canvas' + (enableKeys ? ' (1)' : '')
          },
          (0, _preact.h)('i', { className: 'icon-resize-full' })
        )
      ),
      (0, _preact.h)(
        'li',
        { style: { display: this.props.settings.get('full_screen_button') !== false ? 'block' : 'none' } },
        (0, _preact.h)(
          'button',
          {
            className: 'button btn ' + (this.props.isFullScreen ? 'active-button' : ''),
            onClick: function onClick() {
              return _this2.props.full_screen();
            },
            title: 'Toggle full screen'
          },
          (0, _preact.h)('i', { className: 'icon-resize-full-alt' })
        )
      ),
      (0, _preact.h)(
        'li',
        {
          className: 'grouping',
          style: { display: menuSetting === 'all' && enableEditing ? 'block' : 'none' }
        },
        (0, _preact.h)(
          'button',
          {
            className: 'buttonGroup btn',
            title: 'Pan mode' + (enableKeys ? ' (Z)' : ''),
            'for': 'zoom',
            id: this.props.mode === 'zoom' ? 'currentMode' : null,
            onClick: function onClick() {
              return _this2.props.setMode('zoom');
            }
          },
          (0, _preact.h)('i', { className: 'icon-move' })
        ),
        (0, _preact.h)(
          'button',
          {
            className: 'buttonGroup btn',
            title: 'Select mode' + (enableKeys ? ' (V)' : ''),
            'for': 'brush',
            id: this.props.mode === 'brush' ? 'currentMode' : null,
            onClick: function onClick() {
              return _this2.props.setMode('brush');
            }
          },
          (0, _preact.h)('i', { className: 'icon-mouse-pointer' })
        ),
        (0, _preact.h)(
          'button',
          {
            className: 'buttonGroup btn',
            title: 'Add reaction mode' + (enableKeys ? ' (N)' : ''),
            'for': 'build',
            onClick: function onClick() {
              return _this2.props.setMode('build');
            },
            id: this.props.mode === 'build' ? 'currentMode' : null },
          (0, _preact.h)('i', { className: 'icon-wrench' })
        ),
        (0, _preact.h)(
          'button',
          {
            className: 'buttonGroup btn',
            title: 'Rotate mode' + (enableKeys ? ' (R)' : ''),
            'for': 'rotate',
            id: this.props.mode === 'rotate' ? 'currentMode' : null,
            onClick: function onClick() {
              return _this2.props.setMode('rotate');
            }
          },
          (0, _preact.h)('i', { className: 'icon-cw' })
        ),
        (0, _preact.h)(
          'button',
          {
            className: 'buttonGroup btn',
            title: 'Text mode' + (enableKeys ? ' (T)' : ''),
            'for': 'text',
            id: this.props.mode === 'text' ? 'currentMode' : null,
            onClick: function onClick() {
              return _this2.props.setMode('text');
            }
          },
          (0, _preact.h)('i', { className: 'icon-font' })
        )
      ),
      (0, _preact.h)(
        'li',
        {
          className: 'grouping',
          style: { display: this.props.mode === 'build' && menuSetting === 'all' && enableEditing ? 'block' : 'none' }
        },
        (0, _preact.h)(
          'button',
          {
            className: 'buttonGroup btn',
            title: 'Direction arrow' + (enableKeys ? ' (←)' : ''),
            onClick: function onClick() {
              return _this2.props.buildInput.direction_arrow.left();
            }
          },
          (0, _preact.h)('i', { className: 'icon-left-big' })
        ),
        (0, _preact.h)(
          'button',
          {
            className: 'buttonGroup btn',
            title: 'Direction arrow' + (enableKeys ? ' (→)' : ''),
            onClick: function onClick() {
              return _this2.props.buildInput.direction_arrow.right();
            }
          },
          (0, _preact.h)('i', { className: 'icon-right-big' })
        ),
        (0, _preact.h)(
          'button',
          {
            className: 'buttonGroup btn',
            title: 'Direction arrow' + (enableKeys ? ' (↑)' : ''),
            onClick: function onClick() {
              return _this2.props.buildInput.direction_arrow.up();
            }
          },
          (0, _preact.h)('i', { className: 'icon-up-big' })
        ),
        (0, _preact.h)(
          'button',
          {
            className: 'buttonGroup btn',
            title: 'Direction arrow' + (enableKeys ? ' (↓)' : ''),
            onClick: function onClick() {
              return _this2.props.buildInput.direction_arrow.down();
            }
          },
          (0, _preact.h)('i', { className: 'icon-down-big' })
        )
      )
    );
  };

  return ButtonPanel;
}(_preact.Component);

exports.default = ButtonPanel;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(93);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(13)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(12);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".escher-container .button-panel {\n  position: absolute;\n  left: 4px;\n  top: 20%;\n  margin-top: -32px;\n  padding-left: 0;\n  touch-action: none;\n}\n\n.escher-container .button-panel>li {\n  margin-top: 5px;\n  display: block;\n\n  /* these sometimes get overridden */\n  margin-left: 0 !important;\n}\n\n.escher-container .grouping {\n  display: block;\n}\n\n.escher-container .buttonGroup {\n  display: block;\n  margin-bottom: -1px;\n  padding: 5px 0px;\n  border-radius: 0;\n}\n\n.escher-container .grouping>.buttonGroup:first-child {\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n}\n\n.escher-container .grouping>.buttonGroup:last-child {\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n\n.escher-container .button-panel>.grouping:last-child {\n  margin-top: 4px;\n}\n\n.escher-container #currentMode,\n.escher-container .active-button {\n  background-image: linear-gradient(#8F4F3F,#834c3c 6%,#8d3a2d) !important;\n}\n\n.escher-container .buttonGroup.btn {\n  margin-top: -1px;\n}\n\n.escher-container .button {\n  border-radius: 4px;\n}\n\n.escher-container .button.btn, .escher-container .buttonGroup.btn {\n  padding: unset;\n  color: white!important;\n  border: 1px solid #474949;\n  background-image: linear-gradient(#4F5151, #474949 6%, #3F4141);\n  background-color: white;\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  font-size: 14px!important;\n  font-weight: 400;\n  width: 40px;\n  height: 40px;\n}\n\n.escher-container .button-panel .button:active, .escher-container .buttonGroup label:active, .escher-container .button-panel .buttonGroup:active {\n  background-image: linear-gradient(#3F4141, #474949 6%, #4F5151);\n}\n\n.escher-container .button-panel .fa {\n  font-size: 24px;\n}\n\n/* Icons */\n.escher-container .button-panel [class^='icon-'] {\n  font-size: 23px;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _CallbackManager = __webpack_require__(21);

var _CallbackManager2 = _interopRequireDefault(_CallbackManager);

var _PlacedDiv = __webpack_require__(35);

var _PlacedDiv2 = _interopRequireDefault(_PlacedDiv);

var _renderWrapper = __webpack_require__(56);

var _renderWrapper2 = _interopRequireDefault(_renderWrapper);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /** @jsx h */


/**
 * Manage the tooltip that lives in a PlacedDiv.
 * @param selection
 * @param tooltipComponent
 * @param zoomContainer
 * @param map
 */
var TooltipContainer = function () {
  function TooltipContainer(selection, TooltipComponent, zoomContainer, map, settings) {
    var _this = this;

    _classCallCheck(this, TooltipContainer);

    this.div = selection.append('div').attr('id', 'tooltip-container');
    this.tooltipRef = null;

    this.zoomContainer = zoomContainer;
    this.setUpZoomCallbacks(zoomContainer);

    // Create callback manager
    this.callbackManager = new _CallbackManager2.default();

    this.div.on('mouseover', this.cancelHideTooltip.bind(this));
    this.div.on('mouseleave', this.hide.bind(this));

    this.map = map;
    this.setUpMapCallbacks(map);

    this.settings = settings;

    this.delay_hide_timeout = null;
    this.currentTooltip = null;

    (0, _renderWrapper2.default)(TooltipComponent, null, function (passProps) {
      return _this.callbackManager.set('pass_props', passProps);
    }, this.div.node(), function (instance) {
      _this.tooltipRef = instance;
    });
    this.passProps({
      display: false,
      disableTooltips: function disableTooltips() {
        return _this.disableTooltips();
      }
    });
  }

  /**
   * Disable tooltips in the settings
   */


  TooltipContainer.prototype.disableTooltips = function disableTooltips() {
    this.settings.set('enable_tooltips', false);
    // draw to update tooltip settings
    this.map.draw_everything();
    this.hide();
    this.map.set_status('Tooltips disabled. You can enable them again in the\n                         settings menu.', 3000);
  };

  /**
    * Function to pass props for the tooltips. Run without an argument to
    * rerender the component
    * @param {Object} props - Props that the tooltip will use
    */


  TooltipContainer.prototype.passProps = function passProps() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this.callbackManager.run('pass_props', null, props);
  };

  /**
   * Sets up the appropriate callbacks to show the input
   * @param {object} map - map object
   */


  TooltipContainer.prototype.setUpMapCallbacks = function setUpMapCallbacks(map) {
    var _this2 = this;

    this.placedDiv = (0, _PlacedDiv2.default)(this.div, map, undefined, false);

    // connect callbacks to show tooltip
    map.callback_manager.set('show_tooltip.tooltip_container', function (type, d) {
      _this2.show(type, d);
    });

    // callback to hide / delay hide tooltip
    map.callback_manager.set('hide_tooltip.tooltip_container', function () {
      return _this2.hide();
    });
    map.callback_manager.set('delay_hide_tooltip.tooltip_container', function () {
      return _this2.delayHide();
    });

    // Hides the tooltip when the canvas is touched
    map.sel.selectAll('.canvas-group').on('touchend', function () {
      return _this2.hide();
    });
  };

  TooltipContainer.prototype.setUpZoomCallbacks = function setUpZoomCallbacks(zoomContainer) {
    zoomContainer.callbackManager.set('zoom.tooltip_container', function () {
      if (this.is_visible()) {
        this.hide();
      }
    }.bind(this));
    zoomContainer.callbackManager.set('go_to.tooltip_container', function () {
      if (this.is_visible()) {
        this.hide();
      }
    }.bind(this));
  };

  /**
   * Return visibility of tooltip container.
   * @return {Boolean} Whether tooltip is visible.
   */


  TooltipContainer.prototype.is_visible = function is_visible() {
    // eslint-disable-line camelcase
    return this.placedDiv.is_visible();
  };

  /**
   * Show and place the input.
   * @param {string} type - 'reaction_label', 'node_label', or 'gene_label'
   * @param {Object} d - D3 data for DOM element
   */


  TooltipContainer.prototype.show = function show(type, d) {
    // get rid of a lingering delayed hide
    this.cancelHideTooltip();

    if (_underscore2.default.contains(['reaction_label', 'node_label', 'gene_label', 'reaction_object', 'node_object'], type)) {
      // Use a default height if the ref hasn't been connected yet
      var tooltipSize = this.tooltipRef !== null && this.tooltipRef.get_size ? this.tooltipRef.get_size() : { width: 270, height: 100 };
      this.currentTooltip = { type: type, id: d[type.replace('_label', '_id').replace('_object', '_id')] };
      var windowTranslate = this.zoomContainer.windowTranslate;
      var windowScale = this.zoomContainer.windowScale;
      var mapSize = this.map !== null ? this.map.get_size() : { width: 1000, height: 1000 };
      var offset = { x: 0, y: 0 };
      var startPosX = type === 'reaction_object' ? d.xPos : d.label_x;
      var startPosY = type === 'reaction_object' ? d.yPos : d.label_y;
      var rightEdge = windowScale * startPosX + windowTranslate.x + tooltipSize.width;
      var bottomEdge = windowScale * startPosY + windowTranslate.y + tooltipSize.height;
      if (mapSize.width < 500) {
        if (rightEdge > mapSize.width) {
          offset.x = -(rightEdge - mapSize.width) / windowScale;
        }
        if (bottomEdge > mapSize.height - 74) {
          offset.y = -(bottomEdge - mapSize.height + 77) / windowScale;
        }
      } else {
        if (windowScale * startPosX + windowTranslate.x + 0.5 * tooltipSize.width > mapSize.width) {
          offset.x = -tooltipSize.width / windowScale;
        } else if (rightEdge > mapSize.width) {
          offset.x = -(rightEdge - mapSize.width) / windowScale;
        }
        if (windowScale * startPosY + windowTranslate.y + 0.5 * tooltipSize.height > mapSize.height - 45) {
          offset.y = -tooltipSize.height / windowScale;
        } else if (bottomEdge > mapSize.height - 45) {
          offset.y = -(bottomEdge - mapSize.height + 47) / windowScale;
        }
      }
      var coords = { x: startPosX + offset.x, y: startPosY + 10 + offset.y };
      this.placedDiv.place(coords);
      this.passProps({
        display: true,
        biggId: d.bigg_id,
        name: d.name,
        loc: coords,
        data: d.data_string,
        type: type.replace('_label', '').replace('node', 'metabolite').replace('_object', '')
      });
    } else {
      throw new Error('Tooltip not supported for object type ' + type);
    }
  };

  /**
   * Hide the input.
   */


  TooltipContainer.prototype.hide = function hide() {
    this.placedDiv.hide();
    this.currentTooltip = null;
  };

  /**
   * Hide the input after a short delay, so that mousing onto the tooltip does not
   * cause it to hide.
   */


  TooltipContainer.prototype.delayHide = function delayHide() {
    var _this3 = this;

    this.delayHideTimeout = setTimeout(function () {
      return _this3.hide();
    }, 100);
  };

  TooltipContainer.prototype.cancelHideTooltip = function cancelHideTooltip() {
    if (this.delayHideTimeout !== null) {
      clearTimeout(this.delayHideTimeout);
    }
  };

  return TooltipContainer;
}();

exports.default = TooltipContainer;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(6);

__webpack_require__(96);

var _utils = __webpack_require__(4);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global window */
/** @jsx h */

/**
 * Define a Tooltip component and interface with Preact.
 */


var DefaultTooltip = function (_Component) {
  _inherits(DefaultTooltip, _Component);

  function DefaultTooltip() {
    _classCallCheck(this, DefaultTooltip);

    var _this = _possibleConstructorReturn(this, _Component.call(this));

    _this.openBigg = _this.openBigg.bind(_this);
    return _this;
  }

  DefaultTooltip.prototype.decompartmentalizeCheck = function decompartmentalizeCheck(id, type) {
    // ID without compartment, if metabolite.
    return type === 'metabolite' ? utils.decompartmentalize(id)[0] : id;
  };

  DefaultTooltip.prototype.openBigg = function openBigg() {
    var type = this.props.type;
    var biggId = this.props.biggId;
    var pref = 'http://bigg.ucsd.edu/';
    var url = type === 'gene' ? pref + 'search?query=' + biggId : pref + 'universal/' + type + 's/' + this.decompartmentalizeCheck(biggId, type);
    window.open(url);
  };

  DefaultTooltip.prototype.capitalizeFirstLetter = function capitalizeFirstLetter(s) {
    return typeof s === 'string' ? s.charAt(0).toUpperCase() + s.slice(1) : console.warn('capitalizeFirstLetter was passed something other than a string');
  };

  DefaultTooltip.prototype.render = function render() {
    var decomp = this.decompartmentalizeCheck(this.props.biggId, this.props.type);
    var biggButtonText = 'Open ' + decomp + ' in BiGG Models.';
    return (0, _preact.h)(
      'div',
      { className: 'default-tooltip' },
      (0, _preact.h)(
        'div',
        { className: 'id' },
        this.props.biggId
      ),
      (0, _preact.h)(
        'div',
        { className: 'name' },
        'name: ',
        this.props.name
      ),
      (0, _preact.h)(
        'div',
        { className: 'data' },
        'data: ',
        this.props.data && this.props.data !== '(nd)' ? this.props.data : 'no data'
      ),
      (0, _preact.h)(
        'button',
        { onClick: this.openBigg },
        biggButtonText
      ),
      (0, _preact.h)(
        'div',
        { className: 'top-right' },
        (0, _preact.h)(
          'div',
          { className: 'type-label' },
          this.capitalizeFirstLetter(this.props.type)
        ),
        (0, _preact.h)(
          'a',
          { onClick: this.props.disableTooltips },
          'Disable Tooltips'
        )
      )
    );
  };

  return DefaultTooltip;
}(_preact.Component);

exports.default = DefaultTooltip;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(97);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(13)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(12);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".escher-container .default-tooltip {\n  box-sizing: border-box;\n  min-width: 300px;\n  min-height: 100px;\n  border-radius: 2px;\n  border: 1px solid #b58787;\n  padding: 7px;\n  background-color: #fff;\n  text-align: left;\n  font-size: 16px;\n  font-family: sans-serif;\n  color: #111;\n  box-shadow: 4px 6px 20px 0px rgba(0, 0, 0, 0.4);\n}\n\n.escher-container .default-tooltip .id{\n  font-size: 18px;\n  font-weight: bold;\n}\n\n.escher-container .default-tooltip button {\n  border-radius: 3px;\n  background-color: #eee;\n  border: 1px solid #ddd;\n  margin-top: 4px;\n  font-size: 16px;\n  padding: 3px 6px;\n}\n\n.escher-container .default-tooltip .top-right {\n  position: absolute;\n  top: 4px;\n  right: 4px;\n}\n\n.escher-container .default-tooltip .top-right * {\n  float: right;\n  text-align: right;\n}\n\n.escher-container .default-tooltip .top-right a {\n  font-size: 11px;\n  color: #999;\n  cursor: pointer;\n}\n.escher-container .default-tooltip .top-right a:hover {\n  color: #444;\n  text-decoration: underline;\n}\n\n.escher-container .default-tooltip .type-label {\n  font-size: 15px;\n  color: #d27066;\n  background-color: #ffeded;\n  border-radius: 2px;\n  margin: 0 0 0 10px;\n  padding: 0 5px;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(99);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(13)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(12);
var ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(100);
var ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(101);
var ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(102);
var ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(103);
var ___CSS_LOADER_URL_IMPORT_3___ = __webpack_require__(104);
var ___CSS_LOADER_URL_IMPORT_4___ = __webpack_require__(105);
exports = ___CSS_LOADER_API_IMPORT___(false);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___, { hash: "#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_5___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___, { hash: "#fontello" });
// Module
exports.push([module.i, "@font-face {\n  font-family: 'fontello';\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") format('embedded-opentype'),\n       url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") format('woff2'),\n       url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ") format('woff'),\n       url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ") format('truetype'),\n       url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ") format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n/* Chrome hack: SVG is rendered more smooth in Windozze. 100% magic, uncomment if you need it. */\n/* Note, that will break hinting! In other OS-es font will be not as sharp as it could be */\n/*\n@media screen and (-webkit-min-device-pixel-ratio:0) {\n  @font-face {\n    font-family: 'fontello';\n    src: url('../font/fontello.svg?9130959#fontello') format('svg');\n  }\n}\n*/\n \n [class^=\"icon-\"]:before, [class*=\" icon-\"]:before {\n  font-family: \"fontello\";\n  font-style: normal;\n  font-weight: normal;\n  speak: none;\n \n  display: inline-block;\n  text-decoration: inherit;\n  width: 1em;\n  margin-right: .2em;\n  text-align: center;\n  /* opacity: .8; */\n \n  /* For safety - reset parent styles, that can break glyph codes*/\n  font-variant: normal;\n  text-transform: none;\n \n  /* fix buttons height, for twitter bootstrap */\n  line-height: 1em;\n \n  /* Animation center compensation - margins should be symmetric */\n  /* remove if not needed */\n  margin-left: .2em;\n \n  /* you can be more comfortable with increased icons size */\n  /* font-size: 120%; */\n \n  /* Font smoothing. That was taken from TWBS */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n \n  /* Uncomment for 3D effect */\n  /* text-shadow: 1px 1px 1px rgba(127, 127, 127, 0.3); */\n}\n \n.icon-ok:before { content: '\\e800'; } /* '' */\n.icon-cancel:before { content: '\\e801'; } /* '' */\n.icon-plus:before { content: '\\e802'; } /* '' */\n.icon-down-big:before { content: '\\e803'; } /* '' */\n.icon-left-big:before { content: '\\e804'; } /* '' */\n.icon-right-big:before { content: '\\e805'; } /* '' */\n.icon-up-big:before { content: '\\e806'; } /* '' */\n.icon-left-open:before { content: '\\e807'; } /* '' */\n.icon-right-open:before { content: '\\e808'; } /* '' */\n.icon-wrench:before { content: '\\e809'; } /* '' */\n.icon-resize-full:before { content: '\\e80a'; } /* '' */\n.icon-cw:before { content: '\\e80b'; } /* '' */\n.icon-trash-empty:before { content: '\\e80e'; } /* '' */\n.icon-font:before { content: '\\e80f'; } /* '' */\n.icon-zoom-in:before { content: '\\e810'; } /* '' */\n.icon-zoom-out:before { content: '\\e811'; } /* '' */\n.icon-move:before { content: '\\f047'; } /* '' */\n.icon-resize-full-alt:before { content: '\\f0b2'; } /* '' */\n.icon-blank:before { content: '\\f0c8'; } /* '' */\n.icon-sort-down:before { content: '\\f0dd'; } /* '' */\n.icon-mouse-pointer:before { content: '\\f245'; } /* '' */", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    // eslint-disable-next-line no-param-reassign
    options = {};
  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign


  url = url && url.__esModule ? url.default : url;

  if (typeof url !== 'string') {
    return url;
  } // If url is already wrapped in quotes, remove them


  if (/^['"].*['"]$/.test(url)) {
    // eslint-disable-next-line no-param-reassign
    url = url.slice(1, -1);
  }

  if (options.hash) {
    // eslint-disable-next-line no-param-reassign
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, '\\n'), "\"");
  }

  return url;
};

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = "data:application/vnd.ms-fontobject;base64,nCUAAPQkAAABAAIAAAAAAAIABQMAAAAAAAABAJABAAAAAExQAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAPEi+7wAAAAAAAAAAAAAAAAAAAAAAABAAZgBvAG4AdABlAGwAbABvAAAADgBSAGUAZwB1AGwAYQByAAAAFgBWAGUAcgBzAGkAbwBuACAAMQAuADAAAAAQAGYAbwBuAHQAZQBsAGwAbwAAAAAAAAEAAAAPAIAAAwBwR1NVQiCLJXoAAAD8AAAAVE9TLzI+I1MqAAABUAAAAFZjbWFwh1r3sAAAAagAAAK4Y3Z0IAbV/v4AABjcAAAAIGZwZ22KkZBZAAAY/AAAC3BnYXNwAAAAEAAAGNQAAAAIZ2x5ZhPQy/4AAARgAAAPmmhlYWQPoZfIAAAT/AAAADZoaGVhBzsDaAAAFDQAAAAkaG10eElc//wAABRYAAAAWGxvY2Ep+yYIAAAUsAAAAC5tYXhwASUMCgAAFOAAAAAgbmFtZcydHR8AABUAAAACzXBvc3Sd6TSHAAAX0AAAAQNwcmVw5UErvAAAJGwAAACGAAEAAAAKADAAPgACREZMVAAObGF0bgAaAAQAAAAAAAAAAQAAAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAEDVgGQAAUAAAJ6ArwAAACMAnoCvAAAAeAAMQECAAACAAUDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBmRWQAQOgA8kUDUv9qAFoDUgCZAAAAAQAAAAAAAAAAAAUAAAADAAAALAAAAAQAAAGsAAEAAAAAAKYAAwABAAAALAADAAoAAAGsAAQAegAAABAAEAADAADoC+gR8EfwsvDI8N3yRf//AADoAOgO8EfwsvDI8N3yRf//AAAAAAAAAAAAAAAAAAAAAQAQACYALAAsACwALAAsAAAAAQACAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAAAEGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAQwAAAAAAAAAFQAA6AAAAOgAAAAAAQAA6AEAAOgBAAAAAgAA6AIAAOgCAAAAAwAA6AMAAOgDAAAABAAA6AQAAOgEAAAABQAA6AUAAOgFAAAABgAA6AYAAOgGAAAABwAA6AcAAOgHAAAACAAA6AgAAOgIAAAACQAA6AkAAOgJAAAACgAA6AoAAOgKAAAACwAA6AsAAOgLAAAADAAA6A4AAOgOAAAADQAA6A8AAOgPAAAADgAA6BAAAOgQAAAADwAA6BEAAOgRAAAAEAAA8EcAAPBHAAAAEQAA8LIAAPCyAAAAEgAA8MgAAPDIAAAAEwAA8N0AAPDdAAAAFAAA8kUAAPJFAAAAFQABAAAAAAOlApgAFQAdQBoPAQABAUcAAgECbwABAAFvAAAAZhQXFAMFFysBFAcBBiInASY0PwE2Mh8BATYyHwEWA6UQ/iAQLBD+6g8PTBAsEKQBbhAsEEwQAhYWEP4gDw8BFhAsEEwQEKUBbxAQTA8AAQAA/+8C1AKGACQAHkAbIhkQBwQAAgFHAwECAAJvAQEAAGYUHBQUBAUYKyUUDwEGIi8BBwYiLwEmND8BJyY0PwE2Mh8BNzYyHwEWFA8BFxYC1A9MECwQpKQQLBBMEBCkpBAQTBAsEKSkECwQTA8PpKQPcBYQTA8PpaUPD0wQLBCkpBAsEEwQEKSkEBBMDy4PpKQPAAEAAP/5AxIDCwAjAClAJgAEAwRvAAEAAXAFAQMAAANUBQEDAwBYAgEAAwBMIzMlIzMjBgUaKwEVFAYnIxUUBgcjIiY3NSMiJic1NDY3MzU0NjsBMhYXFTMyFgMSIBboIBZrFiAB6BceASAW6B4XaxceAegXHgG3axYgAekWHgEgFekeF2sXHgHoFiAgFuggAAEAAP/PA4MDCwAeACBAHRgPAgABAUcAAgECbwMBAQABbwAAAGYVNRcUBAUYKwEUBwEGIicBJjQ/ATYyHwERNDY3MzIWFRE3NjIfARYDgxX+lRY6Ff6VFRUpFjoVpCoeRx0qpRQ7FikVAYIeFP6UFRUBbBQ7FikVFaQBiR0qASwc/nekFRUpFgABAAD/iANZAu0AHQAkQCEAAgMCbwABAAFwAAMAAANUAAMDAFgAAAMATCYXFiMEBRgrARUUBiMhFxYUDwEGIicBJjQ3ATYyHwEWFA8BITIWA1kkHf53pBUVKhU7Ff6UFBQBbBU6FioVFaQBiR0kAV5HHiqkFDwUKxQUAWwVOhYBaxUVKRY6FqQoAAAAAAEAAP+IAzUC7QAeACRAIQADAgNvAAABAHAAAgEBAlQAAgIBWAABAgFMFiUmFAQFGCsBFAcBBiIvASY0PwEhIiY9ATQ2FyEnJjQ/ATYyFwEWAzUU/pUWOhUqFhaj/ncdJCQdAYmjFhYqFToWAWsUAToeFP6UFBQqFTwVoyoeRx4qAaUUPBQqFRX+lRQAAQAA/7EDgwLnAB4AIEAdEAcCAAMBRwADAANvAgEAAQBvAAEBZhcVNRQEBRgrARQPAQYiLwERFAYHIyImNREHBiIvASY0NwE2MhcBFgODFSkWOxSlKB9HHiqkFDwUKhUVAWsUPBUBaxUBNBwWKhUVpP53HSQBJhwBiaQVFSoVOxUBaxUV/pUWAAEAAP/AApgDRAAUAC21AQEAAQFHS7AkUFhACwAAAQBwAAEBDAFJG0AJAAEAAW8AAABmWbQXFwIFFisJAhYUDwEGIicBJjQ3ATYyHwEWFAKO/tcBKQoKXQscC/5iCwsBngoeCl0KAqr+2P7XCh4KXQoKAZ8KHgoBngsLXQoeAAAAAQAA/8ACdANEABQALbUJAQABAUdLsCRQWEALAAABAHAAAQEMAUkbQAkAAQABbwAAAGZZtBwSAgUWKwkBBiIvASY0NwkBJjQ/ATYyFwEWFAJq/mILHAtdCwsBKP7YCwtdCh4KAZ4KAWn+YQoKXQscCwEpASgLHAtdCwv+YgscAAADAAD/dgOgAwsACAAUAC4AWUAQJgEEAygnEgMCBAABAQADR0uwIVBYQBoAAwQDbwAEAgRvAAIAAm8AAAEAbwABAQ0BSRtAGAADBANvAAQCBG8AAgACbwAAAQBvAAEBZlm3HCMtGBIFBRkrNzQmDgIeATYlAQYiLwEmNDcBHgElFAcOASciJjQ2NzIWFxYUDwEVFzY/ATYyFtYUHhQCGBoYAWb+gxU6FjsVFQF8FlQBmQ0bgk9okpJoIEYZCQmjbAIqSyEPCh0OFgISIBIEGvb+gxQUPRQ7FgF8N1TdFiVLXgGS0JACFBAGEgdefTwCGS0UCgAAAgAA/7EDWgMLABgAMAAxQC4oHxkDAgQSDAMDAAECRwAEAgRvAAIDAm8AAwEDbwABAAFvAAAAZjoUFxo3BQUZKwEUDwEXFhQGByMiJic1ND4BHwE3NjIfARYBFRQOAS8BBwYiLwEmND8BJyY0NjczMhYBpQW5UAoUD/oPFAEWHAtQugUOBkAFAbQUIAlQuQYOBkAFBbpRChQP+g8WAQUHBrlRCh4UARYO+g8UAgxQuQYGPwYB2/oPFAIMULkGBkAFDga5UQoeFAEWAAAAAf/+/7EDWQMLADAAPUA6LQEBBQkBAAECRwAAAQMBAANtAAMCAQMCawAFAAEABQFgAAIEBAJUAAICBFgABAIETCcnEyckMwYFGisBFRQGKwEiJj8BJiMiDgIUHgIzMjY3PgEfAR4BBw4BByIuAj4DMzIWFzc2FgNZFBD6FxMRTVJwOmpMLi5MajpCdikEEQZMBQIGPK5fV6BwSARAeJhbUpg9SBEsAsP6DhYtEE1NLkxqdGpMLjo1BgEFTQQOBkpQAUR0nq6edEQ+OUgSEwAAAAYAAP+xAxIDCwAPAB8ALwA7AEMAZwBkQGFXRQIGCCkhGREJAQYAAQJHBQMCAQYABgEAbQQCAgAHBgAHawAOAAkIDglgDw0CCAwKAgYBCAZeAAcLCwdUAAcHC1gACwcLTGVkYV5bWVNST0xJR0E/FCQUJiYmJiYjEAUdKwERFAYrASImNRE0NjsBMhYXERQGKwEiJjURNDY7ATIWFxEUBisBIiY1ETQ2OwEyFhMRIREUHgEzITI+AQEzJyYnIwYHBRUUBisBERQGIyEiJicRIyImPQE0NjsBNz4BNzMyFh8BMzIWAR4KCCQICgoIJAgKjwoIJAgKCggkCAqOCgckCAoKCCQHCkj+DAgIAgHQAggI/on6GwQFsQYEAesKCDY0Jf4wJTQBNQgKCgisJwksFrIXKgknrQgKAbf+vwgKCggBQQgKCgj+vwgKCggBQQgKCgj+vwgKCggBQQgKCv5kAhH97wwUCgoUAmVBBQEBBVMkCAr97y5EQi4CEwoIJAgKXRUcAR4UXQoAAgAA/7EDoQMLAAcAUACzQAk+NiEJBAUDAUdLsApQWEAqAAEAAW8ABQMCAwUCbQACBAMCBGsHBgIEBG4AAAMDAFIAAAADVgADAANKG0uwC1BYQCoAAQABbwAFAwIDBQJtBAECBgMCBmsHAQYGbgAAAwMAUgAAAANWAAMAA0obQCoAAQABbwAFAwIDBQJtAAIEAwIEawcGAgQEbgAAAwMAUgAAAANWAAMAA0pZWUATCAgIUAhQTEtKSTs6KiMbUQgFFisBBxcWMzI3JgE3PgQ3GwEzFxMeARceARcWFx4BFxYVFAYXIiYHIgYjND8CNj8BNj8BNic0Ji8CDgEXFB4BHwEWNxYVFAciJiMiBicGAZVfTDofCxUw/jUBDSQcHBYGhJxIBnITUhYJMBALCAtMCQQCASOOJCqcFQJJBwYDEQQCBQMCIhcY+w46ARAgCyAVAgEBIYIgBRQCLQIa+wEBAY3+BiwEBgYKGBABWAGUDP70K8o0E3ohGgYJEAMWCgMKAgoBCBgTEAEBAQcCAgYEBAlaNjgBIJoODBIKAgUDAQsVBQsMBgEIAAP///9qA6EDDQAjACwARQBdQFofGAIDBBMSAQMAAw0GAgEAQwEHATIBCQcFRwAEBgMGBANtAAEABwABB20ACgAGBAoGYAUBAwIBAAEDAGAABwAJCAcJYAAICA0IST08NTMUExUUIyYUIyMLBR0rARUUBicjFRQGJyMiJjc1IyImJzU0NjsBNTQ2OwEyFhcVMzIWFzQuAQYUFj4BARQGIi8BBiMiLgI+BB4CFxQHFxYCOwoHfQwGJAcMAX0HCgEMBn0KCCQHCgF9BwpIktCSktCSAR4qPBS/ZHtQkmhAAjxsjqSObDwBRb8VAZQkBwwBfQcMAQoIfQoIJAcKfQgKCgh9ChlnkgKWypgGjP6aHSoVv0U+apCijm46BEJmlk17ZL8VAAAD////agOhAw0ADwAYADEAO0A4CQgBAwABLwEDAB4BBQMDRwAGAAIBBgJgAAEAAAMBAGAAAwAFBAMFYAAEBA0ESRcjFBMVJiMHBRsrARUUBichIiYnNTQ2MyEyFhc0LgEGFBY+AQEUBiIvAQYjIi4CPgQeAhcUBxcWAjsKB/6+BwoBDAYBQgcKSJLQkpLQkgEeKjwUv2R7UJJoQAI8bI6kjmw8AUW/FQGUJAcMAQoIJAcKChlnkgKWypgGjP6aHSoVv0U+apCijm46BEJmlk17ZL8VAAEAAP9qA+gDUgBEAFBATQsBCQoHCgkHbQ0BBwgKBwhrBgEAAQIBAAJtBAECAwECA2sMAQgFAQEACAFeAAoKDEgAAwMNA0lBQD08Ozk0My4sExcTESUVIRMUDgUdKwEUDwEGIiY9ASMVMzIWFA8BBiIvASY0NjsBNSMVFAYiLwEmND8BNjIWHQEzNSMiJjQ/ATYyHwEWFAYrARUzNTQ2Mh8BFgPoC44LHhTXSA4WC48KHgqPCxYOSNcUHgqPCwuPCh4U10gOFguPCxwLjwsWDkjXFB4LjgsBXg4LjwsWDkjXFB4KjwsLjwoeFNdIDhYLjwscC48LFg5I1xQeC44LC44LHhTXSA4WC48KAAABAAD/sQNaAwsARQAyQC8+NTMiBAIDNCEgGxIREAIBCQACAkcEAQMCA28FAQIAAm8BAQAAZiY6Nxs6OQYFGisBBxc3NhYdARQGKwEiJyY/AScHFxYHBisBIiYnNTQ2HwE3JwcGIyInJj0BNDY7ATIXFg8BFzcnJjc2OwEyFgcVFAcGIyInAszGxlARLBQQ+hcJChFRxsZQEQkKF/oPFAEsEVDGxlALDgcHFhYO+hcKCRFQxsZREQoJF/oPFgEWBwcOCwIkxsZQEhMY+g4WFxURUcbGUREVFxYO+hgTElDGxlALAwkY+g4WFxURUcbGUREVFxYO+hgJAwsAAAABAAD/sQNZAwsADwARQA4AAQABbwAAAGY1MwIFFisBERQGByEiJjURNDY3ITIWA1leQ/3pQ15eQwIXQ14Cav3oQl4BYEECGEJeAWAAAQAA/9UCPAEXAA4AF0AUAAEAAQFHAAEAAW8AAABmJhQCBRYrJRQPAQYiLwEmNDY3ITIWAjsK+gscC/oLFg4B9A4W8w8K+gsL+goeFAEWAAABAAD/ZwKKA1IAHAAhQB4OAQEAAUcAAAIBAgABbQABAW4AAgIMAkkoGyMDBRcrARYHBisBExYGDwEGJi8BBwYjIicmNRE0NzYzMhcCeBIKCRjVcAYMDWMOGgZrrgsOBwcWFgcHDwoBDBEVF/72DRwFKgYMDfyuCwMKFwNHGAkDCwAAAAABAAAAAQAA775IPF8PPPUACwPoAAAAANZOKhUAAAAA1k4qFf/+/2cD6ANSAAAACAACAAAAAAAAAAEAAANS/2oAAAPo//7//wPoAAEAAAAAAAAAAAAAAAAAAAAWA+gAAAPoAAADEQAAAxEAAAOgAAADWQAAA1kAAAOgAAACygAAAsoAAAOgAAADWQAAA1n//gMRAAADoAAAA6D//wOg//8D6AAAA1kAAANZAAACOwAAAsoAAAAAAAAAOACCAMoBDgFUAZoB3gIeAl4C2AM+A6YEagU+BdAGOgbABz4HZAeMB80AAAABAAAAFgBoAAYAAAAAAAIAIAAwAHMAAAB1C3AAAAAAAAAAEgDeAAEAAAAAAAAANQAAAAEAAAAAAAEACAA1AAEAAAAAAAIABwA9AAEAAAAAAAMACABEAAEAAAAAAAQACABMAAEAAAAAAAUACwBUAAEAAAAAAAYACABfAAEAAAAAAAoAKwBnAAEAAAAAAAsAEwCSAAMAAQQJAAAAagClAAMAAQQJAAEAEAEPAAMAAQQJAAIADgEfAAMAAQQJAAMAEAEtAAMAAQQJAAQAEAE9AAMAAQQJAAUAFgFNAAMAAQQJAAYAEAFjAAMAAQQJAAoAVgFzAAMAAQQJAAsAJgHJQ29weXJpZ2h0IChDKSAyMDE3IGJ5IG9yaWdpbmFsIGF1dGhvcnMgQCBmb250ZWxsby5jb21mb250ZWxsb1JlZ3VsYXJmb250ZWxsb2ZvbnRlbGxvVmVyc2lvbiAxLjBmb250ZWxsb0dlbmVyYXRlZCBieSBzdmcydHRmIGZyb20gRm9udGVsbG8gcHJvamVjdC5odHRwOi8vZm9udGVsbG8uY29tAEMAbwBwAHkAcgBpAGcAaAB0ACAAKABDACkAIAAyADAAMQA3ACAAYgB5ACAAbwByAGkAZwBpAG4AYQBsACAAYQB1AHQAaABvAHIAcwAgAEAAIABmAG8AbgB0AGUAbABsAG8ALgBjAG8AbQBmAG8AbgB0AGUAbABsAG8AUgBlAGcAdQBsAGEAcgBmAG8AbgB0AGUAbABsAG8AZgBvAG4AdABlAGwAbABvAFYAZQByAHMAaQBvAG4AIAAxAC4AMABmAG8AbgB0AGUAbABsAG8ARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAAIAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgECAQMBBAEFAQYBBwEIAQkBCgELAQwBDQEOAQ8BEAERARIBEwEUARUBFgEXAAJvawZjYW5jZWwEcGx1cwhkb3duLWJpZwhsZWZ0LWJpZwlyaWdodC1iaWcGdXAtYmlnCWxlZnQtb3BlbgpyaWdodC1vcGVuBndyZW5jaAtyZXNpemUtZnVsbAJjdwt0cmFzaC1lbXB0eQRmb250B3pvb20taW4Iem9vbS1vdXQEbW92ZQ9yZXNpemUtZnVsbC1hbHQFYmxhbmsJc29ydC1kb3duDW1vdXNlLXBvaW50ZXIAAAAAAQAB//8ADwAAAAAAAAAAAAAAAAAAAAAAGAAYABgAGANS/2cDUv9nsAAsILAAVVhFWSAgS7gADlFLsAZTWliwNBuwKFlgZiCKVViwAiVhuQgACABjYyNiGyEhsABZsABDI0SyAAEAQ2BCLbABLLAgYGYtsAIsIGQgsMBQsAQmWrIoAQpDRWNFUltYISMhG4pYILBQUFghsEBZGyCwOFBYIbA4WVkgsQEKQ0VjRWFksChQWCGxAQpDRWNFILAwUFghsDBZGyCwwFBYIGYgiophILAKUFhgGyCwIFBYIbAKYBsgsDZQWCGwNmAbYFlZWRuwAStZWSOwAFBYZVlZLbADLCBFILAEJWFkILAFQ1BYsAUjQrAGI0IbISFZsAFgLbAELCMhIyEgZLEFYkIgsAYjQrEBCkNFY7EBCkOwAWBFY7ADKiEgsAZDIIogirABK7EwBSWwBCZRWGBQG2FSWVgjWSEgsEBTWLABKxshsEBZI7AAUFhlWS2wBSywB0MrsgACAENgQi2wBiywByNCIyCwACNCYbACYmawAWOwAWCwBSotsAcsICBFILALQ2O4BABiILAAUFiwQGBZZrABY2BEsAFgLbAILLIHCwBDRUIqIbIAAQBDYEItsAkssABDI0SyAAEAQ2BCLbAKLCAgRSCwASsjsABDsAQlYCBFiiNhIGQgsCBQWCGwABuwMFBYsCAbsEBZWSOwAFBYZVmwAyUjYUREsAFgLbALLCAgRSCwASsjsABDsAQlYCBFiiNhIGSwJFBYsAAbsEBZI7AAUFhlWbADJSNhRESwAWAtsAwsILAAI0KyCwoDRVghGyMhWSohLbANLLECAkWwZGFELbAOLLABYCAgsAxDSrAAUFggsAwjQlmwDUNKsABSWCCwDSNCWS2wDywgsBBiZrABYyC4BABjiiNhsA5DYCCKYCCwDiNCIy2wECxLVFixBGREWSSwDWUjeC2wESxLUVhLU1ixBGREWRshWSSwE2UjeC2wEiyxAA9DVVixDw9DsAFhQrAPK1mwAEOwAiVCsQwCJUKxDQIlQrABFiMgsAMlUFixAQBDYLAEJUKKiiCKI2GwDiohI7ABYSCKI2GwDiohG7EBAENgsAIlQrACJWGwDiohWbAMQ0ewDUNHYLACYiCwAFBYsEBgWWawAWMgsAtDY7gEAGIgsABQWLBAYFlmsAFjYLEAABMjRLABQ7AAPrIBAQFDYEItsBMsALEAAkVUWLAPI0IgRbALI0KwCiOwAWBCIGCwAWG1EBABAA4AQkKKYLESBiuwcisbIlktsBQssQATKy2wFSyxARMrLbAWLLECEystsBcssQMTKy2wGCyxBBMrLbAZLLEFEystsBossQYTKy2wGyyxBxMrLbAcLLEIEystsB0ssQkTKy2wHiwAsA0rsQACRVRYsA8jQiBFsAsjQrAKI7ABYEIgYLABYbUQEAEADgBCQopgsRIGK7ByKxsiWS2wHyyxAB4rLbAgLLEBHistsCEssQIeKy2wIiyxAx4rLbAjLLEEHistsCQssQUeKy2wJSyxBh4rLbAmLLEHHistsCcssQgeKy2wKCyxCR4rLbApLCA8sAFgLbAqLCBgsBBgIEMjsAFgQ7ACJWGwAWCwKSohLbArLLAqK7AqKi2wLCwgIEcgILALQ2O4BABiILAAUFiwQGBZZrABY2AjYTgjIIpVWCBHICCwC0NjuAQAYiCwAFBYsEBgWWawAWNgI2E4GyFZLbAtLACxAAJFVFiwARawLCqwARUwGyJZLbAuLACwDSuxAAJFVFiwARawLCqwARUwGyJZLbAvLCA1sAFgLbAwLACwAUVjuAQAYiCwAFBYsEBgWWawAWOwASuwC0NjuAQAYiCwAFBYsEBgWWawAWOwASuwABa0AAAAAABEPiM4sS8BFSotsDEsIDwgRyCwC0NjuAQAYiCwAFBYsEBgWWawAWNgsABDYTgtsDIsLhc8LbAzLCA8IEcgsAtDY7gEAGIgsABQWLBAYFlmsAFjYLAAQ2GwAUNjOC2wNCyxAgAWJSAuIEewACNCsAIlSYqKRyNHI2EgWGIbIVmwASNCsjMBARUUKi2wNSywABawBCWwBCVHI0cjYbAJQytlii4jICA8ijgtsDYssAAWsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgsAhDIIojRyNHI2EjRmCwBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2EjICCwBCYjRmE4GyOwCENGsAIlsAhDRyNHI2FgILAEQ7ACYiCwAFBYsEBgWWawAWNgIyCwASsjsARDYLABK7AFJWGwBSWwAmIgsABQWLBAYFlmsAFjsAQmYSCwBCVgZCOwAyVgZFBYIRsjIVkjICCwBCYjRmE4WS2wNyywABYgICCwBSYgLkcjRyNhIzw4LbA4LLAAFiCwCCNCICAgRiNHsAErI2E4LbA5LLAAFrADJbACJUcjRyNhsABUWC4gPCMhG7ACJbACJUcjRyNhILAFJbAEJUcjRyNhsAYlsAUlSbACJWG5CAAIAGNjIyBYYhshWWO4BABiILAAUFiwQGBZZrABY2AjLiMgIDyKOCMhWS2wOiywABYgsAhDIC5HI0cjYSBgsCBgZrACYiCwAFBYsEBgWWawAWMjICA8ijgtsDssIyAuRrACJUZSWCA8WS6xKwEUKy2wPCwjIC5GsAIlRlBYIDxZLrErARQrLbA9LCMgLkawAiVGUlggPFkjIC5GsAIlRlBYIDxZLrErARQrLbA+LLA1KyMgLkawAiVGUlggPFkusSsBFCstsD8ssDYriiAgPLAEI0KKOCMgLkawAiVGUlggPFkusSsBFCuwBEMusCsrLbBALLAAFrAEJbAEJiAuRyNHI2GwCUMrIyA8IC4jOLErARQrLbBBLLEIBCVCsAAWsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgR7AEQ7ACYiCwAFBYsEBgWWawAWNgILABKyCKimEgsAJDYGQjsANDYWRQWLACQ2EbsANDYFmwAyWwAmIgsABQWLBAYFlmsAFjYbACJUZhOCMgPCM4GyEgIEYjR7ABKyNhOCFZsSsBFCstsEIssDUrLrErARQrLbBDLLA2KyEjICA8sAQjQiM4sSsBFCuwBEMusCsrLbBELLAAFSBHsAAjQrIAAQEVFBMusDEqLbBFLLAAFSBHsAAjQrIAAQEVFBMusDEqLbBGLLEAARQTsDIqLbBHLLA0Ki2wSCywABZFIyAuIEaKI2E4sSsBFCstsEkssAgjQrBIKy2wSiyyAABBKy2wSyyyAAFBKy2wTCyyAQBBKy2wTSyyAQFBKy2wTiyyAABCKy2wTyyyAAFCKy2wUCyyAQBCKy2wUSyyAQFCKy2wUiyyAAA+Ky2wUyyyAAE+Ky2wVCyyAQA+Ky2wVSyyAQE+Ky2wViyyAABAKy2wVyyyAAFAKy2wWCyyAQBAKy2wWSyyAQFAKy2wWiyyAABDKy2wWyyyAAFDKy2wXCyyAQBDKy2wXSyyAQFDKy2wXiyyAAA/Ky2wXyyyAAE/Ky2wYCyyAQA/Ky2wYSyyAQE/Ky2wYiywNysusSsBFCstsGMssDcrsDsrLbBkLLA3K7A8Ky2wZSywABawNyuwPSstsGYssDgrLrErARQrLbBnLLA4K7A7Ky2waCywOCuwPCstsGkssDgrsD0rLbBqLLA5Ky6xKwEUKy2wayywOSuwOystsGwssDkrsDwrLbBtLLA5K7A9Ky2wbiywOisusSsBFCstsG8ssDorsDsrLbBwLLA6K7A8Ky2wcSywOiuwPSstsHIsswkEAgNFWCEbIyFZQiuwCGWwAyRQeLABFTAtAEu4AMhSWLEBAY5ZsAG5CAAIAGNwsQAFQrIAAQAqsQAFQrMKAgEIKrEABUKzDgABCCqxAAZCugLAAAEACSqxAAdCugBAAAEACSqxAwBEsSQBiFFYsECIWLEDZESxJgGIUVi6CIAAAQRAiGNUWLEDAERZWVlZswwCAQwquAH/hbAEjbECAEQAAA=="

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff2;base64,d09GMgABAAAAABKUAA8AAAAAJPQAABI7AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHFQGVgCFOAggCZZwEQgKnxyaVAE2AiQDWAsuAAQgBYVNB4IDDIEGG3UhBdwYumHjAJ55bgvZ/4fjjpUVOJbYEKqpuEgYY4RGw1xkC9qrly7T8mghbhYrHvTL5IwNHzluZQ3s/HCVNusnK5jg8CFWfFBkvTioSxtKCf//2Urv+7+qurp7ehZQRDgCgBHBamXAIATMnJkjPDmm9skdQkgQJAqA+X83/ZvWE3QrSdsBnVBzmECdpkbPg5YESkVhVGbOdk7YHGaVFFLmZRK6vlPazZ+IIE/sz2VGAQQczmWuiClj+qMnysBNTbpZ81pOz0xVSbnUgoMG4ofZ7U+7e5KNchL4f7R9s6IEn+aGt2IZzAbLN/B1EjRZK2qKerrqZPAGQMZdus1WakWb8u1Mq3/vtWfZIHcsYUI4+1+bZSvpECqqEIr62m70x/L6f82ClrU8PvLYPpj10hwAB6G7LsT2oX1oBxCqvPTY5aWt0jR9IJ2tR5+ipFk7hvjQYGz2h6tg6aIQsUlh20e/FwRULLeV7d7bTID2w2vbNoCJAvSuguNAPbxn7QO530DgTBG5JjGu6Wf0FhHsZfsKeC0O6RdWNDwy0aFXPHYbN4Ptv/6P+4knw1yYJt4tzwfo9cGBxfI06VNm+ye+x8WxrljhwMtA7+IWHX6tv+v7rfPv8Fu/ffkH/iTyaxymfbUrVhS95loM+F95hhOIJAoyJRU1LRra9NCrT78Bg4agBM1pAWizFTCEX1kZFCsYDApuGykYQqRgiFAwJCgYCigYMhQMJRQMFRQMNRQMLXhtGBp4PSCuvV4Q8PqAoPHfeiBo/Hcehn54b8AwAO9LLMUg/sfvliHUG13I4CZr9BuVewDBK06S9OYf7eNvSI9PkdUL5v/kM/WnI6blf3YJDBzbUeMc/ABtPOBR5+ARmB7PPAadiO90hPTTMN8rnBxPdj9HZ67pz4lj29GxPTVi/T67/ieppvDLCfMv1ZkVyzv1LBdi36EaEHnlmqiuMV/RdDZVe7GWra3LSR9bgywlg2s8Tcnj0EQELScicjsSJZAkND2aUPQEmEy9dVLjJ4gZqxg2URQnx3hwrFaqr/CXsrq81KmUbyfm7abspmiJY7fvxQE1CqlaL+SJoODmQGIWTKfvRIIJJBTsc4Z+USQGTwE1cLOax/+C61fuJNtzSm7IY3K5jKFoOPUkbDhDn6aE4b2qhFIyAxI0a9LPyp3gWqmehSU3Mn3Bdtv0wdXKuPijqbMaZuc4iYVau4xY6xMECUNdL2TRNebShvM0qJZk3CxjTxsoSrT4OpK7tIREc8bvvMn19ED0miPQv+AG6vzMaDOr74q2BPP04s1+rOFvnJZo/u2Hpw9vduKbvRumccNhAwv3o9LZdZDomdIoD/RYAmIaamvNm0JobMJ1O1bDBQQNvWuhShucZYkfvYYH6RtMJ5i0wJnsOGPsxk1747wrVNw5GyPCYZDcdvoFDGDOn+zZj/RI0IRaApWgGJRR/ru3O4941IS+W/vLhKc3m2vJM4jKYNMzhKqYDQtjI8LZqAhsgohsokhskijYZJHZFFG2TsUcx9sawafxNZ8OBGcAgDMBwFkA4GwAcA4AOBcAnAcAzgdg1QKoCyW2sFemN2pUvR7ZO6nIAo9KLQILzS9M8CyGNJOpk1Ye2OvU3nNlqHR7lth/S41ZHNDohmKHLLXIbm6vWgbdlbF1OeY4QlbwPSOrEFhJxr+gecdP7UFd5r0Nzwqdz0YzGVPA8oAXaSXaS51nVTof8ThtidWo5tBltZqB+GzqVf9Kx8oWxdfrMhOSMKzyMDq/4VkDGBN06SbnpeTmab9UpK4v56C1SQ1q+2kRJAi0ie6dPHT7Tvxp28Wymauki3EKwUSm+lmCj9GmmcBHJJuF7FU8jzGfGM5ykuQbS3Ok/HTZrXi0mERIbdpuaKX7U0y3bg1nzOp49hyzgTn2iVpWu00hSwNttDZAbrzt59dO9SSTZ53+CamTmCLHugee9bd8sgR2YgpUBC2lN5gLGq+sGeUZW3Xmmqv4UBa0k7lN0rNDXr2txpy0x6BVrSLl6/RsrL2GbqH8vrtb9eJuTG+CqbXYzaa7UV1q6yKPNz2bb620fZgtgnvmn3srWGMFhraBtdZXCp4iJd0DuQyBLYvMsz244pYFz+pv6tTag6Ke2ju2ai5q8MP/xCzwoOnwmmI6e27s3NZNLslHOw0R113sanLWVTpUqct3e6M7s37gEXxBzrWsCJ49rOjerYofPMfKo9/ZYvWW7YsynphaTXsJVK9+/5YvGvZNQge2BtyLHT8oPDukdYWH4YKO8HkQR4HQMQDoOAB0Avyp8Cd6ABEAEAkAGcCpMAKoDQAyAUDt4J+iA0CdAFAXANQNfhc9AOoFgPoAWNefN7fKxDRwYuZU+2FmXqYtoSQJL2dra1cLkhUu9OAeoIcAMzY8ag2NzF3odRFArweAbRilpI1zF3pTBNCbARiwJW8hMSbqU1GBmty5BMtctEy3672kdz6AgCKRz/aSan/DlwvUgD0BEOcAwK8jP3J4WLQ7sO+58G3wIGddEU2XpUnT0kSiRE5qSnKxQEM5CbKERlliisAV4nUCvsRGJZknHOjaSTtmdDlFpHUd0BupJIKhDYDbNQaeS5AeOSxiA9S1DHgRGezwLYEWSYXsM5nIIgjiZFPA27BRWeZrjpy1Pntu5Ywzm4y2P5+JOJ8FjPHMlLPZt3kG5pAslVUmoK2sHiqL4KIy8oqFjBzHcxDUmc41FEOWciGHb4iinql9zXNQNJFSW5NW7zRbaBVAsZhOndRWszY1Vm1ligJGu897zc1enhmoireWtvqDA5Q4EDA4Qvaw0RlMJ1sC0qUy3nfSVs0tdS0JHPWuWsS20FY7eF6DjWg1M9gEjLQpDDuezjSGJhHQaCoYIM6w2pVrCE0nBQKEIwQP50OcwRbjzF1rFDWROpiEou0uM94Wmjyv0BTLiaEYGuE6XZ5hxDCJwhNJfYC/eQwVgDmOkDRWUEDW6LlvfXs3hczTM0KQr+63kxkyp7luX706g3V0ICLTbLCYCUoYER0UMfmvIHKE5I4AbF9ixFxYpp0pD7WHSkoM7oCIYi6L0i9jNPhNcmjle9EbW1M3oPB6umMSgzRaoYvpTloEfNIeCqkfhMMW6pmWaw7AimPYJBmSIki2hGpOvmPmCmubk5M+CII9TnkuTYYgQd6pPDhwOVmArpocPk8muk0IeCuc2J0EaXcPOCpInco1GkrtSHbDLrb3s8mLPhOwA70CBbefwmQRc+tb4jlJs0mAknHQZu7RBM9AsUHzIL4zuFGSDMZ1sltLsybazWi+go6mxdszXeWL5IKyFUUjX3/9ZHkiEv2a96tGE9mKTHvXb9hGNJonko83or92e/KeTHtLkhhPUhe7HKf+UvBLkV+kxctuj6AR3Xffo491uyEx3/+KfRk3gl2p775Dv8YY/XWs06+Uvbp4v1Q9PEIoa8NXq/Cj+Aamp49JmA/qJR7xMe+0XEUcxZcqRrvrpWskx6an1WXqKbVKPTIiVypGhmuVhBtX4sJlrpKVtiilpcMjeqWaIcqIS5eOSdZIc0ReOHbJqy/TM2JFhodLZauL5WL8GKGSe0ehrd/US2lxkUPlZXKmVlU7PHzk+pbwpSfYrMysLEbKdHayYvbsOVYaPWenpFPfgJHmDw3268TsE/aJfZlZmZlbB5kguWWJ84NinuLD4rTN47stf+/dq1bqr6v0VdpsBr3e/QX6SmqTvespMDg6+sHoKSu0FF986tCiw5e69o2ohO6mvGg+Y/LGxON37mh1jLT0mwemgrveot4/o9XevYPzyCf4wmcPzNLfnVrtnTskj4yMefhvtU7sLZDFirGXHxgKwQMsj9/c3NK8STmUr9HkD22zs53341fWbF9zUAEITbNaQqoaZ7XdwHhevXFr/dno2cqzO7e61B2trvI36uuh+XLJreoE5mntLBWf7mT8hTgxKv6dxDP1HuFfQs7W3VEf2O6tO8wPUqvkVX6d/IdW/sVXCgtK1ekfpJdWcxcrCnmF6xmdB+/r5rGzB86vcTaBMU+kdD/QgNNpSFXh8bf+V19ec/OuseeA0TPe0LEZyWl5U7+/cPdv7PZrGv5+BRydAq04kViU44kXJS9q4PfqlsYVC/EVixOXmSw7H4CvjwyX8/v/F/+qEcCiWHiZHVkaqxC8vqAcl8V7evfti7+vizF346X8DiwuNnavvsv6ZOvo6PvQKP3WqOv92FGnxCJhyuTPPTdQa9ONlluHKk9BF1UnRtafWDMdfaJ6xKKiQbOtduC552q7yq6uKfGE1ZRTpqrC3s3znTjpkyp4DeFwA08vZU+e9DGnO1ip/pIUZ9L3gFUl4CSduHR6p0gWEbC6t1e8SrNaLTSfHCCZwxNAp7vO6MDBSSzQssnzkFYrEvh48f1tw9Ekb+bkQaBlujEThzn5j7T1x/N8JYqx4eSarq4agLGrp/oQFir/4DP//98Mp2Vj38EHfxkkthMRTBxODm5M7Lz/Sn920NM5/HB2to42E1ZfVA5/atn6b+IQzesfmxue/GoBOxzPet8PODLrqJvsr1l+P2DfznnB3F47bFs5O/w9R7ZPNIXUwWTjDN/pOHB7MMBsHCF0Uh1ZYsDUcRk2LiWcP8WYi6OEzkXBQ4bI4ygHP7V9ReecCefQrHXnyzRCnEjolNC0Cppd3Y6hbVDI3BnI3DQdokN01swN/IY/2c1l12GaSTbZTH1lOjTc9WVEplii4eoMrubjJsQ40u0Rb8treEhNOvjjWGMVUswOUkv7J9FS7d/5+RsBxsRh8ihTjk0XFae9PQSfPzisBSQ8D68KpiIPPk6wMI7tqmkONUUczWhC8dvnb6crVqHDxwmELh2LqMBt+jV3ZB1B7ndyubMyG3EQ7+fpjStQlFumLIpc+BhucntA7OdGdbEQTMeCLCr30LzBHdq1kwpfM+JRKS+oIltWyo4x20eZSGIsmFEkige0KXO77PY0lluVJeV0haKui1MUu/UcdVdy6Ja5r7vDpG/VNjfWV1fiFve0RGPxUwgtt+4qOUS3K1e8HAVkLUM82hgW3IkHyAb+ux+BOycAP4PjByZ9f6kKp4IseZ7jQaGUsN+KTp03VS2WlDhWhQ5pmhpVp7lJfnLL/jQvpIWMhwEHHG+SiV0qtBLKInYIyVPwMUSBijEqUqhSN8pNyOlSUOai7JJzk/dvuWzX2PVw07u+UW0RWS9nOVq2vsWpo3uHhClZF4GLbhQhBo9dQmjC/pEm6y32jRgnEXoYUVkVVVmMNSpylVs8SEImLIKOT/BBSzlKZF2hqlr7cG98/46q8sv5uFk/LW7g2p1XudhoRsXLbtt1zZmvrsrEsS1GJWadoIfuoHj358w97ZPT0Vtq28HXsGZ9FzQOomdJ/Na4udhONdR1qAiToTGkR5i1bP/8pHmVUf8HvjF+/kpiuMrf/Jdr/xXgxyPBi6/5/yRi9V+9FcgYCLv/9Vn8Vw6LVE3jFIevZbQGvG/F3xtxXh4b7QfsxGp58kQE3ysPooN+FR9vm9xa5gy7S7qGMd1yzwDP1Y+h3f1+kqV6jXAAIp/FevOMgi3znMxuHkYcmhepOTUvkbk6r2KRO9evGfCOo1AC9/n4ZZ7o3TPPaGsaOmvEEgwYsWVeZPhhTBhxY17FGT3ztmrm/v6FpLRlb53A3ds99Lu9CVRboMsP4qMKoIo44gzPYCgKhkBtTQ0Z+I22BMXDeHypf+TsKUKv3Y02/8KIrATrkq+TV7YvYsAwNfDJ/VuQmBaope1E0rzTqavMvTck2WKe5Qi4YxS7h363N4GKdAIJhL1ICchVCuGYmIHPEZp+EAkk4YC0de/wDQu/ibVK/+4V5uz2vP0flq8967FDr90V4F86CmnFqK3lttmqh33SLoyEmiW6O/jst0Nib7mANNG2SFgkZGy0bLFXusXutUcBFfSXNNzkCopKKpRVqlKtlhq11aNe6IN+GIBBGIJhGEFGHi1PtIoaw1EKJZ/VtI6tytuzgEZ2+jysYN9+UtKFy8xSwnjRhcMncbJmjNpdMma/w5YpIRzo9aWwyq6FTZLtkS9sebojalo+nsXPTEWOGlrhbY6SLRXkuAoqLs8zsbRkeY/XDZWMrUQ+CvLenr3dmdv8EHTSNAf96pvc5Af87371YOEuuwBHQQndcTwQFWruRb0QlH0mjgc0Eg12+2XQ0ZafKlNH2/zR5ltk5LmXQAGIqTo6QNywYLeJll7gREGcnDtQ5BAxJ/xRYDcAAA=="

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff;base64,d09GRgABAAAAABXUAA8AAAAAJPQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY+I1MqY21hcAAAAdgAAADTAAACuIda97BjdnQgAAACrAAAABMAAAAgBtX+/mZwZ20AAALAAAAFkAAAC3CKkZBZZ2FzcAAACFAAAAAIAAAACAAAABBnbHlmAAAIWAAACf0AAA+aE9DL/mhlYWQAABJYAAAAMgAAADYPoZfIaGhlYQAAEowAAAAfAAAAJAc7A2hobXR4AAASrAAAAC0AAABYSVz//GxvY2EAABLcAAAALgAAAC4p+yYIbWF4cAAAEwwAAAAgAAAAIAElDApuYW1lAAATLAAAAXcAAALNzJ0dH3Bvc3QAABSkAAAAswAAAQOd6TSHcHJlcAAAFVgAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZA5jnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4vGD65Mgf9z2KIYg5imAkUZgTJAQDhCgvVAHic7ZLBccIwEEWfwCEBjMFJ3AIn2mDoiYI4caIKmvB9jxoaIH+9mwM9sJrnGf2RZM0+AR/AXBxEA+VKweuitEz5nNWUN5w132lova2tr6d6q/c6Po7PpxKse01eqmjfXqf9D09mOqnRDRZ88sVS/1nTsqFjq9U93/zwy6ClC97V+qe0ORu844F7skQ9xZLJU+JuLXHnlqj3WCILWCIfWCIzWOJvwRLZ0jsI/HbWBTKIbQM82wV41gfySz0FMk29BXJOvQeyTx0DvQMex4DhD8NHSkgAeJxjYEADEhDIHPQ/HYQBEloD1wB4nK1WaXfTRhQdeUmchCwlCy1qYcTEabBGJmzBgAlBsmMgXZytlaCLFDvpvvGJ3+Bf82Tac+g3flrvGy8kkLTncJqTo3fnzdXM22USWpLYC+uRlJsvxdTWJo3sPAnphk3LUXwoO3shZYrJ3wVREK2W2rcdh0REIlC1rrBEEPseWZpkfOhRRsu2pFdNyi096S5b40G9Vd9+GjrKsTuhpGYzdGg9siVVGFWiSKY9UtKmZaj6K0krvL/CzFfNUMKITiJpvBnG0EjeG2e0ymg1tuMoimyy3ChSJJrhQRR5lNUS5+SKCQzKB82Q8sqnEeXD/Iis2KOcVrBLttP8vi95p3c5P7Ffb1G25EAfyI7s4Ox0JV+EW1th3LST7ShUEXbXd0Js2exU/2aP8ppGA7crMr3QjGCpfIUQKz+hzP4hWS2cT/mSR6NaspETQetlTuxLPoHW44gpcc0YWdDd0QkR1P2SMwz2mD4e/PHeKZYLEwJ4HMt6RyWcCBMpYXM0SdowcmAlZYsqqfWumDjldVrEW8J+7drRl85o41B3YjxbDx1bOVHJ8WhSp5lMndpJzaMpDaKUdCZ4zK8DKD+iSV5tYzWJlUfTOGbGhEQiAi3cS1NBLDuxpCkEzaMZvbkbprl2LVqkyQP13KP39OZWuLnTU9oO9LNGf1anYjrYC9PpaeQv8Wna5SJF6frpGX5M4kHWAjKRLTbDlIMHb/0O0svXlhyF1wbY7u3zK6h91kTwpAH7G9AeT9UpCUyFmFWIVkBirWtZlsnVrBapyNR3Q5pWvqzTBIpyHBfHvoxx/V8zM5aYEr7fidOzIy49c+1LCNMcfJt1PZrXqcVyAXFmeU6nWZbv6zTH8gOd5lme1+kIS1unoyw/1GmB5Uc6HWN5QQuadN/BkIsw5AIOkDCEpQNDWF6CISwVDGG5CENYFmEIyyUYwvJjGMJyGYawvKxl1dRTSePamVgGbEJgYo4eucxF5WoquVRCu2hUakOeEm6VVBTPqn9loF488oY5sBZIl8iaXzHOlY9G5fjWFS1vGjtXwLHqbx+O9jnxUtaLhT8F/9XWVCW9Ys3Dk6vwG4aebCeqNql4dE2Xz1U9uv5fVFRYC/QbSIVYKMqybHBnIoSPOp2GaqCVQ8xszDy063XLmp/D/TcxQhZQ/fg3FBoL3INOWUlZ7eCs1dfbstw7g3I4EyxJMTfz+lb4IiOz0n6RWcqej3wecAWMSmXYagOtFbzZJzEPmd4kzwRxW1E2SNrYzgSJDRzzgHnznQQmYeqqDeRO4YYN+AVhbsF5J1yieqMsh+5F7PMopPxbp+JE9qhojMCz2Rthr+9Cym9xDCQ0+aV+DFQVoakYNRXQNFJuqAZfxtm6bULGDvQjKnbDsqziw8cW95WSbRmEfKSI1aOjn9Zeok6q3H5mFJfvnb4FwSA1MX9733RxkMq7WskyR20DU7calVPXmkPjVYfq5lH1vePsEzlrmm66Jx56X9Oq28HFXCyw9m0O0lImF9T1YYUNosvFpVDqZTRJ77gHGBYY0O9Qio3/q/rYfJ4rVYXRcSTfTtS30edgDPwP2H9H9QPQ92Pocg0uz/eaE59u9OFsma6iF+un6Dcwa625WboG3NB0A+IhR62OuMoNfKcGcXqkuRzpIeBj3RXiAcAmgMXgE921jOZTAKP5jDk+wOfMYdBkDoMt5jDYZs4awA5zGOwyh8Eecxh8wZx1gC+ZwyBkDoOIOQyeMCcAeMocBl8xh8HXzGHwDXPuA3zLHAYxcxgkzGGwr+nWMMwtXtBdoLZBVaADU09Y3MPiUFNlyP6OF4b9vUHM/sEgpv6o6faQ+hMvDPVng5j6i0FM/VXTnSH1N14Y6u8GMfUPg5j6TL8Yy2UGv4x8lwoHlF1sPufvifcP28VAuQABAAH//wAPeJyVV1tsXMUZnn/m3M96r3POWdu7x3vzrr12nODd9cLacTa32iYb4YSoxCAb04ZA7VysKgJUmhdSVU3VGmQFlCKU0sZ+qdoIWioEDw1SJR5QpfIADVLV54ZWFQ9FSDXNSf+ZXSdpIwRdrebMnPln/vv3/4cAwR/boBeJQ9LNnggQgClCgZ4mOD2Nm8e5x5nqDQHXQcuVoFjdBWOjfSAHl21Eg0x0OBr8LRJp4XMdTuHYilLXxY1IBFy5jG7A6Wi0FcFLyc1P6Af0+6RA/GZvrjuqK8huigEl9DSA4JfiXFGTQ/08ggy3gy4GwbW0xbouWeO259IP2mzX22zwGb29jkTW1yMrrphsbETuJoyMCAIp079YnNkkTwabRaIwRWq/ogJD4xzBByNHKRBGWvlKf76S19SeIXC4VsrjoOdzxXoNh1KtOlav4DAOo67nVEZdFs+41zPuspuB654PuPC9ZZyIxZvi7ccuvnU+7rx1M4JcyvNHdg7l8UmmmU5G6C2nMNjyilPzpJX+1y0xIcOo68TaRmLnnOBFt4GD4wzic73sT6XLG3zcHXTgOZ8HFxwHTsilsw7n02UYTgVPrwtiKccP2Bz9B0mTQjNLKGtHxQqRZiHCKkQYpei5eSkLWiOf9VzpOCFSHbY8lUVjzBXS8uqyM+4EFziHE07DLbf5FmBhyi+v8wk+1NmAZSmxuz4gQrQtSw1l8aUsjLLT4u0KmgXoEUIpHCVAoeX2F++wSztwsrniTqiOedlOBHlolxqXdim77uXg6XShkIbzl12URjDm0BCW4bzsTDiX0WJ+GTZQNJQ1eJFLWV5n5+hf2/6J6pQw9A8j7DQGCRA0Ehz3nFpHjnYUx9qBUot1wrnekeMcKjnONwb6OuojDxRgAgcHqilpHiEfFFNwvmM7YRkUXsrxDr3I9hFOtv0WZOoeeK0we7Rpt00DEIKZ3qZ5K5Xn3vA8qrpDJr3bR3Q1uAaDljVvp+zgG7YNlyzfmrfoL4KPgmtyasFP8QmXbHve8js+eYee6fA3vxL/VFzy77imbsItj3C6hGxT9jyyHgg+kkyQmQXfCh5rSwWDMNAmEIQi8sjNp9irmCcGSjBC5prRIihsoBRnVEHmhKE4WRSnhzAFw0WhmNcCZkjHSV1CuuQXbB6fezOV35aMq2r3UL1aDFMfxvq35AYf+rkehlKuiPmG2S7s6XhjQhf3T9znNNmThOPBOYyncfTod90j8JOu3uceeHJt7cnM17pN8/IJWj6QjVjpsEvjmbjS81lwjvOdmInw3fqRv7j9BxZg7f0XKI9qcX3h7ATt3sYtghKK2HsYdU6SHeSe5shAXzdqGw9hMgKd6qghEpUBu43hDe711IUmIFGzHYuIV5OwhaaYu2H4b7CVQAIb6luzFo9sRji4KXv2bTWsNVV4g2fM2bc0MVffPiT3XVB17a1Dlo+EYSSnISTQdmnw51uLJh7uUIj4uRmgLnOoyw6ys9nYBqCKIEItCDD03knMcmB0maiohwqLhCqKTHXlqNCzVSolSoXKFhYPQa64C4r5XJhyn1ZGx+pCOR/QS3puhE4yVMarjyEM8eiml4gdPLzSWGqNjLSWGnueGlRiWkul2sSVRx96dWVaaT5z8ZHDF3dOx4bp7zfD7rbowYNIeAbpGzUN1INKWLt/FvaduXTl0pl9k/dNxxOojyZ9I+pIhPSR7WSc7CVPkGPNxx7aTzVjMNsdw7gX+qmol0Y0ICcVSomuEX2ZhIlphM3FSBc1QhbVwNAWiG7b+hGi6/ZRYut26/Fjjy08Mvfg4QdaM1O7d/ECL4pfPqqmhwS8CAPUYp3q8yXrRCwb4z5UsqOTAJVSsZTXdFUaMSYgHGMjlm+D5jigHUUg9IGIBt8yCoYlh+dvT1ctvT3VrekgZBgU3qeGEZzf7FXU1zUF/m4ZY9X+YEd/FWqC7pclc9j9tVc2S78yLHgzuCpewm4xfsE8OEZjNz4Jccvi9PHdKobKg8jxxicj+/aM0IQUYt5Jgc/nrU6O/Az9oJNZ8pumOTmWNRWVCXSyEA7K7bRALzCVnsSowgRa1jWMrlNEFLXDoiX6usDz+3sPvGbfdUIBqjGqLWOB0e4+8f9cPzfXTBiGMWvMtg7cPzPeKOd7DxmIj6B7bmW0XkTbK/VeqHgJH7BB8Fw5oJ+8XFHPafnqLiogB/+lanE7DYOHTsVkriONnsNc0EoavPhoq9FnOzuCGnQVUilX+94r09q3E4ddc0fUNuyWqVDIrxbKrzh0RtdYTKEoes5Lfh5uQDRjZxyssNnnMiqn22jP5wDw40AbVjTNSkbhKFwIBZ8OvVdNfCfbo5lR5lrMohYYyUQUKXVKNUUxHx67FzIvh0NxC68G21HtEAY4YTdv3lxCP3Vh3zVM9pP55sN9ScqURBz7LtalYTHdCzqMgqmriGwa0xTEBECvgn6SWERTLG0RmzNRdBlZxPemoZuLxDC6jJmdE7UKTzg8X+T5vC1SZKtfK93Zr43Dnf2aVx0BjbuYE1zgoJYXwKH41OPoEDpu6WdDWkEPwVndgpB2Vga8WEyvvb+Gf/DLE/zqsWdn155s0okTq+urJyZg/1UHLrQPhcAy2ofOisA+a3U/sUZfeu+i9qPg5XTZubp/cumFn6+eaih7jr908NljVx1yh40iiPj3kPHmvaaB2iJUM+KDytgU4g7CCV0U9RhhcxEjS1WYukgUpUuZ8fJohWJeV3vbFsi29cbM/3Jtg99JPWHPV9RQqvblSom+YYldZ4fJPjLbPGiDaemWqZ/sAt2wdGNZE0UAiEw0/C5gyyEwMOOJAQvEskLTmERdbGZ3c+fE+H3VyshwAtG838kmeFi4WTY2CF154dBO81WUjhbO71Q3rNJpqIgg6LTNrsA+RzTvsmu+bq/aPr82HXbt57ENed52w9PXuJiIdWcDe5GtDSSHhbD9VejuvJl0eklRz/eT0eb2yVolp1BWzWZ647EoBROr3ZQCottVb38hFRv13sZ9svDpoqSlQaJ7CetfCV2nS6gXXsbiXtLRr6UOlI96Lpb/eqlYlzGvI0qIXfqHd9+djQ2LumhasUNiYVqeqPjDsVlc2WFdd7Gme5Yp1odilumJeu/qetimBaSIJ5JYJj1HHD4UczwkTibi8iwz794yUd8t3edkvYw1w7ealVpF9IiyY862S1Zdfj4s7L3x8d6Fhb3U27tAl25c37MAi7tpUjzkXR/SCfCwkHpN0aOLT6atG4tc3Nh/OxrEhRjhm+iaTXQNfBp2/xnBpb3ZaU7EfU/QH2KMpki26YdFd419CX6DEUAMglPomBCdGejNy29jafOEqyGDomiihMlR8PpYZdSjz8QtM/nhihbq+ma4R1u+0janrkcwudAgwWddKbWMu/++YjPLY1PSPP8B8cyO5QAAAHicY2BkYGAA4vf7ZCPi+W2+MnAzvwCKMFzz0xKF0f///U9nfsEcBORyMDCBRAFSLwwtAAB4nGNgZGBgDvqfBSRf/P/3/z/zCwagCAoQAwC2mQeoAHicY37BwMAMwoJQvACII6EYyGY6BcEI8f//4OoW/P8Pxi8QepisIeoBt34RkgAAAAAAAAAAOACCAMoBDgFUAZoB3gIeAl4C2AM+A6YEagU+BdAGOgbABz4HZAeMB80AAAABAAAAFgBoAAYAAAAAAAIAIAAwAHMAAAB1C3AAAAAAeJx1kN1qwjAYht/Mn20K29hgp8vRUMbqDwxBEASHnmwnMjwdtda2UhtJo+Bt7B52MbuJXcte2ziGspY0z/fky5evAXCNbwjkzxNHzgJnjHI+wSl6lgv0z5aL5BfLJVTxZrlM/265ggcElqu4wQcriOI5owU+LQtciUvLJ7gQd5YL9I+Wi+Se5RJuxavlMr1nuYKJSC1XcS++Bmq11VEQGlkb1GW72erI6VYqqihxY+muTah0KvtyrhLjx7FyPLXc89gP1rGr9+F+nvg6jVQiW05zr0Z+4mvX+LNd9XQTtI2Zy7lWSzm0GXKl1cL3jBMas+o2Gn/PwwAKK2yhEfGqQhhI1GjrnNtoooUOacoMycw8K0ICFzGNizV3hNlKyrjPMWeU0PrMiMkOPH6XR35MCrg/ZhV9tHoYT0i7M6LMS/blsLvDrBEpyTLdzM5+e0+x4WltWsNduy511pXE8KCG5H3s1hY0Hr2T3Yqh7aLB95//+wHmboRRAHicbY5JDsIwFEPjUkoH5vEUOVQpvzQizY8yUMHpUcuGBd74yZYli0R8VYr/OiPBDCnmyLBAjgIlKiyxwhobbLHDHgccccIZF5HwI2tq05BOrY4+v/Fg5FXdc01tGKFw6t5NlEU7BVPDlkz5rUbMBkem6SpHXr1JtlHrpBmq4GrfSepteKUtm7B4M/dSmXxyjiHt+Umbn5WsdZhfdW0ehWcX5Phn1XP0JC0rE8gJ8QFXpkEUAHicY/DewXAiKGIjI2Nf5AbGnRwMHAzJBRsZWJ02MTAyaIEYm7mYGDkgLD4GMIvNaRfTAaA0J5DN7rSLwQHCZmZw2ajC2BEYscGhI2Ijc4rLRjUQbxdHAwMji0NHckgESEkkEGzmYWLk0drB+L91A0vvRiYGFwAMdiP0AAA="

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = "data:application/octet-stream;base64,AAEAAAAPAIAAAwBwR1NVQiCLJXoAAAD8AAAAVE9TLzI+I1MqAAABUAAAAFZjbWFwh1r3sAAAAagAAAK4Y3Z0IAbV/v4AABjcAAAAIGZwZ22KkZBZAAAY/AAAC3BnYXNwAAAAEAAAGNQAAAAIZ2x5ZhPQy/4AAARgAAAPmmhlYWQPoZfIAAAT/AAAADZoaGVhBzsDaAAAFDQAAAAkaG10eElc//wAABRYAAAAWGxvY2Ep+yYIAAAUsAAAAC5tYXhwASUMCgAAFOAAAAAgbmFtZcydHR8AABUAAAACzXBvc3Sd6TSHAAAX0AAAAQNwcmVw5UErvAAAJGwAAACGAAEAAAAKADAAPgACREZMVAAObGF0bgAaAAQAAAAAAAAAAQAAAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAEDVgGQAAUAAAJ6ArwAAACMAnoCvAAAAeAAMQECAAACAAUDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBmRWQAQOgA8kUDUv9qAFoDUgCZAAAAAQAAAAAAAAAAAAUAAAADAAAALAAAAAQAAAGsAAEAAAAAAKYAAwABAAAALAADAAoAAAGsAAQAegAAABAAEAADAADoC+gR8EfwsvDI8N3yRf//AADoAOgO8EfwsvDI8N3yRf//AAAAAAAAAAAAAAAAAAAAAQAQACYALAAsACwALAAsAAAAAQACAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAAAEGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAQwAAAAAAAAAFQAA6AAAAOgAAAAAAQAA6AEAAOgBAAAAAgAA6AIAAOgCAAAAAwAA6AMAAOgDAAAABAAA6AQAAOgEAAAABQAA6AUAAOgFAAAABgAA6AYAAOgGAAAABwAA6AcAAOgHAAAACAAA6AgAAOgIAAAACQAA6AkAAOgJAAAACgAA6AoAAOgKAAAACwAA6AsAAOgLAAAADAAA6A4AAOgOAAAADQAA6A8AAOgPAAAADgAA6BAAAOgQAAAADwAA6BEAAOgRAAAAEAAA8EcAAPBHAAAAEQAA8LIAAPCyAAAAEgAA8MgAAPDIAAAAEwAA8N0AAPDdAAAAFAAA8kUAAPJFAAAAFQABAAAAAAOlApgAFQAdQBoPAQABAUcAAgECbwABAAFvAAAAZhQXFAMFFysBFAcBBiInASY0PwE2Mh8BATYyHwEWA6UQ/iAQLBD+6g8PTBAsEKQBbhAsEEwQAhYWEP4gDw8BFhAsEEwQEKUBbxAQTA8AAQAA/+8C1AKGACQAHkAbIhkQBwQAAgFHAwECAAJvAQEAAGYUHBQUBAUYKyUUDwEGIi8BBwYiLwEmND8BJyY0PwE2Mh8BNzYyHwEWFA8BFxYC1A9MECwQpKQQLBBMEBCkpBAQTBAsEKSkECwQTA8PpKQPcBYQTA8PpaUPD0wQLBCkpBAsEEwQEKSkEBBMDy4PpKQPAAEAAP/5AxIDCwAjAClAJgAEAwRvAAEAAXAFAQMAAANUBQEDAwBYAgEAAwBMIzMlIzMjBgUaKwEVFAYnIxUUBgcjIiY3NSMiJic1NDY3MzU0NjsBMhYXFTMyFgMSIBboIBZrFiAB6BceASAW6B4XaxceAegXHgG3axYgAekWHgEgFekeF2sXHgHoFiAgFuggAAEAAP/PA4MDCwAeACBAHRgPAgABAUcAAgECbwMBAQABbwAAAGYVNRcUBAUYKwEUBwEGIicBJjQ/ATYyHwERNDY3MzIWFRE3NjIfARYDgxX+lRY6Ff6VFRUpFjoVpCoeRx0qpRQ7FikVAYIeFP6UFRUBbBQ7FikVFaQBiR0qASwc/nekFRUpFgABAAD/iANZAu0AHQAkQCEAAgMCbwABAAFwAAMAAANUAAMDAFgAAAMATCYXFiMEBRgrARUUBiMhFxYUDwEGIicBJjQ3ATYyHwEWFA8BITIWA1kkHf53pBUVKhU7Ff6UFBQBbBU6FioVFaQBiR0kAV5HHiqkFDwUKxQUAWwVOhYBaxUVKRY6FqQoAAAAAAEAAP+IAzUC7QAeACRAIQADAgNvAAABAHAAAgEBAlQAAgIBWAABAgFMFiUmFAQFGCsBFAcBBiIvASY0PwEhIiY9ATQ2FyEnJjQ/ATYyFwEWAzUU/pUWOhUqFhaj/ncdJCQdAYmjFhYqFToWAWsUAToeFP6UFBQqFTwVoyoeRx4qAaUUPBQqFRX+lRQAAQAA/7EDgwLnAB4AIEAdEAcCAAMBRwADAANvAgEAAQBvAAEBZhcVNRQEBRgrARQPAQYiLwERFAYHIyImNREHBiIvASY0NwE2MhcBFgODFSkWOxSlKB9HHiqkFDwUKhUVAWsUPBUBaxUBNBwWKhUVpP53HSQBJhwBiaQVFSoVOxUBaxUV/pUWAAEAAP/AApgDRAAUAC21AQEAAQFHS7AkUFhACwAAAQBwAAEBDAFJG0AJAAEAAW8AAABmWbQXFwIFFisJAhYUDwEGIicBJjQ3ATYyHwEWFAKO/tcBKQoKXQscC/5iCwsBngoeCl0KAqr+2P7XCh4KXQoKAZ8KHgoBngsLXQoeAAAAAQAA/8ACdANEABQALbUJAQABAUdLsCRQWEALAAABAHAAAQEMAUkbQAkAAQABbwAAAGZZtBwSAgUWKwkBBiIvASY0NwkBJjQ/ATYyFwEWFAJq/mILHAtdCwsBKP7YCwtdCh4KAZ4KAWn+YQoKXQscCwEpASgLHAtdCwv+YgscAAADAAD/dgOgAwsACAAUAC4AWUAQJgEEAygnEgMCBAABAQADR0uwIVBYQBoAAwQDbwAEAgRvAAIAAm8AAAEAbwABAQ0BSRtAGAADBANvAAQCBG8AAgACbwAAAQBvAAEBZlm3HCMtGBIFBRkrNzQmDgIeATYlAQYiLwEmNDcBHgElFAcOASciJjQ2NzIWFxYUDwEVFzY/ATYyFtYUHhQCGBoYAWb+gxU6FjsVFQF8FlQBmQ0bgk9okpJoIEYZCQmjbAIqSyEPCh0OFgISIBIEGvb+gxQUPRQ7FgF8N1TdFiVLXgGS0JACFBAGEgdefTwCGS0UCgAAAgAA/7EDWgMLABgAMAAxQC4oHxkDAgQSDAMDAAECRwAEAgRvAAIDAm8AAwEDbwABAAFvAAAAZjoUFxo3BQUZKwEUDwEXFhQGByMiJic1ND4BHwE3NjIfARYBFRQOAS8BBwYiLwEmND8BJyY0NjczMhYBpQW5UAoUD/oPFAEWHAtQugUOBkAFAbQUIAlQuQYOBkAFBbpRChQP+g8WAQUHBrlRCh4UARYO+g8UAgxQuQYGPwYB2/oPFAIMULkGBkAFDga5UQoeFAEWAAAAAf/+/7EDWQMLADAAPUA6LQEBBQkBAAECRwAAAQMBAANtAAMCAQMCawAFAAEABQFgAAIEBAJUAAICBFgABAIETCcnEyckMwYFGisBFRQGKwEiJj8BJiMiDgIUHgIzMjY3PgEfAR4BBw4BByIuAj4DMzIWFzc2FgNZFBD6FxMRTVJwOmpMLi5MajpCdikEEQZMBQIGPK5fV6BwSARAeJhbUpg9SBEsAsP6DhYtEE1NLkxqdGpMLjo1BgEFTQQOBkpQAUR0nq6edEQ+OUgSEwAAAAYAAP+xAxIDCwAPAB8ALwA7AEMAZwBkQGFXRQIGCCkhGREJAQYAAQJHBQMCAQYABgEAbQQCAgAHBgAHawAOAAkIDglgDw0CCAwKAgYBCAZeAAcLCwdUAAcHC1gACwcLTGVkYV5bWVNST0xJR0E/FCQUJiYmJiYjEAUdKwERFAYrASImNRE0NjsBMhYXERQGKwEiJjURNDY7ATIWFxEUBisBIiY1ETQ2OwEyFhMRIREUHgEzITI+AQEzJyYnIwYHBRUUBisBERQGIyEiJicRIyImPQE0NjsBNz4BNzMyFh8BMzIWAR4KCCQICgoIJAgKjwoIJAgKCggkCAqOCgckCAoKCCQHCkj+DAgIAgHQAggI/on6GwQFsQYEAesKCDY0Jf4wJTQBNQgKCgisJwksFrIXKgknrQgKAbf+vwgKCggBQQgKCgj+vwgKCggBQQgKCgj+vwgKCggBQQgKCv5kAhH97wwUCgoUAmVBBQEBBVMkCAr97y5EQi4CEwoIJAgKXRUcAR4UXQoAAgAA/7EDoQMLAAcAUACzQAk+NiEJBAUDAUdLsApQWEAqAAEAAW8ABQMCAwUCbQACBAMCBGsHBgIEBG4AAAMDAFIAAAADVgADAANKG0uwC1BYQCoAAQABbwAFAwIDBQJtBAECBgMCBmsHAQYGbgAAAwMAUgAAAANWAAMAA0obQCoAAQABbwAFAwIDBQJtAAIEAwIEawcGAgQEbgAAAwMAUgAAAANWAAMAA0pZWUATCAgIUAhQTEtKSTs6KiMbUQgFFisBBxcWMzI3JgE3PgQ3GwEzFxMeARceARcWFx4BFxYVFAYXIiYHIgYjND8CNj8BNj8BNic0Ji8CDgEXFB4BHwEWNxYVFAciJiMiBicGAZVfTDofCxUw/jUBDSQcHBYGhJxIBnITUhYJMBALCAtMCQQCASOOJCqcFQJJBwYDEQQCBQMCIhcY+w46ARAgCyAVAgEBIYIgBRQCLQIa+wEBAY3+BiwEBgYKGBABWAGUDP70K8o0E3ohGgYJEAMWCgMKAgoBCBgTEAEBAQcCAgYEBAlaNjgBIJoODBIKAgUDAQsVBQsMBgEIAAP///9qA6EDDQAjACwARQBdQFofGAIDBBMSAQMAAw0GAgEAQwEHATIBCQcFRwAEBgMGBANtAAEABwABB20ACgAGBAoGYAUBAwIBAAEDAGAABwAJCAcJYAAICA0IST08NTMUExUUIyYUIyMLBR0rARUUBicjFRQGJyMiJjc1IyImJzU0NjsBNTQ2OwEyFhcVMzIWFzQuAQYUFj4BARQGIi8BBiMiLgI+BB4CFxQHFxYCOwoHfQwGJAcMAX0HCgEMBn0KCCQHCgF9BwpIktCSktCSAR4qPBS/ZHtQkmhAAjxsjqSObDwBRb8VAZQkBwwBfQcMAQoIfQoIJAcKfQgKCgh9ChlnkgKWypgGjP6aHSoVv0U+apCijm46BEJmlk17ZL8VAAAD////agOhAw0ADwAYADEAO0A4CQgBAwABLwEDAB4BBQMDRwAGAAIBBgJgAAEAAAMBAGAAAwAFBAMFYAAEBA0ESRcjFBMVJiMHBRsrARUUBichIiYnNTQ2MyEyFhc0LgEGFBY+AQEUBiIvAQYjIi4CPgQeAhcUBxcWAjsKB/6+BwoBDAYBQgcKSJLQkpLQkgEeKjwUv2R7UJJoQAI8bI6kjmw8AUW/FQGUJAcMAQoIJAcKChlnkgKWypgGjP6aHSoVv0U+apCijm46BEJmlk17ZL8VAAEAAP9qA+gDUgBEAFBATQsBCQoHCgkHbQ0BBwgKBwhrBgEAAQIBAAJtBAECAwECA2sMAQgFAQEACAFeAAoKDEgAAwMNA0lBQD08Ozk0My4sExcTESUVIRMUDgUdKwEUDwEGIiY9ASMVMzIWFA8BBiIvASY0NjsBNSMVFAYiLwEmND8BNjIWHQEzNSMiJjQ/ATYyHwEWFAYrARUzNTQ2Mh8BFgPoC44LHhTXSA4WC48KHgqPCxYOSNcUHgqPCwuPCh4U10gOFguPCxwLjwsWDkjXFB4LjgsBXg4LjwsWDkjXFB4KjwsLjwoeFNdIDhYLjwscC48LFg5I1xQeC44LC44LHhTXSA4WC48KAAABAAD/sQNaAwsARQAyQC8+NTMiBAIDNCEgGxIREAIBCQACAkcEAQMCA28FAQIAAm8BAQAAZiY6Nxs6OQYFGisBBxc3NhYdARQGKwEiJyY/AScHFxYHBisBIiYnNTQ2HwE3JwcGIyInJj0BNDY7ATIXFg8BFzcnJjc2OwEyFgcVFAcGIyInAszGxlARLBQQ+hcJChFRxsZQEQkKF/oPFAEsEVDGxlALDgcHFhYO+hcKCRFQxsZREQoJF/oPFgEWBwcOCwIkxsZQEhMY+g4WFxURUcbGUREVFxYO+hgTElDGxlALAwkY+g4WFxURUcbGUREVFxYO+hgJAwsAAAABAAD/sQNZAwsADwARQA4AAQABbwAAAGY1MwIFFisBERQGByEiJjURNDY3ITIWA1leQ/3pQ15eQwIXQ14Cav3oQl4BYEECGEJeAWAAAQAA/9UCPAEXAA4AF0AUAAEAAQFHAAEAAW8AAABmJhQCBRYrJRQPAQYiLwEmNDY3ITIWAjsK+gscC/oLFg4B9A4W8w8K+gsL+goeFAEWAAABAAD/ZwKKA1IAHAAhQB4OAQEAAUcAAAIBAgABbQABAW4AAgIMAkkoGyMDBRcrARYHBisBExYGDwEGJi8BBwYjIicmNRE0NzYzMhcCeBIKCRjVcAYMDWMOGgZrrgsOBwcWFgcHDwoBDBEVF/72DRwFKgYMDfyuCwMKFwNHGAkDCwAAAAABAAAAAQAA775IPF8PPPUACwPoAAAAANZOKhUAAAAA1k4qFf/+/2cD6ANSAAAACAACAAAAAAAAAAEAAANS/2oAAAPo//7//wPoAAEAAAAAAAAAAAAAAAAAAAAWA+gAAAPoAAADEQAAAxEAAAOgAAADWQAAA1kAAAOgAAACygAAAsoAAAOgAAADWQAAA1n//gMRAAADoAAAA6D//wOg//8D6AAAA1kAAANZAAACOwAAAsoAAAAAAAAAOACCAMoBDgFUAZoB3gIeAl4C2AM+A6YEagU+BdAGOgbABz4HZAeMB80AAAABAAAAFgBoAAYAAAAAAAIAIAAwAHMAAAB1C3AAAAAAAAAAEgDeAAEAAAAAAAAANQAAAAEAAAAAAAEACAA1AAEAAAAAAAIABwA9AAEAAAAAAAMACABEAAEAAAAAAAQACABMAAEAAAAAAAUACwBUAAEAAAAAAAYACABfAAEAAAAAAAoAKwBnAAEAAAAAAAsAEwCSAAMAAQQJAAAAagClAAMAAQQJAAEAEAEPAAMAAQQJAAIADgEfAAMAAQQJAAMAEAEtAAMAAQQJAAQAEAE9AAMAAQQJAAUAFgFNAAMAAQQJAAYAEAFjAAMAAQQJAAoAVgFzAAMAAQQJAAsAJgHJQ29weXJpZ2h0IChDKSAyMDE3IGJ5IG9yaWdpbmFsIGF1dGhvcnMgQCBmb250ZWxsby5jb21mb250ZWxsb1JlZ3VsYXJmb250ZWxsb2ZvbnRlbGxvVmVyc2lvbiAxLjBmb250ZWxsb0dlbmVyYXRlZCBieSBzdmcydHRmIGZyb20gRm9udGVsbG8gcHJvamVjdC5odHRwOi8vZm9udGVsbG8uY29tAEMAbwBwAHkAcgBpAGcAaAB0ACAAKABDACkAIAAyADAAMQA3ACAAYgB5ACAAbwByAGkAZwBpAG4AYQBsACAAYQB1AHQAaABvAHIAcwAgAEAAIABmAG8AbgB0AGUAbABsAG8ALgBjAG8AbQBmAG8AbgB0AGUAbABsAG8AUgBlAGcAdQBsAGEAcgBmAG8AbgB0AGUAbABsAG8AZgBvAG4AdABlAGwAbABvAFYAZQByAHMAaQBvAG4AIAAxAC4AMABmAG8AbgB0AGUAbABsAG8ARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAAIAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgECAQMBBAEFAQYBBwEIAQkBCgELAQwBDQEOAQ8BEAERARIBEwEUARUBFgEXAAJvawZjYW5jZWwEcGx1cwhkb3duLWJpZwhsZWZ0LWJpZwlyaWdodC1iaWcGdXAtYmlnCWxlZnQtb3BlbgpyaWdodC1vcGVuBndyZW5jaAtyZXNpemUtZnVsbAJjdwt0cmFzaC1lbXB0eQRmb250B3pvb20taW4Iem9vbS1vdXQEbW92ZQ9yZXNpemUtZnVsbC1hbHQFYmxhbmsJc29ydC1kb3duDW1vdXNlLXBvaW50ZXIAAAAAAQAB//8ADwAAAAAAAAAAAAAAAAAAAAAAGAAYABgAGANS/2cDUv9nsAAsILAAVVhFWSAgS7gADlFLsAZTWliwNBuwKFlgZiCKVViwAiVhuQgACABjYyNiGyEhsABZsABDI0SyAAEAQ2BCLbABLLAgYGYtsAIsIGQgsMBQsAQmWrIoAQpDRWNFUltYISMhG4pYILBQUFghsEBZGyCwOFBYIbA4WVkgsQEKQ0VjRWFksChQWCGxAQpDRWNFILAwUFghsDBZGyCwwFBYIGYgiophILAKUFhgGyCwIFBYIbAKYBsgsDZQWCGwNmAbYFlZWRuwAStZWSOwAFBYZVlZLbADLCBFILAEJWFkILAFQ1BYsAUjQrAGI0IbISFZsAFgLbAELCMhIyEgZLEFYkIgsAYjQrEBCkNFY7EBCkOwAWBFY7ADKiEgsAZDIIogirABK7EwBSWwBCZRWGBQG2FSWVgjWSEgsEBTWLABKxshsEBZI7AAUFhlWS2wBSywB0MrsgACAENgQi2wBiywByNCIyCwACNCYbACYmawAWOwAWCwBSotsAcsICBFILALQ2O4BABiILAAUFiwQGBZZrABY2BEsAFgLbAILLIHCwBDRUIqIbIAAQBDYEItsAkssABDI0SyAAEAQ2BCLbAKLCAgRSCwASsjsABDsAQlYCBFiiNhIGQgsCBQWCGwABuwMFBYsCAbsEBZWSOwAFBYZVmwAyUjYUREsAFgLbALLCAgRSCwASsjsABDsAQlYCBFiiNhIGSwJFBYsAAbsEBZI7AAUFhlWbADJSNhRESwAWAtsAwsILAAI0KyCwoDRVghGyMhWSohLbANLLECAkWwZGFELbAOLLABYCAgsAxDSrAAUFggsAwjQlmwDUNKsABSWCCwDSNCWS2wDywgsBBiZrABYyC4BABjiiNhsA5DYCCKYCCwDiNCIy2wECxLVFixBGREWSSwDWUjeC2wESxLUVhLU1ixBGREWRshWSSwE2UjeC2wEiyxAA9DVVixDw9DsAFhQrAPK1mwAEOwAiVCsQwCJUKxDQIlQrABFiMgsAMlUFixAQBDYLAEJUKKiiCKI2GwDiohI7ABYSCKI2GwDiohG7EBAENgsAIlQrACJWGwDiohWbAMQ0ewDUNHYLACYiCwAFBYsEBgWWawAWMgsAtDY7gEAGIgsABQWLBAYFlmsAFjYLEAABMjRLABQ7AAPrIBAQFDYEItsBMsALEAAkVUWLAPI0IgRbALI0KwCiOwAWBCIGCwAWG1EBABAA4AQkKKYLESBiuwcisbIlktsBQssQATKy2wFSyxARMrLbAWLLECEystsBcssQMTKy2wGCyxBBMrLbAZLLEFEystsBossQYTKy2wGyyxBxMrLbAcLLEIEystsB0ssQkTKy2wHiwAsA0rsQACRVRYsA8jQiBFsAsjQrAKI7ABYEIgYLABYbUQEAEADgBCQopgsRIGK7ByKxsiWS2wHyyxAB4rLbAgLLEBHistsCEssQIeKy2wIiyxAx4rLbAjLLEEHistsCQssQUeKy2wJSyxBh4rLbAmLLEHHistsCcssQgeKy2wKCyxCR4rLbApLCA8sAFgLbAqLCBgsBBgIEMjsAFgQ7ACJWGwAWCwKSohLbArLLAqK7AqKi2wLCwgIEcgILALQ2O4BABiILAAUFiwQGBZZrABY2AjYTgjIIpVWCBHICCwC0NjuAQAYiCwAFBYsEBgWWawAWNgI2E4GyFZLbAtLACxAAJFVFiwARawLCqwARUwGyJZLbAuLACwDSuxAAJFVFiwARawLCqwARUwGyJZLbAvLCA1sAFgLbAwLACwAUVjuAQAYiCwAFBYsEBgWWawAWOwASuwC0NjuAQAYiCwAFBYsEBgWWawAWOwASuwABa0AAAAAABEPiM4sS8BFSotsDEsIDwgRyCwC0NjuAQAYiCwAFBYsEBgWWawAWNgsABDYTgtsDIsLhc8LbAzLCA8IEcgsAtDY7gEAGIgsABQWLBAYFlmsAFjYLAAQ2GwAUNjOC2wNCyxAgAWJSAuIEewACNCsAIlSYqKRyNHI2EgWGIbIVmwASNCsjMBARUUKi2wNSywABawBCWwBCVHI0cjYbAJQytlii4jICA8ijgtsDYssAAWsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgsAhDIIojRyNHI2EjRmCwBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2EjICCwBCYjRmE4GyOwCENGsAIlsAhDRyNHI2FgILAEQ7ACYiCwAFBYsEBgWWawAWNgIyCwASsjsARDYLABK7AFJWGwBSWwAmIgsABQWLBAYFlmsAFjsAQmYSCwBCVgZCOwAyVgZFBYIRsjIVkjICCwBCYjRmE4WS2wNyywABYgICCwBSYgLkcjRyNhIzw4LbA4LLAAFiCwCCNCICAgRiNHsAErI2E4LbA5LLAAFrADJbACJUcjRyNhsABUWC4gPCMhG7ACJbACJUcjRyNhILAFJbAEJUcjRyNhsAYlsAUlSbACJWG5CAAIAGNjIyBYYhshWWO4BABiILAAUFiwQGBZZrABY2AjLiMgIDyKOCMhWS2wOiywABYgsAhDIC5HI0cjYSBgsCBgZrACYiCwAFBYsEBgWWawAWMjICA8ijgtsDssIyAuRrACJUZSWCA8WS6xKwEUKy2wPCwjIC5GsAIlRlBYIDxZLrErARQrLbA9LCMgLkawAiVGUlggPFkjIC5GsAIlRlBYIDxZLrErARQrLbA+LLA1KyMgLkawAiVGUlggPFkusSsBFCstsD8ssDYriiAgPLAEI0KKOCMgLkawAiVGUlggPFkusSsBFCuwBEMusCsrLbBALLAAFrAEJbAEJiAuRyNHI2GwCUMrIyA8IC4jOLErARQrLbBBLLEIBCVCsAAWsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgR7AEQ7ACYiCwAFBYsEBgWWawAWNgILABKyCKimEgsAJDYGQjsANDYWRQWLACQ2EbsANDYFmwAyWwAmIgsABQWLBAYFlmsAFjYbACJUZhOCMgPCM4GyEgIEYjR7ABKyNhOCFZsSsBFCstsEIssDUrLrErARQrLbBDLLA2KyEjICA8sAQjQiM4sSsBFCuwBEMusCsrLbBELLAAFSBHsAAjQrIAAQEVFBMusDEqLbBFLLAAFSBHsAAjQrIAAQEVFBMusDEqLbBGLLEAARQTsDIqLbBHLLA0Ki2wSCywABZFIyAuIEaKI2E4sSsBFCstsEkssAgjQrBIKy2wSiyyAABBKy2wSyyyAAFBKy2wTCyyAQBBKy2wTSyyAQFBKy2wTiyyAABCKy2wTyyyAAFCKy2wUCyyAQBCKy2wUSyyAQFCKy2wUiyyAAA+Ky2wUyyyAAE+Ky2wVCyyAQA+Ky2wVSyyAQE+Ky2wViyyAABAKy2wVyyyAAFAKy2wWCyyAQBAKy2wWSyyAQFAKy2wWiyyAABDKy2wWyyyAAFDKy2wXCyyAQBDKy2wXSyyAQFDKy2wXiyyAAA/Ky2wXyyyAAE/Ky2wYCyyAQA/Ky2wYSyyAQE/Ky2wYiywNysusSsBFCstsGMssDcrsDsrLbBkLLA3K7A8Ky2wZSywABawNyuwPSstsGYssDgrLrErARQrLbBnLLA4K7A7Ky2waCywOCuwPCstsGkssDgrsD0rLbBqLLA5Ky6xKwEUKy2wayywOSuwOystsGwssDkrsDwrLbBtLLA5K7A9Ky2wbiywOisusSsBFCstsG8ssDorsDsrLbBwLLA6K7A8Ky2wcSywOiuwPSstsHIsswkEAgNFWCEbIyFZQiuwCGWwAyRQeLABFTAtAEu4AMhSWLEBAY5ZsAG5CAAIAGNwsQAFQrIAAQAqsQAFQrMKAgEIKrEABUKzDgABCCqxAAZCugLAAAEACSqxAAdCugBAAAEACSqxAwBEsSQBiFFYsECIWLEDZESxJgGIUVi6CIAAAQRAiGNUWLEDAERZWVlZswwCAQwquAH/hbAEjbECAEQAAA=="

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxtZXRhZGF0YT5Db3B5cmlnaHQgKEMpIDIwMTcgYnkgb3JpZ2luYWwgYXV0aG9ycyBAIGZvbnRlbGxvLmNvbTwvbWV0YWRhdGE+CjxkZWZzPgo8Zm9udCBpZD0iZm9udGVsbG8iIGhvcml6LWFkdi14PSIxMDAwIiA+Cjxmb250LWZhY2UgZm9udC1mYW1pbHk9ImZvbnRlbGxvIiBmb250LXdlaWdodD0iNDAwIiBmb250LXN0cmV0Y2g9Im5vcm1hbCIgdW5pdHMtcGVyLWVtPSIxMDAwIiBhc2NlbnQ9Ijg1MCIgZGVzY2VudD0iLTE1MCIgLz4KPG1pc3NpbmctZ2x5cGggaG9yaXotYWR2LXg9IjEwMDAiIC8+CjxnbHlwaCBnbHlwaC1uYW1lPSJvayIgdW5pY29kZT0iJiN4ZTgwMDsiIGQ9Ik05MzMgNTM0cTAtMjItMTYtMzhsLTQwNC00MDQtNzYtNzZxLTE2LTE1LTM4LTE1dC0zOCAxNWwtNzYgNzYtMjAyIDIwMnEtMTUgMTYtMTUgMzh0MTUgMzhsNzYgNzZxMTYgMTYgMzggMTZ0MzgtMTZsMTY0LTE2NSAzNjYgMzY3cTE2IDE2IDM4IDE2dDM4LTE2bDc2LTc2cTE2LTE1IDE2LTM4eiIgaG9yaXotYWR2LXg9IjEwMDAiIC8+Cgo8Z2x5cGggZ2x5cGgtbmFtZT0iY2FuY2VsIiB1bmljb2RlPSImI3hlODAxOyIgZD0iTTcyNCAxMTJxMC0yMi0xNS0zOGwtNzYtNzZxLTE2LTE1LTM4LTE1dC0zOCAxNWwtMTY0IDE2NS0xNjQtMTY1cS0xNi0xNS0zOC0xNXQtMzggMTVsLTc2IDc2cS0xNiAxNi0xNiAzOHQxNiAzOGwxNjQgMTY0LTE2NCAxNjRxLTE2IDE2LTE2IDM4dDE2IDM4bDc2IDc2cTE2IDE2IDM4IDE2dDM4LTE2bDE2NC0xNjQgMTY0IDE2NHExNiAxNiAzOCAxNnQzOC0xNmw3Ni03NnExNS0xNSAxNS0zOHQtMTUtMzhsLTE2NC0xNjQgMTY0LTE2NHExNS0xNSAxNS0zOHoiIGhvcml6LWFkdi14PSI3ODUuNyIgLz4KCjxnbHlwaCBnbHlwaC1uYW1lPSJwbHVzIiB1bmljb2RlPSImI3hlODAyOyIgZD0iTTc4NiA0Mzl2LTEwN3EwLTIyLTE2LTM4dC0zOC0xNWgtMjMydi0yMzNxMC0yMi0xNi0zN3QtMzgtMTZoLTEwN3EtMjIgMC0zOCAxNnQtMTUgMzd2MjMzaC0yMzJxLTIzIDAtMzggMTV0LTE2IDM4djEwN3EwIDIzIDE2IDM4dDM4IDE2aDIzMnYyMzJxMCAyMiAxNSAzOHQzOCAxNmgxMDdxMjMgMCAzOC0xNnQxNi0zOHYtMjMyaDIzMnEyMyAwIDM4LTE2dDE2LTM4eiIgaG9yaXotYWR2LXg9Ijc4NS43IiAvPgoKPGdseXBoIGdseXBoLW5hbWU9ImRvd24tYmlnIiB1bmljb2RlPSImI3hlODAzOyIgZD0iTTg5OSAzODZxMC0zMC0yMS01MGwtMzYzLTM2NHEtMjItMjEtNTEtMjEtMjkgMC01MCAyMWwtMzYzIDM2NHEtMjEgMjAtMjEgNTAgMCAyOSAyMSA1MWw0MSA0MXEyMiAyMSA1MSAyMSAyOSAwIDUwLTIxbDE2NC0xNjR2MzkzcTAgMjkgMjEgNTB0NTEgMjJoNzFxMjkgMCA1MC0yMnQyMS01MHYtMzkzbDE2NSAxNjRxMjAgMjEgNTAgMjEgMjkgMCA1MS0yMWw0MS00MXEyMS0yMiAyMS01MXoiIGhvcml6LWFkdi14PSI5MjguNiIgLz4KCjxnbHlwaCBnbHlwaC1uYW1lPSJsZWZ0LWJpZyIgdW5pY29kZT0iJiN4ZTgwNDsiIGQ9Ik04NTcgMzUwdi03MXEwLTMwLTE4LTUxdC00Ny0yMWgtMzkzbDE2NC0xNjRxMjEtMjAgMjEtNTB0LTIxLTUwbC00Mi00M3EtMjEtMjAtNTEtMjAtMjkgMC01MCAyMGwtMzY0IDM2NHEtMjAgMjEtMjAgNTAgMCAyOSAyMCA1MWwzNjQgMzYzcTIxIDIxIDUwIDIxIDI5IDAgNTEtMjFsNDItNDFxMjEtMjIgMjEtNTF0LTIxLTUxbC0xNjQtMTY0aDM5M3EyOSAwIDQ3LTIwdDE4LTUxeiIgaG9yaXotYWR2LXg9Ijg1Ny4xIiAvPgoKPGdseXBoIGdseXBoLW5hbWU9InJpZ2h0LWJpZyIgdW5pY29kZT0iJiN4ZTgwNTsiIGQ9Ik04MjEgMzE0cTAtMzAtMjAtNTBsLTM2My0zNjRxLTIyLTIwLTUxLTIwLTI5IDAtNTAgMjBsLTQyIDQycS0yMiAyMS0yMiA1MXQyMiA1MWwxNjMgMTYzaC0zOTNxLTI5IDAtNDcgMjF0LTE4IDUxdjcxcTAgMzAgMTggNTF0NDcgMjBoMzkzbC0xNjMgMTY1cS0yMiAyMC0yMiA1MHQyMiA1MGw0MiA0MnEyMSAyMSA1MCAyMSAyOSAwIDUxLTIxbDM2My0zNjNxMjAtMjAgMjAtNTF6IiBob3Jpei1hZHYteD0iODU3LjEiIC8+Cgo8Z2x5cGggZ2x5cGgtbmFtZT0idXAtYmlnIiB1bmljb2RlPSImI3hlODA2OyIgZD0iTTg5OSAzMDhxMC0yOC0yMS01MGwtNDEtNDJxLTIyLTIxLTUxLTIxLTMwIDAtNTAgMjFsLTE2NSAxNjR2LTM5M3EwLTI5LTIwLTQ3dC01MS0xOWgtNzFxLTMwIDAtNTEgMTl0LTIxIDQ3djM5M2wtMTY0LTE2NHEtMjAtMjEtNTAtMjF0LTUwIDIxbC00MiA0MnEtMjEgMjEtMjEgNTAgMCAzMCAyMSA1MWwzNjMgMzYzcTIwIDIxIDUwIDIxIDMwIDAgNTEtMjFsMzYzLTM2M3EyMS0yMiAyMS01MXoiIGhvcml6LWFkdi14PSI5MjguNiIgLz4KCjxnbHlwaCBnbHlwaC1uYW1lPSJsZWZ0LW9wZW4iIHVuaWNvZGU9IiYjeGU4MDc7IiBkPSJNNjU0IDY4MmwtMjk3LTI5NiAyOTctMjk3cTEwLTEwIDEwLTI1dC0xMC0yNWwtOTMtOTNxLTExLTEwLTI1LTEwdC0yNSAxMGwtNDE0IDQxNXEtMTEgMTAtMTEgMjV0MTEgMjVsNDE0IDQxNHExMCAxMSAyNSAxMXQyNS0xMWw5My05M3ExMC0xMCAxMC0yNXQtMTAtMjV6IiBob3Jpei1hZHYteD0iNzE0LjMiIC8+Cgo8Z2x5cGggZ2x5cGgtbmFtZT0icmlnaHQtb3BlbiIgdW5pY29kZT0iJiN4ZTgwODsiIGQ9Ik02MTggMzYxbC00MTQtNDE1cS0xMS0xMC0yNS0xMHQtMjUgMTBsLTkzIDkzcS0xMSAxMS0xMSAyNXQxMSAyNWwyOTYgMjk3LTI5NiAyOTZxLTExIDExLTExIDI1dDExIDI1bDkzIDkzcTEwIDExIDI1IDExdDI1LTExbDQxNC00MTRxMTAtMTEgMTAtMjV0LTEwLTI1eiIgaG9yaXotYWR2LXg9IjcxNC4zIiAvPgoKPGdseXBoIGdseXBoLW5hbWU9IndyZW5jaCIgdW5pY29kZT0iJiN4ZTgwOTsiIGQ9Ik0yMTQgMjlxMCAxNC0xMCAyNXQtMjUgMTAtMjUtMTAtMTEtMjUgMTEtMjUgMjUtMTEgMjUgMTEgMTAgMjV6IG0zNjAgMjM0bC0zODEtMzgxcS0yMS0yMC01MC0yMC0yOSAwLTUxIDIwbC01OSA2MXEtMjEgMjAtMjEgNTAgMCAyOSAyMSA1MWwzODAgMzgwcTIyLTU1IDY0LTk3dDk3LTY0eiBtMzU0IDI0M3EwLTIyLTEzLTU5LTI3LTc1LTkyLTEyMnQtMTQ0LTQ2cS0xMDQgMC0xNzcgNzN0LTczIDE3NyA3MyAxNzYgMTc3IDc0cTMyIDAgNjctMTB0NjAtMjZxOS02IDktMTV0LTktMTZsLTE2My05NHYtMTI1bDEwOC02MHEyIDIgNDQgMjd0NzUgNDUgNDAgMjBxOCAwIDEzLTV0NS0xNHoiIGhvcml6LWFkdi14PSI5MjguNiIgLz4KCjxnbHlwaCBnbHlwaC1uYW1lPSJyZXNpemUtZnVsbCIgdW5pY29kZT0iJiN4ZTgwYTsiIGQ9Ik00MjEgMjYxcTAtNy01LTEzbC0xODUtMTg1IDgwLTgxcTEwLTEwIDEwLTI1dC0xMC0yNS0yNS0xMWgtMjUwcS0xNSAwLTI1IDExdC0xMSAyNXYyNTBxMCAxNSAxMSAyNXQyNSAxMSAyNS0xMWw4MC04MCAxODYgMTg1cTUgNiAxMiA2dDEzLTZsNjQtNjNxNS02IDUtMTN6IG00MzYgNDgydi0yNTBxMC0xNS0xMC0yNXQtMjYtMTEtMjUgMTFsLTgwIDgwLTE4NS0xODVxLTYtNi0xMy02dC0xMyA2bC02NCA2NHEtNSA1LTUgMTJ0NSAxM2wxODYgMTg1LTgxIDgxcS0xMCAxMC0xMCAyNXQxMCAyNSAyNSAxMWgyNTBxMTUgMCAyNi0xMXQxMC0yNXoiIGhvcml6LWFkdi14PSI4NTcuMSIgLz4KCjxnbHlwaCBnbHlwaC1uYW1lPSJjdyIgdW5pY29kZT0iJiN4ZTgwYjsiIGQ9Ik04NTcgNzA3di0yNTBxMC0xNC0xMC0yNXQtMjYtMTFoLTI1MHEtMjMgMC0zMiAyMy0xMCAyMiA3IDM4bDc3IDc3cS04MiA3Ny0xOTQgNzctNTggMC0xMTEtMjN0LTkxLTYxLTYxLTkxLTIzLTExMSAyMy0xMTEgNjEtOTEgOTEtNjEgMTExLTIzcTY2IDAgMTI1IDI5dDEwMCA4MnE0IDYgMTMgNyA4IDAgMTQtNWw3Ni03N3E1LTQgNi0xMXQtNS0xM3EtNjAtNzQtMTQ3LTExNHQtMTgyLTQxcS04NyAwLTE2NyAzNHQtMTM2IDkyLTkyIDEzNy0zNCAxNjYgMzQgMTY2IDkyIDEzNyAxMzYgOTIgMTY3IDM0cTgyIDAgMTU4LTMxdDEzNy04OGw3MiA3MnExNyAxOCAzOSA4IDIyLTkgMjItMzN6IiBob3Jpei1hZHYteD0iODU3LjEiIC8+Cgo8Z2x5cGggZ2x5cGgtbmFtZT0idHJhc2gtZW1wdHkiIHVuaWNvZGU9IiYjeGU4MGU7IiBkPSJNMjg2IDQzOXYtMzIxcTAtOC01LTEzdC0xMy01aC0zNnEtOCAwLTEzIDV0LTUgMTN2MzIxcTAgOCA1IDEzdDEzIDVoMzZxOCAwIDEzLTV0NS0xM3ogbTE0MyAwdi0zMjFxMC04LTUtMTN0LTEzLTVoLTM2cS04IDAtMTMgNXQtNSAxM3YzMjFxMCA4IDUgMTN0MTMgNWgzNnE4IDAgMTMtNXQ1LTEzeiBtMTQyIDB2LTMyMXEwLTgtNS0xM3QtMTItNWgtMzZxLTggMC0xMyA1dC01IDEzdjMyMXEwIDggNSAxM3QxMyA1aDM2cTcgMCAxMi01dDUtMTN6IG03Mi00MDR2NTI5aC01MDB2LTUyOXEwLTEyIDQtMjJ0OC0xNSA2LTVoNDY0cTIgMCA2IDV0OCAxNSA0IDIyeiBtLTM3NSA2MDFoMjUwbC0yNyA2NXEtNCA1LTkgNmgtMTc3cS02LTEtMTAtNnogbTUxOC0xOHYtMzZxMC04LTUtMTN0LTEzLTVoLTU0di01MjlxMC00Ni0yNi04MHQtNjMtMzRoLTQ2NHEtMzcgMC02MyAzM3QtMjcgNzl2NTMxaC01M3EtOCAwLTEzIDV0LTUgMTN2MzZxMCA4IDUgMTN0MTMgNWgxNzJsMzkgOTNxOSAyMSAzMSAzNXQ0NCAxNWgxNzhxMjMgMCA0NC0xNXQzMC0zNWwzOS05M2gxNzNxOCAwIDEzLTV0NS0xM3oiIGhvcml6LWFkdi14PSI3ODUuNyIgLz4KCjxnbHlwaCBnbHlwaC1uYW1lPSJmb250IiB1bmljb2RlPSImI3hlODBmOyIgZD0iTTQwNSA1MzhsLTk1LTI1MXExOCAwIDc2LTF0ODktMXExMSAwIDMyIDEtNDggMTQxLTEwMiAyNTJ6IG0tNDA1LTYxN2wxIDQ0cTEzIDQgMzEgN3QzMiA2IDI4IDggMjUgMTcgMTcgMjhsMTMyIDM0NCAxNTYgNDA0aDcycTQtOCA2LTEybDExNC0yNjhxMTktNDMgNjAtMTQ0dDYzLTE1M3E5LTE5IDMzLTgwdDQwLTk0cTExLTI2IDE5LTMyIDExLTkgNDktMTd0NDctMTFxNC0yMiA0LTMyIDAtMy0xLTh0MC03cS0zNSAwLTEwNiA1dC0xMDcgNHEtNDIgMC0xMjAtNHQtOTktNHEwIDI0IDIgNDNsNzMgMTZxMSAwIDcgMXQ5IDIgOCAzIDkgNCA2IDQgNSA2IDEgOHEwIDktMTcgNTR0LTQwIDk5LTI0IDU2bC0yNTEgMXEtMTQtMzItNDMtMTA5dC0yOC05MXEwLTEyIDgtMjF0MjQtMTQgMjctNyAzMi01IDIzLTJxMS0xMSAxLTMyIDAtNS0xLTE2LTMzIDAtOTggNnQtOTcgNnEtNSAwLTE1LTN0LTEyLTJxLTQ1LTgtMTA1LTh6IiBob3Jpei1hZHYteD0iOTI4LjYiIC8+Cgo8Z2x5cGggZ2x5cGgtbmFtZT0iem9vbS1pbiIgdW5pY29kZT0iJiN4ZTgxMDsiIGQ9Ik01NzEgNDA0di0zNnEwLTctNS0xM3QtMTItNWgtMTI1di0xMjVxMC03LTYtMTN0LTEyLTVoLTM2cS03IDAtMTMgNXQtNSAxM3YxMjVoLTEyNXEtNyAwLTEyIDV0LTYgMTN2MzZxMCA3IDYgMTJ0MTIgNWgxMjV2MTI1cTAgOCA1IDEzdDEzIDVoMzZxNyAwIDEyLTV0Ni0xM3YtMTI1aDEyNXE3IDAgMTItNXQ1LTEyeiBtNzItMThxMCAxMDMtNzMgMTc2dC0xNzcgNzQtMTc3LTc0LTczLTE3NiA3My0xNzcgMTc3LTczIDE3NyA3MyA3MyAxNzd6IG0yODYtNDY1cTAtMjktMjEtNTB0LTUxLTIxcS0zMCAwLTUwIDIxbC0xOTEgMTkxcS0xMDAtNjktMjIzLTY5LTgwIDAtMTUzIDMxdC0xMjUgODQtODQgMTI1LTMxIDE1MyAzMSAxNTIgODQgMTI2IDEyNSA4NCAxNTMgMzEgMTUzLTMxIDEyNS04NCA4NC0xMjYgMzEtMTUycTAtMTIzLTY5LTIyM2wxOTEtMTkxcTIxLTIxIDIxLTUxeiIgaG9yaXotYWR2LXg9IjkyOC42IiAvPgoKPGdseXBoIGdseXBoLW5hbWU9Inpvb20tb3V0IiB1bmljb2RlPSImI3hlODExOyIgZD0iTTU3MSA0MDR2LTM2cTAtNy01LTEzdC0xMi01aC0zMjJxLTcgMC0xMiA1dC02IDEzdjM2cTAgNyA2IDEydDEyIDVoMzIycTcgMCAxMi01dDUtMTJ6IG03Mi0xOHEwIDEwMy03MyAxNzZ0LTE3NyA3NC0xNzctNzQtNzMtMTc2IDczLTE3NyAxNzctNzMgMTc3IDczIDczIDE3N3ogbTI4Ni00NjVxMC0yOS0yMS01MHQtNTEtMjFxLTMwIDAtNTAgMjFsLTE5MSAxOTFxLTEwMC02OS0yMjMtNjktODAgMC0xNTMgMzF0LTEyNSA4NC04NCAxMjUtMzEgMTUzIDMxIDE1MiA4NCAxMjYgMTI1IDg0IDE1MyAzMSAxNTMtMzEgMTI1LTg0IDg0LTEyNiAzMS0xNTJxMC0xMjMtNjktMjIzbDE5MS0xOTFxMjEtMjEgMjEtNTF6IiBob3Jpei1hZHYteD0iOTI4LjYiIC8+Cgo8Z2x5cGggZ2x5cGgtbmFtZT0ibW92ZSIgdW5pY29kZT0iJiN4ZjA0NzsiIGQ9Ik0xMDAwIDM1MHEwLTE0LTExLTI1bC0xNDItMTQzcS0xMS0xMS0yNi0xMXQtMjUgMTEtMTAgMjV2NzJoLTIxNXYtMjE1aDcycTE0IDAgMjUtMTB0MTEtMjUtMTEtMjVsLTE0My0xNDNxLTEwLTExLTI1LTExdC0yNSAxMWwtMTQzIDE0M3EtMTEgMTAtMTEgMjV0MTEgMjUgMjUgMTBoNzJ2MjE1aC0yMTV2LTcycTAtMTQtMTAtMjV0LTI1LTExLTI1IDExbC0xNDMgMTQzcS0xMSAxMS0xMSAyNXQxMSAyNWwxNDMgMTQzcTEwIDExIDI1IDExdDI1LTExIDEwLTI1di03MmgyMTV2MjE1aC03MnEtMTQgMC0yNSAxMHQtMTEgMjUgMTEgMjZsMTQzIDE0MnExMSAxMSAyNSAxMXQyNS0xMWwxNDMtMTQycTExLTExIDExLTI2dC0xMS0yNS0yNS0xMGgtNzJ2LTIxNWgyMTV2NzJxMCAxNCAxMCAyNXQyNSAxMSAyNi0xMWwxNDItMTQzcTExLTEwIDExLTI1eiIgaG9yaXotYWR2LXg9IjEwMDAiIC8+Cgo8Z2x5cGggZ2x5cGgtbmFtZT0icmVzaXplLWZ1bGwtYWx0IiB1bmljb2RlPSImI3hmMGIyOyIgZD0iTTcxNiA1NDhsLTE5OC0xOTggMTk4LTE5OCA4MCA4MHExNyAxOCAzOSA4IDIyLTkgMjItMzN2LTI1MHEwLTE0LTEwLTI1dC0yNi0xMWgtMjUwcS0yMyAwLTMyIDIzLTEwIDIxIDcgMzhsODEgODEtMTk4IDE5OC0xOTgtMTk4IDgwLTgxcTE3LTE3IDgtMzgtMTAtMjMtMzMtMjNoLTI1MHEtMTUgMC0yNSAxMXQtMTEgMjV2MjUwcTAgMjQgMjIgMzMgMjIgMTAgMzktOGw4MC04MCAxOTggMTk4LTE5OCAxOTgtODAtODBxLTExLTExLTI1LTExLTcgMC0xNCAzLTIyIDktMjIgMzN2MjUwcTAgMTQgMTEgMjV0MjUgMTFoMjUwcTIzIDAgMzMtMjMgOS0yMS04LTM4bC04MC04MSAxOTgtMTk4IDE5OCAxOTgtODEgODFxLTE3IDE3LTcgMzggOSAyMyAzMiAyM2gyNTBxMTUgMCAyNi0xMXQxMC0yNXYtMjUwcTAtMjQtMjItMzMtNy0zLTE0LTMtMTQgMC0yNSAxMXoiIGhvcml6LWFkdi14PSI4NTcuMSIgLz4KCjxnbHlwaCBnbHlwaC1uYW1lPSJibGFuayIgdW5pY29kZT0iJiN4ZjBjODsiIGQ9Ik04NTcgNjE4di01MzZxMC02Ni00Ny0xMTN0LTExNC00OGgtNTM1cS02NyAwLTExNCA0OHQtNDcgMTEzdjUzNnEwIDY2IDQ3IDExM3QxMTQgNDhoNTM1cTY3IDAgMTE0LTQ4dDQ3LTExM3oiIGhvcml6LWFkdi14PSI4NTcuMSIgLz4KCjxnbHlwaCBnbHlwaC1uYW1lPSJzb3J0LWRvd24iIHVuaWNvZGU9IiYjeGYwZGQ7IiBkPSJNNTcxIDI0M3EwLTE1LTEwLTI1bC0yNTAtMjUwcS0xMS0xMS0yNS0xMXQtMjUgMTFsLTI1MCAyNTBxLTExIDEwLTExIDI1dDExIDI1IDI1IDExaDUwMHExNCAwIDI1LTExdDEwLTI1eiIgaG9yaXotYWR2LXg9IjU3MS40IiAvPgoKPGdseXBoIGdseXBoLW5hbWU9Im1vdXNlLXBvaW50ZXIiIHVuaWNvZGU9IiYjeGYyNDU7IiBkPSJNNjMyIDI2OHExOC0xNyA4LTM4LTktMjMtMzMtMjNoLTIxM2wxMTItMjY2cTYtMTMgMC0yN3QtMTktMTlsLTk5LTQycS0xNC02LTI3IDB0LTE5IDE5bC0xMDcgMjUyLTE3NC0xNzRxLTExLTExLTI1LTExLTcgMC0xNCAzLTIyIDEwLTIyIDMzdjgzOXEwIDI0IDIyIDMzIDcgMyAxNCAzIDE1IDAgMjUtMTF6IiBob3Jpei1hZHYteD0iNzE0LjMiIC8+CjwvZm9udD4KPC9kZWZzPgo8L3N2Zz4="

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(107);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(13)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(12);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* Containers */\n\n/* The top level container for an Escher Builder */\n.escher-container {\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif !important;\n  background-color: #F3F3F3;\n  text-align: center;\n  position: relative;\n  font-size: 14px;\n  color: #333333;\n}\n\n/* Applied to the body when Escher fills the screen. This stops browser from\nshowing scroll-end animations. */\nhtml.fill-screen {\n  height: 100%;\n  width: 100%;\n}\nbody.fill-screen {\n  margin: 0;\n  position: relative;\n  overflow: hidden;\n  height: 100%;\n  width: 100%;\n}\n\n/* Applied to top level container (generally .escher-container) when Escher\nfills the screen. These make sure Escher completely fills the screen, even after\nresizes. */\n.fill-screen-div {\n  margin: 0;\n  padding: 0;\n  position: fixed;\n  top: 0px;\n  bottom: 0px;\n  left: 0px;\n  right: 0px;\n  width: 100% !important;\n  height: 100% !important;\n  z-index: 1000;\n}\n\n/* The zoom container classes. */\n.escher-container .escher-zoom-container,\n.escher-container .escher-3d-transform-container,\n.escher-container svg.escher-svg {\n  width: 100% !important;\n  height: 100% !important;\n  overflow: hidden;\n}\n\n/* SVG text should not be selectable */\n.escher-container svg text {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n/* Status */\n.escher-container #status {\n  position:absolute;\n  bottom:10px;\n  left: 20px;\n  color: red;\n  background-color: white;\n  font-size: 16px\n}\n\n/* Search & Menu */\n.escher-container .search-menu-container {\n  position: absolute;\n  width: 100%;\n  top: 0px;\n  left: 0px;\n  margin: 0;\n  text-align: center;\n  pointer-events: none;\n}\n.escher-container .search-menu-container-inline {\n  box-sizing: border-box;\n  width: 320px;\n  display: inline-block;\n  text-align: left;\n  pointer-events: auto;\n}\n@media (min-width: 550px) {\n  .escher-container .search-menu-container-inline {\n    width: 410px;\n  }\n}\n\n/* Reaction input */\n.escher-container #rxn-input {\n  z-index: 10;\n  width: 200px;\n}\n.escher-container .input-close-button {\n  position: absolute;\n  right: 0px;\n  width: 18px;\n  bottom: 0px;\n  padding: 0px;\n  border-width: 0px;\n  margin: 0px;\n  background: none;\n  font-size: 20px;\n  font-weight: normal;\n  top: -8px;\n}\n.escher-container .input-close-button:hover {\n  color: #ff3333;\n  font-weight: bold;\n}\n\n/* text edit input */\n.escher-container #text-edit-input input {\n  width: 500px;\n  border: 1px solid #cccccc;\n  font-size: 22px;\n}\n\n.escher-container #tooltip-container {\n  -ms-touch-action: none;\n  touch-action: none;\n}\n\n/* Buttons */\n.escher-container .btn {\n  color: white!important;\n  border: 1px solid #2E2F2F;\n  background-image: linear-gradient(#4F5151, #474949 6%, #3F4141);\n  background-color: white;\n  cursor: pointer;\n}\n\n.escher-container .btn:active {\n  background-image: linear-gradient(#3F4141, #474949 6%, #4F5151);\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("svg.escher-svg #mouse-node {\n  fill: none;\n}\nsvg.escher-svg #canvas {\n  stroke: #ccc;\n  stroke-width: 7px;\n  fill: white;\n}\nsvg.escher-svg .resize-rect {\n  fill: black;\n  opacity: 0;\n  stroke: none;\n}\nsvg.escher-svg .label {\n  font-family: sans-serif;\n  font-style: italic;\n  font-weight: bold;\n  font-size: 8px;\n  fill: black;\n  stroke: none;\n  text-rendering: optimizelegibility;\n  cursor: default;\n}\nsvg.escher-svg .reaction-label {\n  font-size: 30px;\n  fill: rgb(32, 32, 120);\n  text-rendering: optimizelegibility;\n}\nsvg.escher-svg .node-label {\n  font-size: 20px;\n}\nsvg.escher-svg .gene-label {\n  font-size: 18px;\n  fill: rgb(32, 32, 120);\n  text-rendering: optimizelegibility;\n  cursor: default;\n}\nsvg.escher-svg .text-label .label {\n  font-size: 50px;\n}\nsvg.escher-svg .text-label-input {\n  font-size: 50px;\n}\nsvg.escher-svg .node-circle {\n  stroke-width: 2px;\n}\nsvg.escher-svg .midmarker-circle, svg.escher-svg .multimarker-circle {\n  fill: white;\n  fill-opacity: 0.2;\n  stroke: rgb(50, 50, 50);\n}\nsvg.escher-svg g.selected .node-circle{\n  stroke-width: 6px;\n  stroke: rgb(20, 113, 199);\n}\nsvg.escher-svg g.selected .label {\n  fill: rgb(20, 113, 199);\n}\nsvg.escher-svg .metabolite-circle {\n  stroke: rgb(162, 69, 16);\n  fill: rgb(224, 134, 91);\n}\nsvg.escher-svg g.selected .metabolite-circle {\n  stroke: rgb(5, 2, 0);\n}\nsvg.escher-svg .segment {\n  stroke: #334E75;\n  stroke-width: 10px;\n  fill: none;\n}\nsvg.escher-svg .arrowhead {\n  fill: #334E75;\n}\nsvg.escher-svg .stoichiometry-label-rect {\n  fill: white;\n  opacity: 0.5;\n}\nsvg.escher-svg .stoichiometry-label {\n  fill: #334E75;\n  font-size: 17px;\n}\nsvg.escher-svg .membrane {\n  fill: none;\n  stroke: rgb(255, 187, 0);\n}\nsvg.escher-svg .brush .extent {\n  fill-opacity: 0.1;\n  fill: black;\n  stroke: #fff;\n  shape-rendering: crispEdges;\n}\nsvg.escher-svg #brush-container .background {\n  fill: none;\n}\nsvg.escher-svg .bezier-circle {\n  fill: rgb(255,255,255);\n}\nsvg.escher-svg .bezier-circle.b1 {\n  stroke: red;\n}\nsvg.escher-svg .bezier-circle.b2 {\n  stroke: blue;\n}\nsvg.escher-svg .connect-line{\n  stroke: rgb(200,200,200);\n}\nsvg.escher-svg .direction-arrow {\n  cursor: default;\n  stroke: black;\n  stroke-width: 1px;\n  fill: white;\n  opacity: 0.3;\n}\nsvg.escher-svg .start-reaction-target {\n  stroke: rgb(100,100,100);\n  fill: none;\n  opacity: 0.5;\n}\nsvg.escher-svg .rotation-center-line {\n  stroke: red;\n  stroke-width: 5px;\n}\nsvg.escher-svg .highlight {\n  fill: #D97000;\n  text-decoration: underline;\n}\nsvg.escher-svg .node-to-combine {\n  stroke-width: 12px !important;\n}\n");

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** DataMenu */

var utils = __webpack_require__(4);
var d3_json = __webpack_require__(31).json;

module.exports = function (options) {
    var o = utils.set_options(options, {
        selection: null,
        getdatafiles: null,
        datafiles: null,
        update_callback: null,
        target: null });

    if (o.selection === null) throw new Error('No selection provided for DataMenu');

    // setup dropdown menu
    // Append menu if it doesn't exist
    var menu = o.selection.select('.data-menu');
    if (menu.empty()) {
        menu = o.selection.append('div').attr('class', 'data-menu');
    }
    var select_sel = menu.append('form').append('select').attr('class', 'dropdown-menu');

    if (o.getdatafiles) {
        if (o.datafiles) {
            console.warn('DataMenu: getdatafiles option overrides datafiles');
        }
        d3_json(o.getdatafiles, function (error, d) {
            // returns json object:  { data: [file0, file1, ...] }
            if (error) {
                return console.warn(error);
            } else {
                load_with_files(o.target, d.data, select_sel, o.update_callback, o.selection);
            }
            return null;
        });
    } else if (o.datafiles) {
        load_with_files(o.target, o.datafiles, select_sel, o.update_callback, o.selection);
    } else {
        console.warn('DataMenu: No datafiles given');
    }

    return { update: update };

    // definitions
    function load_with_files(t, files, select_sel, update_callback, selection) {

        //when it changes
        select_sel.node().addEventListener("change", function () {
            load_datafile(t, this.value, selection, update_callback);
        }, false);

        var file = files[0];

        update(files, select_sel);
        load_datafile(t, file, selection, update_callback);
    };
    function load_datafile(t, this_file, selection, callback) {
        utils.load_the_file(t, this_file, function (error, data) {
            if (error) {
                return console.warn(error);
                selection.append('error loading');
                o.data = null;
            } else {
                o.data = data;
                if (callback) {
                    callback(data);
                }
            }
        });
    };

    function update(list, select_sel) {
        // update select element with d3 selection /select_sel/ to have options
        // given by /list/
        // TODO remove paths from file list
        select_sel.selectAll(".menu-option").data(list).enter().append('option').attr('value', function (d) {
            return d;
        }).text(function (d) {
            return d;
        });
        // TODO set value to default_filename_index
        select_sel.node().focus();
    };

    function get_data() {
        return o.data;
    };
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.EscherMapModel = exports.EscherMapView = undefined;

var _Builder = __webpack_require__(39);

var _Builder2 = _interopRequireDefault(_Builder);

var _d3Selection = __webpack_require__(2);

var _underscore = __webpack_require__(5);

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global ESCHER_VERSION */

// These will be conditionally defined below
var EscherMapView = exports.EscherMapView = null;
var EscherMapModel = exports.EscherMapModel = null;

// @jupyter-widgets/base is optional, so only initialize if it's called
var base = void 0;
try {
  base = __webpack_require__(111);
} catch (e) {}
if (base) {
  var version = "1.7.3";

  // These options can be set without explicitly redrawing the map. List is
  // probably not complete.
  var NO_DRAW_OPTIONS = ['menu', 'scroll_behavior', 'use_3d_transform', 'enable_editing', 'enable_keys', 'full_screen_button',
  // these already redraw
  'reaction_data', 'metabolite_data', 'gene_data'];

  var WITH_API_FUNCTIONS = {
    reaction_data: 'set_reaction_data',
    metabolite_data: 'set_metabolite_data',
    gene_data: 'set_gene_data'

    /**
     * Jupyter widget implementation for the Escher Builder.
     */
    // eslint-disable-next-line no-unused-vars
  };
  var EscherMapViewRef = function (_base$DOMWidgetView) {
    _inherits(EscherMapViewRef, _base$DOMWidgetView);

    function EscherMapViewRef() {
      _classCallCheck(this, EscherMapViewRef);

      return _possibleConstructorReturn(this, _base$DOMWidgetView.apply(this, arguments));
    }

    EscherMapViewRef.prototype.render = function render() {
      var _this2 = this;

      if (!base) {
        throw Error('@jupyter-widgets/base not installed. You must install it to ' + 'use the jupyter widget');
      }

      var sel = (0, _d3Selection.select)(this.el).append('div');

      // set height before loading map
      this.setHeight(sel);

      _underscore2.default.defer(function () {
        _this2.builder = new _Builder2.default(_this2.getMapData(), _this2.getModelData(), _this2.model.get('embedded_css'), sel, {
          first_load_callback: function first_load_callback(builder) {
            // reset map json in widget
            builder.callback_manager.set('clear_map', function () {
              _this2.model.set('_loaded_map_json', null);
              _this2.model.save_changes();
            });

            // reset model json in widget
            builder.callback_manager.set('clear_model', function () {
              _this2.model.set('_loaded_model_json', null);
              _this2.model.save_changes();
            });

            // update functions
            _this2.model.on('change:height', function () {
              _this2.setHeight(sel);
            });
            _this2.model.on('change:_loaded_map_json', function () {
              builder.load_map(_this2.getMapData());
            });
            _this2.model.on('change:_loaded_model_json', function () {
              builder.load_model(_this2.getModelData());
            });

            // sync changes from options (only after they have been accepted)
            _underscore2.default.mapObject(builder.settings.acceptedStreams, function (stream, key) {
              if (_this2.model.keys().includes(key)) {
                var val = _this2.model.get(key);
                if (val !== null) {
                  // if set, use the value from Python
                  if (key in WITH_API_FUNCTIONS) {
                    builder[WITH_API_FUNCTIONS[key]](val);
                  } else {
                    builder.settings.set(key, val);
                  }
                } else {
                  // otherwise use the default from JavaScript
                  _this2.model.set(key, builder.settings.get(key));
                  _this2.model.save_changes();
                }

                // reactive updates
                _this2.model.on('change:' + key, function () {
                  var val = _this2.model.get(key);
                  // stop if hasn't changed
                  if (!_underscore2.default.isEqual(val, builder.settings.get(key))) {
                    if (key in WITH_API_FUNCTIONS) {
                      builder[WITH_API_FUNCTIONS[key]](val);
                    } else {
                      builder.settings.set(key, val);
                    }

                    // default to drawing everything, unless it's a common
                    // option where that's not necessary
                    if (!NO_DRAW_OPTIONS.includes(key)) {
                      builder.map.draw_everything();
                    }
                  }
                });
              }

              stream.onValue(function (val) {
                // avoid a loop with a deep comparison
                if (!_underscore2.default.isEqual(val, _this2.model.get(key))) {
                  _this2.model.set(key, val);
                  _this2.model.save_changes();
                }
              });
            });

            // draw again to get settings visualized
            builder.map.draw_everything();
          }
        });
      });
    };

    EscherMapViewRef.prototype.setHeight = function setHeight(sel) {
      sel.style('height', this.model.get('height') + 'px');
    };

    EscherMapViewRef.prototype.getMapData = function getMapData() {
      var json = this.model.get('_loaded_map_json');
      return json ? JSON.parse(json) : null;
    };

    EscherMapViewRef.prototype.getModelData = function getModelData() {
      var json = this.model.get('_loaded_model_json');
      return json ? JSON.parse(json) : null;
    };

    return EscherMapViewRef;
  }(base.DOMWidgetView);

  // eslint-disable-next-line no-unused-vars


  var EscherMapModelRef = function (_base$DOMWidgetModel) {
    _inherits(EscherMapModelRef, _base$DOMWidgetModel);

    function EscherMapModelRef() {
      _classCallCheck(this, EscherMapModelRef);

      return _possibleConstructorReturn(this, _base$DOMWidgetModel.apply(this, arguments));
    }

    EscherMapModelRef.prototype.defaults = function defaults() {
      return _underscore2.default.extend(_base$DOMWidgetModel.prototype.defaults.call(this), {
        _model_name: 'EscherMapModel',
        _view_name: 'EscherMapView',
        _model_module: 'escher',
        _view_module: 'escher',
        _model_module_version: version,
        _view_module_version: version
      });
    };

    return EscherMapModelRef;
  }(base.DOMWidgetModel);

  // Trick for conditional exports


  exports.EscherMapView = EscherMapView = EscherMapViewRef;
  exports.EscherMapModel = EscherMapModel = EscherMapModelRef;
}

/***/ }),
/* 111 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE__111__ === 'undefined') {var e = new Error("Cannot find module '@jupyter-widgets/base'"); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE__111__;

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "scaleBand", function() { return /* reexport */ band; });
__webpack_require__.d(__webpack_exports__, "scalePoint", function() { return /* reexport */ point; });
__webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return /* reexport */ identity_identity; });
__webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return /* reexport */ linear; });
__webpack_require__.d(__webpack_exports__, "scaleLog", function() { return /* reexport */ log; });
__webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return /* reexport */ ordinal; });
__webpack_require__.d(__webpack_exports__, "scaleImplicit", function() { return /* reexport */ implicit; });
__webpack_require__.d(__webpack_exports__, "scalePow", function() { return /* reexport */ pow; });
__webpack_require__.d(__webpack_exports__, "scaleSqrt", function() { return /* reexport */ sqrt; });
__webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return /* reexport */ quantile_quantile; });
__webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return /* reexport */ quantize; });
__webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return /* reexport */ threshold_threshold; });
__webpack_require__.d(__webpack_exports__, "scaleTime", function() { return /* reexport */ time; });
__webpack_require__.d(__webpack_exports__, "scaleUtc", function() { return /* reexport */ utcTime; });
__webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return /* reexport */ category10; });
__webpack_require__.d(__webpack_exports__, "schemeCategory20b", function() { return /* reexport */ category20b; });
__webpack_require__.d(__webpack_exports__, "schemeCategory20c", function() { return /* reexport */ category20c; });
__webpack_require__.d(__webpack_exports__, "schemeCategory20", function() { return /* reexport */ category20; });
__webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return /* reexport */ cubehelix; });
__webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return /* reexport */ src_rainbow; });
__webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return /* reexport */ warm; });
__webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return /* reexport */ cool; });
__webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return /* reexport */ viridis; });
__webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return /* reexport */ magma; });
__webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return /* reexport */ inferno; });
__webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return /* reexport */ plasma; });
__webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return /* reexport */ sequential; });

// CONCATENATED MODULE: ./node_modules/d3-array/src/ascending.js
/* harmony default export */ var ascending = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/bisector.js


/* harmony default export */ var bisector = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/bisect.js



var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ var bisect = (bisectRight);

// CONCATENATED MODULE: ./node_modules/d3-array/src/pairs.js
/* harmony default export */ var pairs = (function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
});

function pair(a, b) {
  return [a, b];
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/cross.js


/* harmony default export */ var cross = (function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/descending.js
/* harmony default export */ var descending = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/number.js
/* harmony default export */ var number = (function(x) {
  return x === null ? NaN : +x;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/variance.js


/* harmony default export */ var variance = (function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/deviation.js


/* harmony default export */ var deviation = (function(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/extent.js
/* harmony default export */ var extent = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/array.js
var array_array = Array.prototype;

var slice = array_array.slice;
var map = array_array.map;

// CONCATENATED MODULE: ./node_modules/d3-array/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/identity.js
/* harmony default export */ var identity = (function(x) {
  return x;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/range.js
/* harmony default export */ var src_range = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ var ticks = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/threshold/sturges.js
/* harmony default export */ var sturges = (function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/histogram.js









/* harmony default export */ var src_histogram = (function() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = src_range(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisect(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/quantile.js


/* harmony default export */ var quantile = (function(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/threshold/freedmanDiaconis.js





/* harmony default export */ var freedmanDiaconis = (function(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/threshold/scott.js


/* harmony default export */ var scott = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/max.js
/* harmony default export */ var src_max = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/mean.js


/* harmony default export */ var src_mean = (function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/median.js




/* harmony default export */ var median = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/merge.js
/* harmony default export */ var merge = (function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/min.js
/* harmony default export */ var src_min = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/permute.js
/* harmony default export */ var permute = (function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/scan.js


/* harmony default export */ var scan = (function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/shuffle.js
/* harmony default export */ var shuffle = (function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/sum.js
/* harmony default export */ var src_sum = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/transpose.js


/* harmony default export */ var src_transpose = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = src_min(matrix, transpose_length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function transpose_length(d) {
  return d.length;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/zip.js


/* harmony default export */ var zip = (function() {
  return src_transpose(arguments);
});

// CONCATENATED MODULE: ./node_modules/d3-array/index.js




























// EXTERNAL MODULE: ./node_modules/d3-collection/index.js + 6 modules
var d3_collection = __webpack_require__(30);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/array.js
var src_array_array = Array.prototype;

var array_map = src_array_array.map;
var array_slice = src_array_array.slice;

// CONCATENATED MODULE: ./node_modules/d3-scale/src/ordinal.js



var implicit = {name: "implicit"};

function ordinal(range) {
  var index = Object(d3_collection["a" /* map */])(),
      domain = [],
      unknown = implicit;

  range = range == null ? [] : array_slice.call(range);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = Object(d3_collection["a" /* map */])();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = array_slice.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return scale;
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/band.js



function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = src_range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

// EXTERNAL MODULE: ./node_modules/d3-interpolate/index.js + 21 modules
var d3_interpolate = __webpack_require__(3);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/constant.js
/* harmony default export */ var src_constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/number.js
/* harmony default export */ var src_number = (function(x) {
  return +x;
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/continuous.js






var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : src_constant(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate["a" /* interpolate */],
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = array_map.call(_, src_number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = array_slice.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = array_slice.call(_), interpolate = d3_interpolate["e" /* interpolateRound */], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  return rescale();
}

// EXTERNAL MODULE: ./node_modules/d3-format/index.js + 15 modules
var d3_format = __webpack_require__(7);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/tickFormat.js



/* harmony default export */ var src_tickFormat = (function(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = tickStep(start, stop, count == null ? 10 : count),
      precision;
  specifier = Object(d3_format["formatSpecifier"])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = Object(d3_format["precisionPrefix"])(step, value))) specifier.precision = precision;
      return Object(d3_format["formatPrefix"])(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = Object(d3_format["precisionRound"])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = Object(d3_format["precisionFixed"])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return Object(d3_format["format"])(specifier);
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/linear.js





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return src_tickFormat(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous(deinterpolateLinear, d3_interpolate["c" /* interpolateNumber */]);

  scale.copy = function() {
    return copy(scale, linear());
  };

  return linearish(scale);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/identity.js




function identity_identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = array_map.call(_, src_number), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity_identity().domain(domain);
  };

  return linearish(scale);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/nice.js
/* harmony default export */ var nice = (function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/log.js






function log_deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : src_constant(b);
}

function log_reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = continuous(log_deinterpolate, log_reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = Object(d3_format["format"])(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy(scale, log().base(base));
  };

  return scale;
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/pow.js




function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent)))
        ? function(x) { return (raise(x, exponent) - a) / b; }
        : src_constant(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function(t) { return raise(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy(scale, pow().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/quantile.js



function quantile_quantile() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = quantile(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = array_slice.call(_), rescale()) : range.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile_quantile()
        .domain(domain)
        .range(range);
  };

  return scale;
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/quantize.js




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[bisect(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = array_slice.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range);
  };

  return linearish(scale);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/threshold.js



function threshold_threshold() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[bisect(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold_threshold()
        .domain(domain)
        .range(range);
  };

  return scale;
}

// CONCATENATED MODULE: ./node_modules/d3-time/src/interval.js
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

// CONCATENATED MODULE: ./node_modules/d3-time/src/millisecond.js


var millisecond_millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond_millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond_millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ var src_millisecond = (millisecond_millisecond);
var milliseconds = millisecond_millisecond.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

// CONCATENATED MODULE: ./node_modules/d3-time/src/second.js



var second_second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ var src_second = (second_second);
var seconds = second_second.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/minute.js



var minute_minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ var src_minute = (minute_minute);
var minutes = minute_minute.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/hour.js



var hour_hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

/* harmony default export */ var src_hour = (hour_hour);
var hours = hour_hour.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/day.js



var day_day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});

/* harmony default export */ var src_day = (day_day);
var days = day_day.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/week.js



function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/month.js


var month_month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ var src_month = (month_month);
var months = month_month.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/year.js


var year_year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year_year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ var src_year = (year_year);
var years = year_year.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/utcMinute.js



var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ var src_utcMinute = (utcMinute);
var utcMinutes = utcMinute.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/utcHour.js



var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ var src_utcHour = (utcHour);
var utcHours = utcHour.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/utcDay.js



var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ var src_utcDay = (utcDay);
var utcDays = utcDay.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/utcWeek.js



function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/utcMonth.js


var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ var src_utcMonth = (utcMonth);
var utcMonths = utcMonth.range;

// CONCATENATED MODULE: ./node_modules/d3-time/src/utcYear.js


var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ var src_utcYear = (utcYear);
var utcYears = utcYear.range;

// CONCATENATED MODULE: ./node_modules/d3-time/index.js






























// CONCATENATED MODULE: ./node_modules/d3-time-format/src/locale.js


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": locale_formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = src_utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? monday.ceil(week) : monday(week);
          week = src_day.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + src_day.count(src_year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(src_year(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
  return pad(thursday.count(src_year(d), d) + (src_year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(src_year(d), d), p, 2);
}

function locale_formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + src_utcDay.count(src_utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(src_utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(utcThursday.count(src_utcYear(d), d) + (src_utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(src_utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

// CONCATENATED MODULE: ./node_modules/d3-time-format/src/defaultLocale.js


var defaultLocale_locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  defaultLocale_locale = formatLocale(definition);
  timeFormat = defaultLocale_locale.format;
  timeParse = defaultLocale_locale.parse;
  utcFormat = defaultLocale_locale.utcFormat;
  utcParse = defaultLocale_locale.utcParse;
  return defaultLocale_locale;
}

// CONCATENATED MODULE: ./node_modules/d3-time-format/src/isoFormat.js


var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : utcFormat(isoSpecifier);

/* harmony default export */ var isoFormat = (formatIso);

// CONCATENATED MODULE: ./node_modules/d3-time-format/src/isoParse.js



function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : utcParse(isoSpecifier);

/* harmony default export */ var isoParse = (parseIso);

// CONCATENATED MODULE: ./node_modules/d3-time-format/index.js





// CONCATENATED MODULE: ./node_modules/d3-scale/src/time.js








var time_durationSecond = 1000,
    time_durationMinute = time_durationSecond * 60,
    time_durationHour = time_durationMinute * 60,
    time_durationDay = time_durationHour * 24,
    time_durationWeek = time_durationDay * 7,
    durationMonth = time_durationDay * 30,
    durationYear = time_durationDay * 365;

function time_date(t) {
  return new Date(t);
}

function time_number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous(deinterpolateLinear, d3_interpolate["c" /* interpolateNumber */]),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      time_durationSecond],
    [second,  5,  5 * time_durationSecond],
    [second, 15, 15 * time_durationSecond],
    [second, 30, 30 * time_durationSecond],
    [minute,  1,      time_durationMinute],
    [minute,  5,  5 * time_durationMinute],
    [minute, 15, 15 * time_durationMinute],
    [minute, 30, 30 * time_durationMinute],
    [  hour,  1,      time_durationHour  ],
    [  hour,  3,  3 * time_durationHour  ],
    [  hour,  6,  6 * time_durationHour  ],
    [  hour, 12, 12 * time_durationHour  ],
    [   day,  1,      time_durationDay   ],
    [   day,  2,  2 * time_durationDay   ],
    [  week,  1,      time_durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(array_map.call(_, time_number)) : domain().map(time_date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

/* harmony default export */ var time = (function() {
  return calendar(src_year, src_month, sunday, src_day, src_hour, src_minute, src_second, src_millisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/utcTime.js




/* harmony default export */ var utcTime = (function() {
  return calendar(src_utcYear, src_utcMonth, utcSunday, src_utcDay, src_utcHour, src_utcMinute, src_second, src_millisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/colors.js
/* harmony default export */ var colors = (function(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/category10.js


/* harmony default export */ var category10 = (colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));

// CONCATENATED MODULE: ./node_modules/d3-scale/src/category20b.js


/* harmony default export */ var category20b = (colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6"));

// CONCATENATED MODULE: ./node_modules/d3-scale/src/category20c.js


/* harmony default export */ var category20c = (colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9"));

// CONCATENATED MODULE: ./node_modules/d3-scale/src/category20.js


/* harmony default export */ var category20 = (colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"));

// EXTERNAL MODULE: ./node_modules/d3-color/index.js + 5 modules
var d3_color = __webpack_require__(1);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/cubehelix.js



/* harmony default export */ var cubehelix = (Object(d3_interpolate["b" /* interpolateCubehelixLong */])(Object(d3_color["b" /* cubehelix */])(300, 0.5, 0.0), Object(d3_color["b" /* cubehelix */])(-240, 0.5, 1.0)));

// CONCATENATED MODULE: ./node_modules/d3-scale/src/rainbow.js



var warm = Object(d3_interpolate["b" /* interpolateCubehelixLong */])(Object(d3_color["b" /* cubehelix */])(-100, 0.75, 0.35), Object(d3_color["b" /* cubehelix */])(80, 1.50, 0.8));

var cool = Object(d3_interpolate["b" /* interpolateCubehelixLong */])(Object(d3_color["b" /* cubehelix */])(260, 0.75, 0.35), Object(d3_color["b" /* cubehelix */])(80, 1.50, 0.8));

var rainbow = Object(d3_color["b" /* cubehelix */])();

/* harmony default export */ var src_rainbow = (function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/viridis.js


function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

/* harmony default export */ var viridis = (ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")));

var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// CONCATENATED MODULE: ./node_modules/d3-scale/src/sequential.js


function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/index.js







































/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "zoom", function() { return /* reexport */ src_zoom; });
__webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return /* reexport */ transform_transform; });
__webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return /* reexport */ identity; });

// EXTERNAL MODULE: ./node_modules/d3-dispatch/index.js + 1 modules
var d3_dispatch = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/d3-drag/src/nodrag.js
var nodrag = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/index.js + 21 modules
var d3_interpolate = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/on.js
var on = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/mouse.js
var mouse = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/select.js
var src_select = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/touch.js
var touch = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/d3-transition/index.js + 38 modules
var d3_transition = __webpack_require__(19);

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/event.js
function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform_transform.prototype = Transform.prototype;

function transform_transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/noevent.js


function nopropagation() {
  on["c" /* event */].stopImmediatePropagation();
}

/* harmony default export */ var noevent = (function() {
  on["c" /* event */].preventDefault();
  on["c" /* event */].stopImmediatePropagation();
});

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/zoom.js










// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !on["c" /* event */].ctrlKey && !on["c" /* event */].button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || identity;
}

function defaultWheelDelta() {
  return -on["c" /* event */].deltaY * (on["c" /* event */].deltaMode === 1 ? 0.05 : on["c" /* event */].deltaMode ? 1 : 0.002);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ var src_zoom = (function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate["i" /* interpolateZoom */],
      listeners = Object(d3_dispatch["a" /* dispatch */])("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p);
  };

  zoom.scaleTo = function(selection, k, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p);
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      Object(on["a" /* customEvent */])(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(mouse["a" /* default */])(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      Object(d3_transition["a" /* interrupt */])(this);
      g.start();
    }

    noevent();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments, true),
        v = Object(src_select["a" /* default */])(on["c" /* event */].view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(mouse["a" /* default */])(this),
        x0 = on["c" /* event */].clientX,
        y0 = on["c" /* event */].clientY;

    Object(nodrag["a" /* default */])(on["c" /* event */].view);
    nopropagation();
    g.mouse = [p, this.__zoom.invert(p)];
    Object(d3_transition["a" /* interrupt */])(this);
    g.start();

    function mousemoved() {
      noevent();
      if (!g.moved) {
        var dx = on["c" /* event */].clientX - x0, dy = on["c" /* event */].clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(mouse["a" /* default */])(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(nodrag["b" /* yesdrag */])(on["c" /* event */].view, g.moved);
      noevent();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(mouse["a" /* default */])(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (on["c" /* event */].shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    noevent();
    if (duration > 0) Object(src_select["a" /* default */])(this).transition().duration(duration).call(schedule, t1, p0);
    else Object(src_select["a" /* default */])(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = on["c" /* event */].touches,
        n = touches.length,
        g = gesture(this, arguments, on["c" /* event */].changedTouches.length === n),
        started, i, t, p;

    nopropagation();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(touch["a" /* default */])(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      Object(d3_transition["a" /* interrupt */])(this);
      g.start();
    }
  }

  function touchmoved() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = on["c" /* event */].changedTouches,
        n = touches.length, i, t, p, l;

    noevent();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    g.taps = 0;
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(touch["a" /* default */])(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = on["c" /* event */].changedTouches,
        n = touches.length, i, t;

    nopropagation();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        var p = Object(src_select["a" /* default */])(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
});

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/index.js




/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "brush", function() { return /* reexport */ src_brush; });
__webpack_require__.d(__webpack_exports__, "brushX", function() { return /* reexport */ brushX; });
__webpack_require__.d(__webpack_exports__, "brushY", function() { return /* reexport */ brushY; });
__webpack_require__.d(__webpack_exports__, "brushSelection", function() { return /* reexport */ brushSelection; });

// EXTERNAL MODULE: ./node_modules/d3-dispatch/index.js + 1 modules
var d3_dispatch = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/d3-drag/src/nodrag.js
var nodrag = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/index.js + 21 modules
var d3_interpolate = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/on.js
var on = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/select.js
var src_select = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/mouse.js
var mouse = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/d3-transition/index.js + 38 modules
var d3_transition = __webpack_require__(19);

// CONCATENATED MODULE: ./node_modules/d3-brush/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-brush/src/event.js
/* harmony default export */ var src_event = (function(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
});

// CONCATENATED MODULE: ./node_modules/d3-brush/src/noevent.js


function nopropagation() {
  on["c" /* event */].stopImmediatePropagation();
}

/* harmony default export */ var noevent = (function() {
  on["c" /* event */].preventDefault();
  on["c" /* event */].stopImmediatePropagation();
});

// CONCATENATED MODULE: ./node_modules/d3-brush/src/brush.js









var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

var X = {
  name: "x",
  handles: ["e", "w"].map(brush_type),
  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(brush_type),
  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(brush_type),
  input: function(xy) { return xy; },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function brush_type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !on["c" /* event */].button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush_brush(X);
}

function brushY() {
  return brush_brush(Y);
}

/* harmony default export */ var src_brush = (function() {
  return brush_brush(XY);
});

function brush_brush(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = Object(d3_dispatch["a" /* dispatch */])(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([brush_type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          Object(src_select["a" /* default */])(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([brush_type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
        .on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = Object(d3_interpolate["a" /* interpolate */])(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && empty(selection1) ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 && selection1 ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            Object(d3_transition["a" /* interrupt */])(that);
            state.selection = selection1 == null || empty(selection1) ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  function redraw() {
    var group = Object(src_select["a" /* default */])(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      Object(on["a" /* customEvent */])(new src_event(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (on["c" /* event */].touches) { if (on["c" /* event */].changedTouches.length < on["c" /* event */].touches.length) return noevent(); }
    else if (touchending) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = on["c" /* event */].target.__data__.type,
        mode = (on["c" /* event */].metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (on["c" /* event */].altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx,
        dy,
        moving,
        shifting = false, // ZK disable shift key
        lockX,
        lockY,
        point0 = Object(mouse["a" /* default */])(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = Object(src_select["a" /* default */])(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (on["c" /* event */].touches) {
      group
          .on("touchmove.brush", moved, true)
          .on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = Object(src_select["a" /* default */])(on["c" /* event */].view)
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);

      Object(nodrag["a" /* default */])(on["c" /* event */].view);
    }

    nopropagation();
    Object(d3_transition["a" /* interrupt */])(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = Object(mouse["a" /* default */])(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation();
      if (on["c" /* event */].touches) {
        if (on["c" /* event */].touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        Object(nodrag["b" /* yesdrag */])(on["c" /* event */].view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (on["c" /* event */].keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }

    function keyupped() {
      switch (on["c" /* event */].keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (on["c" /* event */].altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

// CONCATENATED MODULE: ./node_modules/d3-brush/index.js



/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "gsap", function() { return /* binding */ gsapWithCSS; });
__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ gsapWithCSS; });
__webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return /* reexport */ CSSPlugin; });
__webpack_require__.d(__webpack_exports__, "TweenMax", function() { return /* binding */ TweenMaxWithCSS; });
__webpack_require__.d(__webpack_exports__, "TweenLite", function() { return /* reexport */ Tween; });
__webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return /* reexport */ Timeline; });
__webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return /* reexport */ Timeline; });
__webpack_require__.d(__webpack_exports__, "Power0", function() { return /* reexport */ Power0; });
__webpack_require__.d(__webpack_exports__, "Power1", function() { return /* reexport */ Power1; });
__webpack_require__.d(__webpack_exports__, "Power2", function() { return /* reexport */ Power2; });
__webpack_require__.d(__webpack_exports__, "Power3", function() { return /* reexport */ Power3; });
__webpack_require__.d(__webpack_exports__, "Power4", function() { return /* reexport */ Power4; });
__webpack_require__.d(__webpack_exports__, "Linear", function() { return /* reexport */ Linear; });
__webpack_require__.d(__webpack_exports__, "Quad", function() { return /* reexport */ Quad; });
__webpack_require__.d(__webpack_exports__, "Cubic", function() { return /* reexport */ Cubic; });
__webpack_require__.d(__webpack_exports__, "Quart", function() { return /* reexport */ Quart; });
__webpack_require__.d(__webpack_exports__, "Quint", function() { return /* reexport */ Quint; });
__webpack_require__.d(__webpack_exports__, "Strong", function() { return /* reexport */ Strong; });
__webpack_require__.d(__webpack_exports__, "Elastic", function() { return /* reexport */ Elastic; });
__webpack_require__.d(__webpack_exports__, "Back", function() { return /* reexport */ Back; });
__webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return /* reexport */ SteppedEase; });
__webpack_require__.d(__webpack_exports__, "Bounce", function() { return /* reexport */ Bounce; });
__webpack_require__.d(__webpack_exports__, "Sine", function() { return /* reexport */ Sine; });
__webpack_require__.d(__webpack_exports__, "Expo", function() { return /* reexport */ Expo; });
__webpack_require__.d(__webpack_exports__, "Circ", function() { return /* reexport */ Circ; });

// CONCATENATED MODULE: ./node_modules/gsap/gsap-core.js
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _reverting,
    _context,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _startAtRevertConfig = {
  suppressEvents: true,
  isStart: true,
  kill: false
},
    _revertConfigNoKill = {
  suppressEvents: true,
  kill: false
},
    _revertConfig = {
  suppressEvents: true
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 10000000) / 10000000 || 0;
},
    // increased precision mostly for timing values.
_parseRelative = function _parseRelative(start, value) {
  var operator = value.charAt(0),
      end = parseFloat(value.substr(2));
  start = parseFloat(start);
  return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && !_reverting && _lazyRender();
  animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
  _lazyTweens.length && !_reverting && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
  return function (obj, defaults) {
    for (var p in defaults) {
      p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
    }
  };
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
  return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {
    // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)

  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
  _initTween(tween, time, tTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [tTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
      // if iteration changed
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents && !_reverting) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
  animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value, v) {
  return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt < l && wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

  return function (raw) {
    var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);

    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      prevContext = _context,
      context = animation._ctx,
      params,
      scope,
      result;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  context && (_context = context);
  result = params ? callback.apply(scope, params) : callback.call(scope);
  _context = prevContext;
  return result;
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _registerPluginQueue = [],
    _createPlugin = function _createPlugin(config) {
  if (!config) return;
  config = !config.name && config["default"] || config; // UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  if (_windowExists() || config.headless) {
    // edge case: some build tools may pass in a null/undefined value
    var name = config.name,
        isFunc = _isFunction(config),
        Plugin = name && !isFunc && config.init ? function () {
      this._props = [];
    } : config,
        //in case someone passes in an object that's not a plugin, like CustomEase
    instanceDefaults = {
      init: _emptyFunc,
      render: _renderPropTweens,
      add: _addPropTween,
      kill: _killPropTweensOf,
      modifier: _addPluginModifier,
      rawVars: 0
    },
        statics = {
      targetTest: 0,
      get: 0,
      getSetter: _getSetter,
      aliases: {},
      register: 0
    };

    _wake();

    if (config !== Plugin) {
      if (_plugins[name]) {
        return;
      }

      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


      _plugins[Plugin.prop = name] = Plugin;

      if (config.targetTest) {
        _harnessPlugins.push(Plugin);

        _reservedProps[name] = 1;
      }

      name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
    }

    _addGlobal(name, Plugin);

    config.register && config.register(gsap, Plugin, PropTween);
  } else {
    _registerPluginQueue.push(config);
  }
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
// let ctx = _doc.createElement("canvas").getContext("2d");
// _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
_hue = function _hue(h, m1, m2) {
  h += h < 0 ? 1 : h > 1 ? -1 : 0;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _registerPluginQueue.forEach(_createPlugin);
        }

        _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback, once, prioritize) {
      var func = once ? function (t, d, f, v) {
        callback(t, d, f, v);

        _self.remove(func);
      } : callback;

      _self.remove(callback);

      _listeners[prioritize ? "unshift" : "push"](func);

      _wake();

      return func;
    },
    remove: function remove(callback, i) {
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;

    if (_context) {
      this._ctx = _context;

      _context.data.push(this);
    }

    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value, suppressEvents) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);

    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


    return _recacheAncestors(this);
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.revert = function revert(config) {
    if (config === void 0) {
      config = _revertConfig;
    }

    var prevIsReverting = _reverting;
    _reverting = config;

    if (this._initted || this._startAt) {
      this.timeline && this.timeline.revert(config);
      this.totalTime(-0.01, config.suppressEvents);
    }

    this.data !== "nested" && config.kill !== false && this.kill();
    _reverting = prevIsReverting;
    return this;
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (Math.abs(animation._ts) || 1);
      animation = animation._dp;
    }

    return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). "_sat" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://gsap.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the "repeatDelay" portion

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.

          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents && !iteration) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate(soft) {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate(soft);
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this, soft);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (!optional || parsedStart !== end || _forceAllPropTweens) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_forceAllPropTweens,
    _initTween = function _initTween(tween, time, tTime) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl || keyframes && !vars.stagger) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);

    if (prevStartAt) {
      prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.

      time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a "startAt" (not "from()" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)
      // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for "startAt" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.

      prevStartAt._lazy = 0;
    }

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: !prevStartAt && _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate && function () {
          return _callback(tween, "onUpdate");
        },
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.

      tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween

      time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        if (dur && time <= 0 && tTime <= 0) {
          // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (!prevStartAt) {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        tween._startAt._dp = 0; // don't allow it to get put back into root timeline!

        tween._startAt._sat = tween; // used in globalTime()

        time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
        tween._zTime = time;

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = tween._ptCache = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
},
    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
      pt,
      rootPT,
      lookup,
      i;

  if (!ptCache) {
    ptCache = tween._ptCache[property] = [];
    lookup = tween._ptLookup;
    i = tween._targets.length;

    while (i--) {
      pt = lookup[i][property];

      if (pt && pt.d && pt.d._pt) {
        // it's a plugin, so find the nested PropTween
        pt = pt.d._pt;

        while (pt && pt.p !== property && pt.fp !== property) {
          // "fp" is functionParam for things like setting CSS variables which require .setProperty("--var-name", value)
          pt = pt._next;
        }
      }

      if (!pt) {
        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

        tween.vars[property] = "+=0";

        _initTween(tween, time);

        _forceAllPropTweens = 0;
        return skipRecursion ? _warn(property + " not eligible for reset") : 1; // if someone tries to do a quickTo() on a special property like borderRadius which must get split into 4 different properties, that's not eligible for .resetTo().
      }

      ptCache.push(pt);
    }
  }

  i = ptCache.length;

  while (i--) {
    rootPT = ptCache[i];
    pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.

    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
    pt.c = value - pt.s;
    rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)

    rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)
  }
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
  var ease = obj.ease || easeEach || "power1.inOut",
      p,
      a;

  if (_isArray(obj)) {
    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

    obj.forEach(function (value, i) {
      return a.push({
        t: i / (obj.length - 1) * 100,
        v: value,
        e: ease
      });
    });
  } else {
    for (p in obj) {
      a = allProps[p] || (allProps[p] = []);
      p === "ease" || a.push({
        t: parseFloat(prop),
        v: obj[p],
        e: ease
      });
    }
  }
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    _staggerPropsToSkip = {};

_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
  return _staggerPropsToSkip[name] = 1;
});
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {},
        targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
      }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.

      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      } else if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));

        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0,
            a,
            kf,
            v;

        if (_isArray(keyframes)) {
          keyframes.forEach(function (frame) {
            return tl.to(parsedTargets, frame, ">");
          });
          tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.
        } else {
          copy = {};

          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }

          for (p in copy) {
            a = copy[p].sort(function (a, b) {
              return a.t - b.t;
            });
            time = 0;

            for (i = 0; i < a.length; i++) {
              kf = a[i];
              v = {
                ease: kf.e,
                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }

          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          }); // in case keyframes didn't go to 100%
        }
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay) || 0); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        isNegative = totalTime < 0,
        tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && isNegative) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted && iteration === prevIteration) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          this._tTime = tTime;
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {
            // this._time will === cycleDuration when we render at EXACTLY the end of an iteration. Without this condition, it'd often do the repeatRefresh render TWICE (again on the very next tick).
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values. But we also don't want to dump if we're doing a repeatRefresh render!
          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (time && !prevTime && !suppressEvents && !iteration) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate(soft) {
    // "soft" gives us a way to clear out everything EXCEPT the recorded pre-"from" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the "from" values would persist and then on the next render, the from() tweens would initialize and the current value would match the "from" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.
    (!soft || !this.vars.runBackwards) && (this._startAt = 0);
    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate(soft);
    return _Animation2.prototype.invalidate.call(this, soft);
  };

  _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
    _tickerActive || _ticker.wake();
    this._ts || this.play();
    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        ratio;
    this._initted || _initTween(this, time);
    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
    // if (_isObject(property)) { // performance optimization
    // 	for (p in property) {
    // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
    // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    // 		}
    // 	}
    // } else {

    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
      return this.resetTo(property, value, start, startIsRelative, 1); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    } //}


    _alignPlayhead(this, 0);

    this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
    return this.render(0);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;

var _media = [],
    _listeners = {},
    _emptyArray = [],
    _lastMediaTime = 0,
    _contextID = 0,
    _dispatch = function _dispatch(type) {
  return (_listeners[type] || _emptyArray).map(function (f) {
    return f();
  });
},
    _onMediaChange = function _onMediaChange() {
  var time = Date.now(),
      matches = [];

  if (time - _lastMediaTime > 2) {
    _dispatch("matchMediaInit");

    _media.forEach(function (c) {
      var queries = c.queries,
          conditions = c.conditions,
          match,
          p,
          anyMatch,
          toggled;

      for (p in queries) {
        match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.

        match && (anyMatch = 1);

        if (match !== conditions[p]) {
          conditions[p] = match;
          toggled = 1;
        }
      }

      if (toggled) {
        c.revert();
        anyMatch && matches.push(c);
      }
    });

    _dispatch("matchMediaRevert");

    matches.forEach(function (c) {
      return c.onMatch(c, function (func) {
        return c.add(null, func);
      });
    });
    _lastMediaTime = time;

    _dispatch("matchMedia");
  }
};

var Context = /*#__PURE__*/function () {
  function Context(func, scope) {
    this.selector = scope && selector(scope);
    this.data = [];
    this._r = []; // returned/cleanup functions

    this.isReverted = false;
    this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because "this" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely

    func && this.add(func);
  }

  var _proto5 = Context.prototype;

  _proto5.add = function add(name, func, scope) {
    // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.
    // if (name && _isFunction(name.revert)) {
    // 	this.data.push(name);
    // 	return (name._ctx = this);
    // }
    if (_isFunction(name)) {
      scope = func;
      func = name;
      name = _isFunction;
    }

    var self = this,
        f = function f() {
      var prev = _context,
          prevSelector = self.selector,
          result;
      prev && prev !== self && prev.data.push(self);
      scope && (self.selector = selector(scope));
      _context = self;
      result = func.apply(self, arguments);
      _isFunction(result) && self._r.push(result);
      _context = prev;
      self.selector = prevSelector;
      self.isReverted = false;
      return result;
    };

    self.last = f;
    return name === _isFunction ? f(self, function (func) {
      return self.add(null, func);
    }) : name ? self[name] = f : f;
  };

  _proto5.ignore = function ignore(func) {
    var prev = _context;
    _context = null;
    func(this);
    _context = prev;
  };

  _proto5.getTweens = function getTweens() {
    var a = [];
    this.data.forEach(function (e) {
      return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
    });
    return a;
  };

  _proto5.clear = function clear() {
    this._r.length = this.data.length = 0;
  };

  _proto5.kill = function kill(revert, matchMedia) {
    var _this4 = this;

    if (revert) {
      (function () {
        var tweens = _this4.getTweens(),
            i = _this4.data.length,
            t;

        while (i--) {
          // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.
          t = _this4.data[i];

          if (t.data === "isFlip") {
            t.revert();
            t.getChildren(true, true, false).forEach(function (tween) {
              return tweens.splice(tweens.indexOf(tween), 1);
            });
          }
        } // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort


        tweens.map(function (t) {
          return {
            g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,
            t: t
          };
        }).sort(function (a, b) {
          return b.g - a.g || -Infinity;
        }).forEach(function (o) {
          return o.t.revert(revert);
        }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the " || -1" in the sort keeps the order properly.

        i = _this4.data.length;

        while (i--) {
          // make sure we loop backwards so that, for example, SplitTexts that were created later on the same element get reverted first
          t = _this4.data[i];

          if (t instanceof Timeline) {
            if (t.data !== "nested") {
              t.scrollTrigger && t.scrollTrigger.revert();
              t.kill(); // don't revert() the timeline because that's duplicating efforts since we already reverted all the tweens
            }
          } else {
            !(t instanceof Tween) && t.revert && t.revert(revert);
          }
        }

        _this4._r.forEach(function (f) {
          return f(revert, _this4);
        });

        _this4.isReverted = true;
      })();
    } else {
      this.data.forEach(function (e) {
        return e.kill && e.kill();
      });
    }

    this.clear();

    if (matchMedia) {
      var i = _media.length;

      while (i--) {
        // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.
        _media[i].id === this.id && _media.splice(i, 1);
      }
    }
  };

  _proto5.revert = function revert(config) {
    this.kill(config || {});
  };

  return Context;
}();

var MatchMedia = /*#__PURE__*/function () {
  function MatchMedia(scope) {
    this.contexts = [];
    this.scope = scope;
    _context && _context.data.push(this);
  }

  var _proto6 = MatchMedia.prototype;

  _proto6.add = function add(conditions, func, scope) {
    _isObject(conditions) || (conditions = {
      matches: conditions
    });
    var context = new Context(0, scope || this.scope),
        cond = context.conditions = {},
        mq,
        p,
        active;
    _context && !context.selector && (context.selector = _context.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()

    this.contexts.push(context);
    func = context.add("onMatch", func);
    context.queries = conditions;

    for (p in conditions) {
      if (p === "all") {
        active = 1;
      } else {
        mq = _win.matchMedia(conditions[p]);

        if (mq) {
          _media.indexOf(context) < 0 && _media.push(context);
          (cond[p] = mq.matches) && (active = 1);
          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
        }
      }
    }

    active && func(context, function (f) {
      return context.add(null, f);
    });
    return this;
  } // refresh() {
  // 	let time = _lastMediaTime,
  // 		media = _media;
  // 	_lastMediaTime = -1;
  // 	_media = this.contexts;
  // 	_onMediaChange();
  // 	_lastMediaTime = time;
  // 	_media = media;
  // }
  ;

  _proto6.revert = function revert(config) {
    this.kill(config || {});
  };

  _proto6.kill = function kill(revert) {
    this.contexts.forEach(function (c) {
      return c.kill(revert, true);
    });
  };

  return MatchMedia;
}();
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */


var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  quickTo: function quickTo(target, property, vars) {
    var _merge2;

    var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
        func = function func(value, start, startIsRelative) {
      return tween.resetTo(property, value, start, startIsRelative);
    };

    func.tween = tween;
    return func;
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  context: function context(func, scope) {
    return func ? new Context(func, scope) : _context;
  },
  matchMedia: function matchMedia(scope) {
    return new MatchMedia(scope);
  },
  matchMediaRefresh: function matchMediaRefresh() {
    return _media.forEach(function (c) {
      var cond = c.conditions,
          found,
          p;

      for (p in cond) {
        if (cond[p]) {
          cond[p] = false;
          found = 1;
        }
      }

      found && c.revert();
    }) || _onMediaChange();
  },
  addEventListener: function addEventListener(type, callback) {
    var a = _listeners[type] || (_listeners[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  },
  removeEventListener: function removeEventListener(type, callback) {
    var a = _listeners[type],
        i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    reverting: function reverting() {
      return _reverting;
    },
    context: function context(toAdd) {
      if (toAdd && _context) {
        _context.data.push(toAdd);

        toAdd._ctx = _context;
      }

      return _context;
    },
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt, v;
    this.tween = tween;

    for (p in vars) {
      v = target.getAttribute(p) || "";
      pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
      pt.op = p;
      pt.b = v; // record the beginning value so we can revert()

      this._props.push(p);
    }
  },
  render: function render(ratio, data) {
    var pt = data._pt;

    while (pt) {
      _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)

      pt = pt._next;
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.12.5";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.


// CONCATENATED MODULE: ./node_modules/gsap/CSSPlugin.js
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var CSSPlugin_win,
    CSSPlugin_doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    CSSPlugin_reverting,
    CSSPlugin_windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    CSSPlugin_bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _saveStyle = function _saveStyle(property, isNotCSS) {
  var _this = this;

  var target = this.target,
      style = target.style,
      cache = target._gsap;

  if (property in _transformProps && style) {
    this.tfm = this.tfm || {};

    if (property !== "transform") {
      property = _propertyAliases[property] || property;
      ~property.indexOf(",") ? property.split(",").forEach(function (a) {
        return _this.tfm[a] = CSSPlugin_get(target, a);
      }) : this.tfm[property] = cache.x ? cache[property] : CSSPlugin_get(target, property); // note: scale would map to "scaleX,scaleY", thus we loop and apply them both.

      property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
    } else {
      return _propertyAliases.transform.split(",").forEach(function (p) {
        return _saveStyle.call(_this, p, isNotCSS);
      });
    }

    if (this.props.indexOf(_transformProp) >= 0) {
      return;
    }

    if (cache.svg) {
      this.svgo = target.getAttribute("data-svg-origin");
      this.props.push(_transformOriginProp, isNotCSS, "");
    }

    property = _transformProp;
  }

  (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
},
    _removeIndependentTransforms = function _removeIndependentTransforms(style) {
  if (style.translate) {
    style.removeProperty("translate");
    style.removeProperty("scale");
    style.removeProperty("rotate");
  }
},
    _revertStyle = function _revertStyle() {
  var props = this.props,
      target = this.target,
      style = target.style,
      cache = target._gsap,
      i,
      p;

  for (i = 0; i < props.length; i += 3) {
    // stored like this: property, isNotCSS, value
    props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
  }

  if (this.tfm) {
    for (p in this.tfm) {
      cache[p] = this.tfm[p];
    }

    if (cache.svg) {
      cache.renderTransform();
      target.setAttribute("data-svg-origin", this.svgo || "");
    }

    i = CSSPlugin_reverting();

    if ((!i || !i.isStart) && !style[_transformProp]) {
      _removeIndependentTransforms(style);

      if (cache.zOrigin && style[_transformOriginProp]) {
        style[_transformOriginProp] += " " + cache.zOrigin + "px"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.

        cache.zOrigin = 0;
        cache.renderTransform();
      }

      cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.
    }
  }
},
    CSSPlugin_getStyleSaver = function _getStyleSaver(target, properties) {
  var saver = {
    target: target,
    props: [],
    revert: _revertStyle,
    save: _saveStyle
  };
  target._gsap || gsap.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.

  properties && properties.split(",").forEach(function (p) {
    return saver.save(p);
  });
  return saver;
},
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = CSSPlugin_doc.createElementNS ? CSSPlugin_doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : CSSPlugin_doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e && e.style ? e : CSSPlugin_doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    CSSPlugin_initCore = function _initCore() {
  if (CSSPlugin_windowExists() && window.document) {
    CSSPlugin_win = window;
    CSSPlugin_doc = CSSPlugin_win.document;
    _docElement = CSSPlugin_doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    CSSPlugin_reverting = gsap.core.reverting;
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style,
        first2Chars;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      first2Chars = property.substr(0, 2);

      if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    CSSPlugin_addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    _nonStandardLayouts = {
  grid: 1,
  flex: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
CSSPlugin_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === CSSPlugin_doc || !parent.appendChild) {
    parent = CSSPlugin_doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
    return _round(curValue / cache.width * amount);
  } else {
    if (toPercent && (property === "height" || property === "width")) {
      // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.
      var v = target.style[property];
      target.style[property] = amount + unit;
      px = target[measureProperty];
      v ? target.style[property] = v : _removeProperty(target, property);
    } else {
      (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
      parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

      parent.appendChild(_tempDiv);
      px = _tempDiv[measureProperty];
      parent.removeChild(_tempDiv);
      style.position = "absolute";
    }

    if (horizontal && toPercent) {
      cache = _getCache(parent);
      cache.time = _ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    CSSPlugin_get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || CSSPlugin_initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = CSSPlugin_parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? CSSPlugin_convertToUnit(target, property, value, unit) + unit : value;
},
    CSSPlugin_tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; // ensure values are strings

  end += "";

  if (end === "auto") {
    startValue = target.style[prop];
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
  }

  a = [start, end];

  _colorStringFilter(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_numWithUnitExp) || [];
  endValues = end.match(_numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = CSSPlugin_convertToUnit(target, prop, startValue, endUnit) || 0;
        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        CSSPlugin_parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;

        _removeIndependentTransforms(style);
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    CSSPlugin_getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
},
    CSSPlugin_getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || _getCache(target),
      style = target.style,
      matrix = CSSPlugin_getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextElementSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = CSSPlugin_getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || CSSPlugin_getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin); // if (!("xOrigin" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration
    // 	xOrigin -= bounds.x;
    // 	yOrigin -= bounds.y;
    // }
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    CSSPlugin_addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    CSSPlugin_addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    CSSPlugin_addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    CSSPlugin_addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    CSSPlugin_parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      cs = getComputedStyle(target),
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));

  if (cs.translate) {
    // accommodate independent transforms by combining them into normal ones.
    if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
      style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
    }

    style.scale = style.rotate = style.translate = "none";
  }

  matrix = CSSPlugin_getMatrix(target, cache.svg);

  if (cache.svg) {
    if (cache.uncache) {
      // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.
      t2 = target.getBBox();
      origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
      t1 = "";
    } else {
      t1 = !uncache && target.getAttribute("data-svg-origin"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.
    }

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = _round(Math.sqrt(a * a + b * b + c * c));
      scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  uncache = uncache || cache.uncache;
  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = _round(scaleX);
  cache.scaleY = _round(scaleY);
  cache.rotation = _round(rotation) + deg;
  cache.rotationX = _round(rotationX) + deg;
  cache.rotationY = _round(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _config.force3D;
  cache.renderTransform = cache.svg ? CSSPlugin_renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
CSSPlugin_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = getUnit(start);
  return _round(parseFloat(start) + parseFloat(CSSPlugin_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = CSSPlugin_addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = CSSPlugin_addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = CSSPlugin_addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    CSSPlugin_renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = _round(a11);
    a21 = _round(a21);
    a12 = _round(a12);
    a22 = _round(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = CSSPlugin_convertToUnit(target, "x", x, "px");
    ty = CSSPlugin_convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = _round(tx + xPercent / 100 * temp.width);
    ty = _round(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)
},
    CSSPlugin_addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
  var cap = 360,
      isString = _isString(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * CSSPlugin_bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * CSSPlugin_bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    CSSPlugin_addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = CSSPlugin_parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = CSSPlugin_parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = getUnit(startValue);
      endUnit = getUnit(endValue);
      startNum = startUnit !== endUnit ? CSSPlugin_convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


_forEachName("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return CSSPlugin_get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: CSSPlugin_initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority,
        inlineProps;
    _pluginInitted || CSSPlugin_initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps

    this.styles = this.styles || CSSPlugin_getStyleSaver(target);
    inlineProps = this.styles.props;
    this.tween = tween;

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = _replaceRandom(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _colorExp.lastIndex = 0;

        if (!_colorExp.test(startValue)) {
          // colors don't have units
          startUnit = getUnit(startValue);
          endUnit = getUnit(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = CSSPlugin_convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
        inlineProps.push(p, 0, style[p]);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
          getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p] || getUnit(CSSPlugin_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = CSSPlugin_get(target, p)); // can't work with relative values
        } else {
          startValue = CSSPlugin_get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && CSSPlugin_get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            inlineProps.push("visibility", 0, style.visibility);

            CSSPlugin_addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          this.styles.save(p);

          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || CSSPlugin_parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
            this._pt.u = 0;
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && CSSPlugin_addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              CSSPlugin_addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            CSSPlugin_addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);

            continue;
          } else if (p === "smoothOrigin") {
            CSSPlugin_addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            CSSPlugin_addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = CSSPlugin_convertToUnit(target, p, startValue, endUnit));
          this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
          } else if (p !== "parseTransform") {
            _missingPlugin(p, endValue);

            continue;
          }
        } else {
          CSSPlugin_tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
        }

        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
        props.push(p);
      }
    }

    hasPriority && _sortPropTweensByPriority(this);
  },
  render: function render(ratio, data) {
    if (data.tween._time || !CSSPlugin_reverting()) {
      var pt = data._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    } else {
      data.styles.revert();
    }
  },
  get: CSSPlugin_get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || CSSPlugin_get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: CSSPlugin_getMatrix
  }
};
gsap.utils.checkPrefix = _checkPropPrefix;
gsap.core.getStyleSaver = CSSPlugin_getStyleSaver;

(function (positionAndScale, rotation, others, aliases) {
  var all = _forEachName(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  _forEachName(rotation, function (name) {
    _config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  _forEachName(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

_forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _config.units[name] = "px";
});

gsap.registerPlugin(CSSPlugin);

// CONCATENATED MODULE: ./node_modules/gsap/index.js


var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;


/***/ })
/******/ ]);
});
//# sourceMappingURL=escher.js.map